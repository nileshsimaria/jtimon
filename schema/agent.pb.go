// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: agent.proto

package schema

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Result of the operation
type ReturnCode int32

const (
	ReturnCode_SUCCESS               ReturnCode = 0
	ReturnCode_NO_SUBSCRIPTION_ENTRY ReturnCode = 1
	ReturnCode_UNKNOWN_ERROR         ReturnCode = 2
)

var ReturnCode_name = map[int32]string{
	0: "SUCCESS",
	1: "NO_SUBSCRIPTION_ENTRY",
	2: "UNKNOWN_ERROR",
}

var ReturnCode_value = map[string]int32{
	"SUCCESS":               0,
	"NO_SUBSCRIPTION_ENTRY": 1,
	"UNKNOWN_ERROR":         2,
}

func (x ReturnCode) String() string {
	return proto.EnumName(ReturnCode_name, int32(x))
}

func (ReturnCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{0}
}

// Verbosity Level
type VerbosityLevel int32

const (
	VerbosityLevel_DETAIL VerbosityLevel = 0
	VerbosityLevel_TERSE  VerbosityLevel = 1
	VerbosityLevel_BRIEF  VerbosityLevel = 2
)

var VerbosityLevel_name = map[int32]string{
	0: "DETAIL",
	1: "TERSE",
	2: "BRIEF",
}

var VerbosityLevel_value = map[string]int32{
	"DETAIL": 0,
	"TERSE":  1,
	"BRIEF":  2,
}

func (x VerbosityLevel) String() string {
	return proto.EnumName(VerbosityLevel_name, int32(x))
}

func (VerbosityLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{1}
}

// Encoding Type Supported
type EncodingType int32

const (
	EncodingType_UNDEFINED EncodingType = 0
	EncodingType_XML       EncodingType = 1
	EncodingType_JSON_IETF EncodingType = 2
	EncodingType_PROTO3    EncodingType = 3
)

var EncodingType_name = map[int32]string{
	0: "UNDEFINED",
	1: "XML",
	2: "JSON_IETF",
	3: "PROTO3",
}

var EncodingType_value = map[string]int32{
	"UNDEFINED": 0,
	"XML":       1,
	"JSON_IETF": 2,
	"PROTO3":    3,
}

func (x EncodingType) String() string {
	return proto.EnumName(EncodingType_name, int32(x))
}

func (EncodingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{2}
}

// Subscription modes
type SubscriptionMode int32

const (
	SubscriptionMode_LONG_LIVED SubscriptionMode = 0
	// Not supported
	SubscriptionMode_ONE_OFF SubscriptionMode = 1
	// Not supported
	SubscriptionMode_POLL SubscriptionMode = 2
)

var SubscriptionMode_name = map[int32]string{
	0: "LONG_LIVED",
	1: "ONE_OFF",
	2: "POLL",
}

var SubscriptionMode_value = map[string]int32{
	"LONG_LIVED": 0,
	"ONE_OFF":    1,
	"POLL":       2,
}

func (x SubscriptionMode) String() string {
	return proto.EnumName(SubscriptionMode_name, int32(x))
}

func (SubscriptionMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{3}
}

// Collector endpoints to send data specified as an ip+port combination.
type Collector struct {
	// IP address of collector endpoint
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Transport protocol port number for the collector destination.
	Port                 uint32   `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Collector) Reset()         { *m = Collector{} }
func (m *Collector) String() string { return proto.CompactTextString(m) }
func (*Collector) ProtoMessage()    {}
func (*Collector) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{0}
}
func (m *Collector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Collector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Collector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Collector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Collector.Merge(m, src)
}
func (m *Collector) XXX_Size() int {
	return m.Size()
}
func (m *Collector) XXX_DiscardUnknown() {
	xxx_messageInfo_Collector.DiscardUnknown(m)
}

var xxx_messageInfo_Collector proto.InternalMessageInfo

func (m *Collector) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Collector) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// Data associated with a telemetry subscription
type SubscriptionInput struct {
	// List of optional collector endpoints to send data for
	// this subscription.
	// If no collector destinations are specified, the collector
	// destination is assumed to be the requester on the rpc channel.
	CollectorList        []*Collector `protobuf:"bytes,1,rep,name=collector_list,json=collectorList,proto3" json:"collector_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *SubscriptionInput) Reset()         { *m = SubscriptionInput{} }
func (m *SubscriptionInput) String() string { return proto.CompactTextString(m) }
func (*SubscriptionInput) ProtoMessage()    {}
func (*SubscriptionInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{1}
}
func (m *SubscriptionInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionInput.Merge(m, src)
}
func (m *SubscriptionInput) XXX_Size() int {
	return m.Size()
}
func (m *SubscriptionInput) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionInput.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionInput proto.InternalMessageInfo

func (m *SubscriptionInput) GetCollectorList() []*Collector {
	if m != nil {
		return m.CollectorList
	}
	return nil
}

// Data model path
type Path struct {
	// Data model path of interest
	// Path specification for elements of OpenConfig data models
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Regular expression to be used in filtering state leaves
	Filter string `protobuf:"bytes,2,opt,name=filter,proto3" json:"filter,omitempty"`
	// If this is set to true, the target device will only send
	// updates to the collector upon a change in data value
	SuppressUnchanged bool `protobuf:"varint,3,opt,name=suppress_unchanged,json=suppressUnchanged,proto3" json:"suppress_unchanged,omitempty"`
	// Maximum time in ms the target device may go without sending
	// a message to the collector. If this time expires with
	// suppress-unchanged set, the target device must send an update
	// message regardless if the data values have changed.
	MaxSilentInterval uint32 `protobuf:"varint,4,opt,name=max_silent_interval,json=maxSilentInterval,proto3" json:"max_silent_interval,omitempty"`
	// Time in ms between collection and transmission of the
	// specified data to the collector platform. The target device
	// will sample the corresponding data (e.g,. a counter) and
	// immediately send to the collector destination.
	//
	// If sample-frequency is set to 0, then the network device
	// must emit an update upon every datum change.
	SampleFrequency uint32 `protobuf:"varint,5,opt,name=sample_frequency,json=sampleFrequency,proto3" json:"sample_frequency,omitempty"`
	// EOM needed for each walk cycle of this path?
	//   For periodic sensor, applicable for each complete reap
	//   For event sensor, applicable when initial dump is over
	//     (same as EOS)
	NeedEom bool `protobuf:"varint,6,opt,name=need_eom,json=needEom,proto3" json:"need_eom,omitempty"`
	// To denote if the path is from OC, IETF
	// or some other standards
	Origin string `protobuf:"bytes,100,opt,name=origin,proto3" json:"origin,omitempty"`
	// Allow the target to decide if the updates need to be sent
	// periodically or on-change for the leaves under this path.
	//   If this is set to true and sample_frequency is non-zero,
	//     then whichever leaves support on-change will be
	//     streamed on change and other leaves will be streamed
	//     at the cadence requested as per sample_frequency.
	//   If this is set to true and sample_frequency is zero,
	//     then it will be considered as on-change only.
	//   If this is set to false, then the streaming will be
	//     will be periodic if sample_frequency is non-zero
	//     and will be on-change if sample_frequency is zero.
	TargetDefined        bool     `protobuf:"varint,101,opt,name=target_defined,json=targetDefined,proto3" json:"target_defined,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Path) Reset()         { *m = Path{} }
func (m *Path) String() string { return proto.CompactTextString(m) }
func (*Path) ProtoMessage()    {}
func (*Path) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{2}
}
func (m *Path) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Path) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Path.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Path) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Path.Merge(m, src)
}
func (m *Path) XXX_Size() int {
	return m.Size()
}
func (m *Path) XXX_DiscardUnknown() {
	xxx_messageInfo_Path.DiscardUnknown(m)
}

var xxx_messageInfo_Path proto.InternalMessageInfo

func (m *Path) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Path) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *Path) GetSuppressUnchanged() bool {
	if m != nil {
		return m.SuppressUnchanged
	}
	return false
}

func (m *Path) GetMaxSilentInterval() uint32 {
	if m != nil {
		return m.MaxSilentInterval
	}
	return 0
}

func (m *Path) GetSampleFrequency() uint32 {
	if m != nil {
		return m.SampleFrequency
	}
	return 0
}

func (m *Path) GetNeedEom() bool {
	if m != nil {
		return m.NeedEom
	}
	return false
}

func (m *Path) GetOrigin() string {
	if m != nil {
		return m.Origin
	}
	return ""
}

func (m *Path) GetTargetDefined() bool {
	if m != nil {
		return m.TargetDefined
	}
	return false
}

// Configure subscription request additional features.
type SubscriptionAdditionalConfig struct {
	// limit the number of records sent in the stream
	LimitRecords int32 `protobuf:"varint,1,opt,name=limit_records,json=limitRecords,proto3" json:"limit_records,omitempty"`
	// limit the time the stream remains open
	LimitTimeSeconds int32 `protobuf:"varint,2,opt,name=limit_time_seconds,json=limitTimeSeconds,proto3" json:"limit_time_seconds,omitempty"`
	// EOS needed for this subscription?
	NeedEos bool `protobuf:"varint,3,opt,name=need_eos,json=needEos,proto3" json:"need_eos,omitempty"`
	// Subscription mode (long-lived, one_off or poll)
	Mode                 SubscriptionMode `protobuf:"varint,4,opt,name=mode,proto3,enum=telemetry.SubscriptionMode" json:"mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SubscriptionAdditionalConfig) Reset()         { *m = SubscriptionAdditionalConfig{} }
func (m *SubscriptionAdditionalConfig) String() string { return proto.CompactTextString(m) }
func (*SubscriptionAdditionalConfig) ProtoMessage()    {}
func (*SubscriptionAdditionalConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{3}
}
func (m *SubscriptionAdditionalConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionAdditionalConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionAdditionalConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionAdditionalConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionAdditionalConfig.Merge(m, src)
}
func (m *SubscriptionAdditionalConfig) XXX_Size() int {
	return m.Size()
}
func (m *SubscriptionAdditionalConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionAdditionalConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionAdditionalConfig proto.InternalMessageInfo

func (m *SubscriptionAdditionalConfig) GetLimitRecords() int32 {
	if m != nil {
		return m.LimitRecords
	}
	return 0
}

func (m *SubscriptionAdditionalConfig) GetLimitTimeSeconds() int32 {
	if m != nil {
		return m.LimitTimeSeconds
	}
	return 0
}

func (m *SubscriptionAdditionalConfig) GetNeedEos() bool {
	if m != nil {
		return m.NeedEos
	}
	return false
}

func (m *SubscriptionAdditionalConfig) GetMode() SubscriptionMode {
	if m != nil {
		return m.Mode
	}
	return SubscriptionMode_LONG_LIVED
}

// Message sent for a telemetry subscription request
type SubscriptionRequest struct {
	// Data associated with a telemetry subscription
	Input *SubscriptionInput `protobuf:"bytes,1,opt,name=input,proto3" json:"input,omitempty"`
	// List of data models paths and filters
	// which are used in a telemetry operation.
	PathList []*Path `protobuf:"bytes,2,rep,name=path_list,json=pathList,proto3" json:"path_list,omitempty"`
	// The below configuration is not defined in Openconfig RPC.
	// It is a proposed extension to configure additional
	// subscription request features.
	AdditionalConfig     *SubscriptionAdditionalConfig `protobuf:"bytes,3,opt,name=additional_config,json=additionalConfig,proto3" json:"additional_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *SubscriptionRequest) Reset()         { *m = SubscriptionRequest{} }
func (m *SubscriptionRequest) String() string { return proto.CompactTextString(m) }
func (*SubscriptionRequest) ProtoMessage()    {}
func (*SubscriptionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{4}
}
func (m *SubscriptionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionRequest.Merge(m, src)
}
func (m *SubscriptionRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubscriptionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionRequest proto.InternalMessageInfo

func (m *SubscriptionRequest) GetInput() *SubscriptionInput {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *SubscriptionRequest) GetPathList() []*Path {
	if m != nil {
		return m.PathList
	}
	return nil
}

func (m *SubscriptionRequest) GetAdditionalConfig() *SubscriptionAdditionalConfig {
	if m != nil {
		return m.AdditionalConfig
	}
	return nil
}

// Response message to a telemetry subscription creation or get request.
type SubscriptionResponse struct {
	// Unique id for the subscription on the device. This is
	// generated by the device and returned in a subscription
	// request or when listing existing subscriptions
	SubscriptionId       uint32   `protobuf:"varint,1,opt,name=subscription_id,json=subscriptionId,proto3" json:"subscription_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscriptionResponse) Reset()         { *m = SubscriptionResponse{} }
func (m *SubscriptionResponse) String() string { return proto.CompactTextString(m) }
func (*SubscriptionResponse) ProtoMessage()    {}
func (*SubscriptionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{5}
}
func (m *SubscriptionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionResponse.Merge(m, src)
}
func (m *SubscriptionResponse) XXX_Size() int {
	return m.Size()
}
func (m *SubscriptionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionResponse proto.InternalMessageInfo

func (m *SubscriptionResponse) GetSubscriptionId() uint32 {
	if m != nil {
		return m.SubscriptionId
	}
	return 0
}

type SubscriptionReply struct {
	// Response message to a telemetry subscription creation or
	// get request.
	Response *SubscriptionResponse `protobuf:"bytes,1,opt,name=response,proto3" json:"response,omitempty"`
	// List of data models paths and filters
	// which are used in a telemetry operation.
	PathList             []*Path  `protobuf:"bytes,2,rep,name=path_list,json=pathList,proto3" json:"path_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscriptionReply) Reset()         { *m = SubscriptionReply{} }
func (m *SubscriptionReply) String() string { return proto.CompactTextString(m) }
func (*SubscriptionReply) ProtoMessage()    {}
func (*SubscriptionReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{6}
}
func (m *SubscriptionReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionReply.Merge(m, src)
}
func (m *SubscriptionReply) XXX_Size() int {
	return m.Size()
}
func (m *SubscriptionReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionReply.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionReply proto.InternalMessageInfo

func (m *SubscriptionReply) GetResponse() *SubscriptionResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *SubscriptionReply) GetPathList() []*Path {
	if m != nil {
		return m.PathList
	}
	return nil
}

// Simple Key-value, where value could be one of scalar types
type KeyValue struct {
	// Key
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// One of possible values
	//
	// Types that are valid to be assigned to Value:
	//	*KeyValue_DoubleValue
	//	*KeyValue_IntValue
	//	*KeyValue_UintValue
	//	*KeyValue_SintValue
	//	*KeyValue_BoolValue
	//	*KeyValue_StrValue
	//	*KeyValue_BytesValue
	//	*KeyValue_FloatValue
	Value                isKeyValue_Value `protobuf_oneof:"value"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *KeyValue) Reset()         { *m = KeyValue{} }
func (m *KeyValue) String() string { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()    {}
func (*KeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{7}
}
func (m *KeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValue.Merge(m, src)
}
func (m *KeyValue) XXX_Size() int {
	return m.Size()
}
func (m *KeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValue proto.InternalMessageInfo

type isKeyValue_Value interface {
	isKeyValue_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type KeyValue_DoubleValue struct {
	DoubleValue float64 `protobuf:"fixed64,5,opt,name=double_value,json=doubleValue,proto3,oneof" json:"double_value,omitempty"`
}
type KeyValue_IntValue struct {
	IntValue int64 `protobuf:"varint,6,opt,name=int_value,json=intValue,proto3,oneof" json:"int_value,omitempty"`
}
type KeyValue_UintValue struct {
	UintValue uint64 `protobuf:"varint,7,opt,name=uint_value,json=uintValue,proto3,oneof" json:"uint_value,omitempty"`
}
type KeyValue_SintValue struct {
	SintValue int64 `protobuf:"zigzag64,8,opt,name=sint_value,json=sintValue,proto3,oneof" json:"sint_value,omitempty"`
}
type KeyValue_BoolValue struct {
	BoolValue bool `protobuf:"varint,9,opt,name=bool_value,json=boolValue,proto3,oneof" json:"bool_value,omitempty"`
}
type KeyValue_StrValue struct {
	StrValue string `protobuf:"bytes,10,opt,name=str_value,json=strValue,proto3,oneof" json:"str_value,omitempty"`
}
type KeyValue_BytesValue struct {
	BytesValue []byte `protobuf:"bytes,11,opt,name=bytes_value,json=bytesValue,proto3,oneof" json:"bytes_value,omitempty"`
}
type KeyValue_FloatValue struct {
	FloatValue float32 `protobuf:"fixed32,12,opt,name=float_value,json=floatValue,proto3,oneof" json:"float_value,omitempty"`
}

func (*KeyValue_DoubleValue) isKeyValue_Value() {}
func (*KeyValue_IntValue) isKeyValue_Value()    {}
func (*KeyValue_UintValue) isKeyValue_Value()   {}
func (*KeyValue_SintValue) isKeyValue_Value()   {}
func (*KeyValue_BoolValue) isKeyValue_Value()   {}
func (*KeyValue_StrValue) isKeyValue_Value()    {}
func (*KeyValue_BytesValue) isKeyValue_Value()  {}
func (*KeyValue_FloatValue) isKeyValue_Value()  {}

func (m *KeyValue) GetValue() isKeyValue_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *KeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValue) GetDoubleValue() float64 {
	if x, ok := m.GetValue().(*KeyValue_DoubleValue); ok {
		return x.DoubleValue
	}
	return 0
}

func (m *KeyValue) GetIntValue() int64 {
	if x, ok := m.GetValue().(*KeyValue_IntValue); ok {
		return x.IntValue
	}
	return 0
}

func (m *KeyValue) GetUintValue() uint64 {
	if x, ok := m.GetValue().(*KeyValue_UintValue); ok {
		return x.UintValue
	}
	return 0
}

func (m *KeyValue) GetSintValue() int64 {
	if x, ok := m.GetValue().(*KeyValue_SintValue); ok {
		return x.SintValue
	}
	return 0
}

func (m *KeyValue) GetBoolValue() bool {
	if x, ok := m.GetValue().(*KeyValue_BoolValue); ok {
		return x.BoolValue
	}
	return false
}

func (m *KeyValue) GetStrValue() string {
	if x, ok := m.GetValue().(*KeyValue_StrValue); ok {
		return x.StrValue
	}
	return ""
}

func (m *KeyValue) GetBytesValue() []byte {
	if x, ok := m.GetValue().(*KeyValue_BytesValue); ok {
		return x.BytesValue
	}
	return nil
}

func (m *KeyValue) GetFloatValue() float32 {
	if x, ok := m.GetValue().(*KeyValue_FloatValue); ok {
		return x.FloatValue
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*KeyValue) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*KeyValue_DoubleValue)(nil),
		(*KeyValue_IntValue)(nil),
		(*KeyValue_UintValue)(nil),
		(*KeyValue_SintValue)(nil),
		(*KeyValue_BoolValue)(nil),
		(*KeyValue_StrValue)(nil),
		(*KeyValue_BytesValue)(nil),
		(*KeyValue_FloatValue)(nil),
	}
}

type OpenConfigData struct {
	// router name:export IP address
	SystemId string `protobuf:"bytes,1,opt,name=system_id,json=systemId,proto3" json:"system_id,omitempty"`
	// line card / RE (slot number)
	ComponentId uint32 `protobuf:"varint,2,opt,name=component_id,json=componentId,proto3" json:"component_id,omitempty"`
	// PFE (if applicable)
	SubComponentId uint32 `protobuf:"varint,3,opt,name=sub_component_id,json=subComponentId,proto3" json:"sub_component_id,omitempty"`
	// Path specification for elements of OpenConfig data models
	Path string `protobuf:"bytes,4,opt,name=path,proto3" json:"path,omitempty"`
	// Sequence number, monotonically increasing for each
	// system_id, component_id, sub_component_id + path.
	SequenceNumber uint64 `protobuf:"varint,5,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	// timestamp (milliseconds since epoch)
	Timestamp uint64 `protobuf:"varint,6,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// List of key-value pairs
	Kv []*KeyValue `protobuf:"bytes,7,rep,name=kv,proto3" json:"kv,omitempty"`
	// For delete. If filled, it indicates delete
	Delete []*Delete `protobuf:"bytes,8,rep,name=delete,proto3" json:"delete,omitempty"`
	// [Deprecated] If filled, it indicates end of marker for the
	// respective path in the list.
	Eom []*Eom `protobuf:"bytes,9,rep,name=eom,proto3" json:"eom,omitempty"` // Deprecated: Do not use.
	// If filled, it indicates end of sync for complete subscription
	SyncResponse bool `protobuf:"varint,10,opt,name=sync_response,json=syncResponse,proto3" json:"sync_response,omitempty"`
	// Indicates end of wrap
	IsWrap               bool     `protobuf:"varint,11,opt,name=is_wrap,json=isWrap,proto3" json:"is_wrap,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpenConfigData) Reset()         { *m = OpenConfigData{} }
func (m *OpenConfigData) String() string { return proto.CompactTextString(m) }
func (*OpenConfigData) ProtoMessage()    {}
func (*OpenConfigData) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{8}
}
func (m *OpenConfigData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenConfigData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenConfigData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenConfigData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenConfigData.Merge(m, src)
}
func (m *OpenConfigData) XXX_Size() int {
	return m.Size()
}
func (m *OpenConfigData) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenConfigData.DiscardUnknown(m)
}

var xxx_messageInfo_OpenConfigData proto.InternalMessageInfo

func (m *OpenConfigData) GetSystemId() string {
	if m != nil {
		return m.SystemId
	}
	return ""
}

func (m *OpenConfigData) GetComponentId() uint32 {
	if m != nil {
		return m.ComponentId
	}
	return 0
}

func (m *OpenConfigData) GetSubComponentId() uint32 {
	if m != nil {
		return m.SubComponentId
	}
	return 0
}

func (m *OpenConfigData) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *OpenConfigData) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *OpenConfigData) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *OpenConfigData) GetKv() []*KeyValue {
	if m != nil {
		return m.Kv
	}
	return nil
}

func (m *OpenConfigData) GetDelete() []*Delete {
	if m != nil {
		return m.Delete
	}
	return nil
}

// Deprecated: Do not use.
func (m *OpenConfigData) GetEom() []*Eom {
	if m != nil {
		return m.Eom
	}
	return nil
}

func (m *OpenConfigData) GetSyncResponse() bool {
	if m != nil {
		return m.SyncResponse
	}
	return false
}

func (m *OpenConfigData) GetIsWrap() bool {
	if m != nil {
		return m.IsWrap
	}
	return false
}

// Message indicating delete for a particular path
type Delete struct {
	Path                 string   `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Delete) Reset()         { *m = Delete{} }
func (m *Delete) String() string { return proto.CompactTextString(m) }
func (*Delete) ProtoMessage()    {}
func (*Delete) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{9}
}
func (m *Delete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Delete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Delete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Delete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Delete.Merge(m, src)
}
func (m *Delete) XXX_Size() int {
	return m.Size()
}
func (m *Delete) XXX_DiscardUnknown() {
	xxx_messageInfo_Delete.DiscardUnknown(m)
}

var xxx_messageInfo_Delete proto.InternalMessageInfo

func (m *Delete) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// Message indicating EOM for a particular path
type Eom struct {
	Path                 string   `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Eom) Reset()         { *m = Eom{} }
func (m *Eom) String() string { return proto.CompactTextString(m) }
func (*Eom) ProtoMessage()    {}
func (*Eom) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{10}
}
func (m *Eom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Eom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Eom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Eom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Eom.Merge(m, src)
}
func (m *Eom) XXX_Size() int {
	return m.Size()
}
func (m *Eom) XXX_DiscardUnknown() {
	xxx_messageInfo_Eom.DiscardUnknown(m)
}

var xxx_messageInfo_Eom proto.InternalMessageInfo

func (m *Eom) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// Message sent for a telemetry subscription cancellation request
type CancelSubscriptionRequest struct {
	// Subscription identifier as returned by the device when
	// subscription was requested
	SubscriptionId       uint32   `protobuf:"varint,1,opt,name=subscription_id,json=subscriptionId,proto3" json:"subscription_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CancelSubscriptionRequest) Reset()         { *m = CancelSubscriptionRequest{} }
func (m *CancelSubscriptionRequest) String() string { return proto.CompactTextString(m) }
func (*CancelSubscriptionRequest) ProtoMessage()    {}
func (*CancelSubscriptionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{11}
}
func (m *CancelSubscriptionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelSubscriptionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelSubscriptionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelSubscriptionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelSubscriptionRequest.Merge(m, src)
}
func (m *CancelSubscriptionRequest) XXX_Size() int {
	return m.Size()
}
func (m *CancelSubscriptionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelSubscriptionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CancelSubscriptionRequest proto.InternalMessageInfo

func (m *CancelSubscriptionRequest) GetSubscriptionId() uint32 {
	if m != nil {
		return m.SubscriptionId
	}
	return 0
}

// Reply to telemetry subscription cancellation request
type CancelSubscriptionReply struct {
	// Return code
	Code ReturnCode `protobuf:"varint,1,opt,name=code,proto3,enum=telemetry.ReturnCode" json:"code,omitempty"`
	// Return code string
	CodeStr              string   `protobuf:"bytes,2,opt,name=code_str,json=codeStr,proto3" json:"code_str,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CancelSubscriptionReply) Reset()         { *m = CancelSubscriptionReply{} }
func (m *CancelSubscriptionReply) String() string { return proto.CompactTextString(m) }
func (*CancelSubscriptionReply) ProtoMessage()    {}
func (*CancelSubscriptionReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{12}
}
func (m *CancelSubscriptionReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelSubscriptionReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelSubscriptionReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelSubscriptionReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelSubscriptionReply.Merge(m, src)
}
func (m *CancelSubscriptionReply) XXX_Size() int {
	return m.Size()
}
func (m *CancelSubscriptionReply) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelSubscriptionReply.DiscardUnknown(m)
}

var xxx_messageInfo_CancelSubscriptionReply proto.InternalMessageInfo

func (m *CancelSubscriptionReply) GetCode() ReturnCode {
	if m != nil {
		return m.Code
	}
	return ReturnCode_SUCCESS
}

func (m *CancelSubscriptionReply) GetCodeStr() string {
	if m != nil {
		return m.CodeStr
	}
	return ""
}

// Message sent for a telemetry get request
type GetSubscriptionsRequest struct {
	// Subscription identifier as returned by the device when
	// subscription was requested
	// --- or ---
	// 0xFFFFFFFF for all subscription identifiers
	SubscriptionId       uint32   `protobuf:"varint,1,opt,name=subscription_id,json=subscriptionId,proto3" json:"subscription_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetSubscriptionsRequest) Reset()         { *m = GetSubscriptionsRequest{} }
func (m *GetSubscriptionsRequest) String() string { return proto.CompactTextString(m) }
func (*GetSubscriptionsRequest) ProtoMessage()    {}
func (*GetSubscriptionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{13}
}
func (m *GetSubscriptionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSubscriptionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSubscriptionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSubscriptionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSubscriptionsRequest.Merge(m, src)
}
func (m *GetSubscriptionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetSubscriptionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSubscriptionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSubscriptionsRequest proto.InternalMessageInfo

func (m *GetSubscriptionsRequest) GetSubscriptionId() uint32 {
	if m != nil {
		return m.SubscriptionId
	}
	return 0
}

// Reply to telemetry subscription get request
type GetSubscriptionsReply struct {
	// List of current telemetry subscriptions
	SubscriptionList     []*SubscriptionReply `protobuf:"bytes,1,rep,name=subscription_list,json=subscriptionList,proto3" json:"subscription_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *GetSubscriptionsReply) Reset()         { *m = GetSubscriptionsReply{} }
func (m *GetSubscriptionsReply) String() string { return proto.CompactTextString(m) }
func (*GetSubscriptionsReply) ProtoMessage()    {}
func (*GetSubscriptionsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{14}
}
func (m *GetSubscriptionsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSubscriptionsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSubscriptionsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSubscriptionsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSubscriptionsReply.Merge(m, src)
}
func (m *GetSubscriptionsReply) XXX_Size() int {
	return m.Size()
}
func (m *GetSubscriptionsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSubscriptionsReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetSubscriptionsReply proto.InternalMessageInfo

func (m *GetSubscriptionsReply) GetSubscriptionList() []*SubscriptionReply {
	if m != nil {
		return m.SubscriptionList
	}
	return nil
}

// Message sent for telemetry agent operational states request
type GetOperationalStateRequest struct {
	// Per-subscription_id level operational state can be requested.
	//
	// Subscription identifier as returned by the device when
	// subscription was requested
	// --- or ---
	// 0xFFFFFFFF for all subscription identifiers including agent-level
	// operational stats
	// --- or ---
	// If subscription_id is not present then sent only agent-level
	// operational stats
	SubscriptionId uint32 `protobuf:"varint,1,opt,name=subscription_id,json=subscriptionId,proto3" json:"subscription_id,omitempty"`
	// Control verbosity of the output
	Verbosity            VerbosityLevel `protobuf:"varint,2,opt,name=verbosity,proto3,enum=telemetry.VerbosityLevel" json:"verbosity,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetOperationalStateRequest) Reset()         { *m = GetOperationalStateRequest{} }
func (m *GetOperationalStateRequest) String() string { return proto.CompactTextString(m) }
func (*GetOperationalStateRequest) ProtoMessage()    {}
func (*GetOperationalStateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{15}
}
func (m *GetOperationalStateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetOperationalStateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetOperationalStateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetOperationalStateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOperationalStateRequest.Merge(m, src)
}
func (m *GetOperationalStateRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetOperationalStateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOperationalStateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetOperationalStateRequest proto.InternalMessageInfo

func (m *GetOperationalStateRequest) GetSubscriptionId() uint32 {
	if m != nil {
		return m.SubscriptionId
	}
	return 0
}

func (m *GetOperationalStateRequest) GetVerbosity() VerbosityLevel {
	if m != nil {
		return m.Verbosity
	}
	return VerbosityLevel_DETAIL
}

// Reply to telemetry agent operational states request
type GetOperationalStateReply struct {
	// List of key-value pairs where
	//     key      = operational state definition
	//     value    = operational state value
	Kv                   []*KeyValue `protobuf:"bytes,1,rep,name=kv,proto3" json:"kv,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *GetOperationalStateReply) Reset()         { *m = GetOperationalStateReply{} }
func (m *GetOperationalStateReply) String() string { return proto.CompactTextString(m) }
func (*GetOperationalStateReply) ProtoMessage()    {}
func (*GetOperationalStateReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{16}
}
func (m *GetOperationalStateReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetOperationalStateReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetOperationalStateReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetOperationalStateReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOperationalStateReply.Merge(m, src)
}
func (m *GetOperationalStateReply) XXX_Size() int {
	return m.Size()
}
func (m *GetOperationalStateReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOperationalStateReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetOperationalStateReply proto.InternalMessageInfo

func (m *GetOperationalStateReply) GetKv() []*KeyValue {
	if m != nil {
		return m.Kv
	}
	return nil
}

// Message sent for a data encoding request
type DataEncodingRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DataEncodingRequest) Reset()         { *m = DataEncodingRequest{} }
func (m *DataEncodingRequest) String() string { return proto.CompactTextString(m) }
func (*DataEncodingRequest) ProtoMessage()    {}
func (*DataEncodingRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{17}
}
func (m *DataEncodingRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataEncodingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataEncodingRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataEncodingRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataEncodingRequest.Merge(m, src)
}
func (m *DataEncodingRequest) XXX_Size() int {
	return m.Size()
}
func (m *DataEncodingRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DataEncodingRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DataEncodingRequest proto.InternalMessageInfo

// Reply to data encodings supported request
type DataEncodingReply struct {
	EncodingList         []EncodingType `protobuf:"varint,1,rep,packed,name=encoding_list,json=encodingList,proto3,enum=telemetry.EncodingType" json:"encoding_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *DataEncodingReply) Reset()         { *m = DataEncodingReply{} }
func (m *DataEncodingReply) String() string { return proto.CompactTextString(m) }
func (*DataEncodingReply) ProtoMessage()    {}
func (*DataEncodingReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{18}
}
func (m *DataEncodingReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataEncodingReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataEncodingReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataEncodingReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataEncodingReply.Merge(m, src)
}
func (m *DataEncodingReply) XXX_Size() int {
	return m.Size()
}
func (m *DataEncodingReply) XXX_DiscardUnknown() {
	xxx_messageInfo_DataEncodingReply.DiscardUnknown(m)
}

var xxx_messageInfo_DataEncodingReply proto.InternalMessageInfo

func (m *DataEncodingReply) GetEncodingList() []EncodingType {
	if m != nil {
		return m.EncodingList
	}
	return nil
}

func init() {
	proto.RegisterEnum("telemetry.ReturnCode", ReturnCode_name, ReturnCode_value)
	proto.RegisterEnum("telemetry.VerbosityLevel", VerbosityLevel_name, VerbosityLevel_value)
	proto.RegisterEnum("telemetry.EncodingType", EncodingType_name, EncodingType_value)
	proto.RegisterEnum("telemetry.SubscriptionMode", SubscriptionMode_name, SubscriptionMode_value)
	proto.RegisterType((*Collector)(nil), "telemetry.Collector")
	proto.RegisterType((*SubscriptionInput)(nil), "telemetry.SubscriptionInput")
	proto.RegisterType((*Path)(nil), "telemetry.Path")
	proto.RegisterType((*SubscriptionAdditionalConfig)(nil), "telemetry.SubscriptionAdditionalConfig")
	proto.RegisterType((*SubscriptionRequest)(nil), "telemetry.SubscriptionRequest")
	proto.RegisterType((*SubscriptionResponse)(nil), "telemetry.SubscriptionResponse")
	proto.RegisterType((*SubscriptionReply)(nil), "telemetry.SubscriptionReply")
	proto.RegisterType((*KeyValue)(nil), "telemetry.KeyValue")
	proto.RegisterType((*OpenConfigData)(nil), "telemetry.OpenConfigData")
	proto.RegisterType((*Delete)(nil), "telemetry.Delete")
	proto.RegisterType((*Eom)(nil), "telemetry.Eom")
	proto.RegisterType((*CancelSubscriptionRequest)(nil), "telemetry.CancelSubscriptionRequest")
	proto.RegisterType((*CancelSubscriptionReply)(nil), "telemetry.CancelSubscriptionReply")
	proto.RegisterType((*GetSubscriptionsRequest)(nil), "telemetry.GetSubscriptionsRequest")
	proto.RegisterType((*GetSubscriptionsReply)(nil), "telemetry.GetSubscriptionsReply")
	proto.RegisterType((*GetOperationalStateRequest)(nil), "telemetry.GetOperationalStateRequest")
	proto.RegisterType((*GetOperationalStateReply)(nil), "telemetry.GetOperationalStateReply")
	proto.RegisterType((*DataEncodingRequest)(nil), "telemetry.DataEncodingRequest")
	proto.RegisterType((*DataEncodingReply)(nil), "telemetry.DataEncodingReply")
}

func init() { proto.RegisterFile("agent.proto", fileDescriptor_56ede974c0020f77) }

var fileDescriptor_56ede974c0020f77 = []byte{
	// 1486 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x57, 0xcd, 0x72, 0x1a, 0xc7,
	0x16, 0x66, 0x00, 0x09, 0x38, 0xfc, 0x78, 0x68, 0x59, 0x57, 0x48, 0xd6, 0x95, 0xf1, 0xc8, 0x2e,
	0x63, 0x95, 0x25, 0x6e, 0xe1, 0xc5, 0x2d, 0x97, 0x6f, 0x95, 0xcb, 0x42, 0x48, 0xe2, 0x1a, 0x83,
	0xd2, 0x20, 0x3b, 0xc9, 0x66, 0x32, 0xcc, 0xb4, 0x50, 0x4b, 0xf3, 0x97, 0xe9, 0x46, 0x31, 0x1b,
	0xef, 0xf3, 0x02, 0x79, 0x8f, 0x3c, 0x40, 0xf6, 0xd9, 0xa4, 0x2a, 0x8f, 0x90, 0xf2, 0x73, 0x64,
	0x91, 0xea, 0x9e, 0x01, 0x0d, 0x8a, 0xb0, 0xe3, 0x15, 0xd3, 0xdf, 0xf9, 0xfa, 0x9c, 0xd3, 0xa7,
	0xbf, 0x73, 0x66, 0x80, 0xbc, 0x31, 0x22, 0x2e, 0xdf, 0xf3, 0x03, 0x8f, 0x7b, 0x28, 0xc7, 0x89,
	0x4d, 0x1c, 0xc2, 0x83, 0x89, 0xf6, 0x1c, 0x72, 0x4d, 0xcf, 0xb6, 0x89, 0xc9, 0xbd, 0x00, 0x55,
	0x20, 0x63, 0x58, 0x56, 0x40, 0x18, 0xab, 0x28, 0x55, 0xa5, 0x96, 0xc3, 0xd3, 0x25, 0x42, 0x90,
	0xf6, 0xbd, 0x80, 0x57, 0x92, 0x55, 0xa5, 0x56, 0xc4, 0xf2, 0x59, 0x3b, 0x81, 0x72, 0x7f, 0x3c,
	0x64, 0x66, 0x40, 0x7d, 0x4e, 0x3d, 0xb7, 0xed, 0xfa, 0x63, 0x8e, 0x5e, 0x40, 0xc9, 0x9c, 0xfa,
	0xd3, 0x6d, 0xca, 0x78, 0x45, 0xa9, 0xa6, 0x6a, 0xf9, 0xc6, 0xdd, 0xbd, 0x59, 0xcc, 0xbd, 0x59,
	0x40, 0x5c, 0x9c, 0x71, 0x3b, 0x94, 0x71, 0xed, 0xa7, 0x24, 0xa4, 0x4f, 0x0c, 0x7e, 0x2e, 0xc3,
	0x19, 0xfc, 0x3c, 0xca, 0x42, 0x3e, 0xa3, 0x7f, 0xc1, 0xf2, 0x19, 0xb5, 0x39, 0x09, 0x64, 0x12,
	0x39, 0x1c, 0xad, 0xd0, 0x2e, 0x20, 0x36, 0xf6, 0x7d, 0x91, 0xa6, 0x3e, 0x76, 0xcd, 0x73, 0xc3,
	0x1d, 0x11, 0xab, 0x92, 0xaa, 0x2a, 0xb5, 0x2c, 0x2e, 0x4f, 0x2d, 0xa7, 0x53, 0x03, 0xda, 0x83,
	0x15, 0xc7, 0x78, 0xaf, 0x33, 0x6a, 0x13, 0x97, 0xeb, 0xd4, 0xe5, 0x24, 0xb8, 0x32, 0xec, 0x4a,
	0x5a, 0x1e, 0xac, 0xec, 0x18, 0xef, 0xfb, 0xd2, 0xd2, 0x8e, 0x0c, 0xe8, 0x09, 0xa8, 0xcc, 0x70,
	0x7c, 0x9b, 0xe8, 0x67, 0x01, 0xf9, 0x7e, 0x4c, 0x5c, 0x73, 0x52, 0x59, 0x92, 0xe4, 0x3b, 0x21,
	0x7e, 0x38, 0x85, 0xd1, 0x3a, 0x64, 0x5d, 0x42, 0x2c, 0x9d, 0x78, 0x4e, 0x65, 0x59, 0xc6, 0xcf,
	0x88, 0x75, 0xcb, 0x73, 0x44, 0xf2, 0x5e, 0x40, 0x47, 0xd4, 0xad, 0x58, 0x61, 0xf2, 0xe1, 0x0a,
	0x3d, 0x82, 0x12, 0x37, 0x82, 0x11, 0xe1, 0xba, 0x45, 0xce, 0xa8, 0x4b, 0xac, 0x0a, 0x91, 0x1b,
	0x8b, 0x21, 0x7a, 0x10, 0x82, 0xda, 0x2f, 0x0a, 0x6c, 0xc6, 0x6b, 0xfd, 0xca, 0xb2, 0xa8, 0xf8,
	0x35, 0xec, 0xa6, 0xe7, 0x9e, 0xd1, 0x11, 0xda, 0x86, 0xa2, 0x4d, 0x1d, 0xca, 0xf5, 0x80, 0x98,
	0x5e, 0x60, 0x85, 0xf7, 0xb7, 0x84, 0x0b, 0x12, 0xc4, 0x21, 0x86, 0x9e, 0x02, 0x0a, 0x49, 0x9c,
	0x3a, 0x44, 0x67, 0xc4, 0xf4, 0x5c, 0x8b, 0xc9, 0x6a, 0x2e, 0x61, 0x55, 0x5a, 0x06, 0xd4, 0x21,
	0xfd, 0x10, 0x8f, 0x9d, 0x86, 0x45, 0xd5, 0x8c, 0x4e, 0xc3, 0x50, 0x1d, 0xd2, 0x8e, 0x67, 0x11,
	0x59, 0xb4, 0x52, 0xe3, 0x5e, 0xec, 0x6a, 0xe3, 0x49, 0xbe, 0xf1, 0x2c, 0x82, 0x25, 0x51, 0xfb,
	0x4d, 0x81, 0x95, 0xb8, 0x09, 0x8b, 0x92, 0x31, 0x8e, 0x1a, 0xb0, 0x44, 0x85, 0x6c, 0x64, 0xba,
	0xf9, 0xc6, 0xe6, 0x02, 0x4f, 0x52, 0x5a, 0x38, 0xa4, 0xa2, 0xa7, 0x90, 0x13, 0x7a, 0x08, 0xc5,
	0x95, 0x94, 0xe2, 0xba, 0x13, 0xdb, 0x27, 0xf4, 0x83, 0xb3, 0x82, 0x21, 0x24, 0x85, 0x06, 0x50,
	0x36, 0x66, 0xc5, 0xd2, 0x4d, 0x59, 0x2d, 0x79, 0x9c, 0x7c, 0xe3, 0xf1, 0x82, 0x68, 0x37, 0x8b,
	0x8b, 0x55, 0xe3, 0x06, 0xa2, 0xbd, 0x84, 0xbb, 0xf3, 0xc7, 0x61, 0xbe, 0xe7, 0x32, 0x82, 0x1e,
	0xc3, 0x1d, 0x16, 0xc3, 0x75, 0x6a, 0xc9, 0x93, 0x15, 0x71, 0x29, 0x0e, 0xb7, 0x2d, 0xed, 0xc3,
	0x7c, 0xef, 0x60, 0xe2, 0xdb, 0x13, 0xf4, 0x02, 0xb2, 0x41, 0xe4, 0x29, 0x2a, 0xc8, 0xfd, 0x05,
	0x29, 0x4e, 0x03, 0xe2, 0xd9, 0x86, 0x2f, 0x2b, 0x8b, 0xf6, 0x73, 0x12, 0xb2, 0xaf, 0xc9, 0xe4,
	0xad, 0x61, 0x8f, 0x09, 0x52, 0x21, 0x75, 0x49, 0x26, 0x51, 0xb3, 0x89, 0x47, 0xb4, 0x0d, 0x05,
	0xcb, 0x1b, 0x0f, 0x6d, 0xa2, 0x5f, 0x09, 0x86, 0x14, 0xbc, 0x72, 0x9c, 0xc0, 0xf9, 0x10, 0x0d,
	0xb7, 0xfd, 0x1b, 0x72, 0xd4, 0xe5, 0x11, 0x43, 0xe8, 0x3d, 0x75, 0x9c, 0xc0, 0x59, 0xea, 0xf2,
	0xd0, 0x7c, 0x1f, 0x60, 0x7c, 0x6d, 0xcf, 0x54, 0x95, 0x5a, 0xfa, 0x38, 0x81, 0x73, 0xe3, 0x38,
	0x81, 0x5d, 0x13, 0xb2, 0x55, 0xa5, 0x86, 0x04, 0x81, 0xc5, 0x09, 0x43, 0xcf, 0xb3, 0x23, 0x42,
	0x4e, 0x68, 0x50, 0x10, 0x04, 0x36, 0xcb, 0x80, 0xf1, 0x20, 0xb2, 0x83, 0x48, 0x5f, 0x64, 0xc0,
	0x78, 0x10, 0x9a, 0x1f, 0x40, 0x7e, 0x38, 0xe1, 0x84, 0x45, 0x84, 0x7c, 0x55, 0xa9, 0x15, 0x8e,
	0x13, 0x18, 0x24, 0x38, 0xa3, 0x9c, 0xd9, 0x9e, 0x31, 0x4d, 0xa2, 0x50, 0x55, 0x6a, 0x49, 0x41,
	0x91, 0xa0, 0xa4, 0xec, 0x67, 0x60, 0x49, 0x1a, 0xb5, 0x1f, 0x53, 0x50, 0xea, 0xf9, 0xc4, 0x0d,
	0x35, 0x70, 0x60, 0x70, 0x03, 0xdd, 0x83, 0x1c, 0x9b, 0x30, 0x4e, 0x9c, 0xe9, 0x4d, 0xe7, 0x70,
	0x36, 0x04, 0xda, 0x16, 0x7a, 0x00, 0x05, 0xd3, 0x73, 0x7c, 0xcf, 0x95, 0x83, 0xc6, 0x8a, 0x66,
	0x67, 0x7e, 0x86, 0xb5, 0x2d, 0x54, 0x03, 0x95, 0x8d, 0x87, 0xfa, 0x1c, 0x2d, 0x35, 0x13, 0x4c,
	0x33, 0xc6, 0x9c, 0x4e, 0xc4, 0x74, 0x6c, 0x22, 0x0a, 0xb5, 0x85, 0xb3, 0x87, 0xe8, 0xee, 0xd8,
	0x19, 0x92, 0x40, 0x5e, 0x54, 0x1a, 0x97, 0xa6, 0x70, 0x57, 0xa2, 0x68, 0x13, 0x72, 0xa2, 0xe5,
	0x19, 0x37, 0x1c, 0x5f, 0xde, 0x54, 0x1a, 0x5f, 0x03, 0x68, 0x1b, 0x92, 0x97, 0x57, 0x95, 0x8c,
	0x94, 0xcc, 0x4a, 0x4c, 0x32, 0x53, 0x7d, 0xe0, 0xe4, 0xe5, 0x15, 0x7a, 0x02, 0xcb, 0x16, 0xb1,
	0x09, 0x17, 0x17, 0x25, 0x88, 0xe5, 0x18, 0xf1, 0x40, 0x1a, 0x70, 0x44, 0x40, 0x0f, 0x21, 0x25,
	0x26, 0x60, 0x4e, 0xf2, 0x4a, 0x31, 0x5e, 0xcb, 0x73, 0xf6, 0x93, 0x15, 0x05, 0x0b, 0xb3, 0x98,
	0x58, 0x6c, 0xe2, 0x9a, 0xfa, 0x4c, 0xf1, 0x20, 0x67, 0x4c, 0x41, 0x80, 0xb3, 0x7e, 0x5a, 0x83,
	0x0c, 0x65, 0xfa, 0x0f, 0x81, 0xe1, 0xcb, 0xdb, 0xcb, 0xe2, 0x65, 0xca, 0xde, 0x05, 0x86, 0xaf,
	0x6d, 0xc2, 0x72, 0x18, 0xf5, 0xb6, 0x57, 0x85, 0xb6, 0x0e, 0x29, 0x31, 0x74, 0x6f, 0x33, 0x1d,
	0xc0, 0x7a, 0xd3, 0x70, 0x4d, 0x62, 0xdf, 0x36, 0x8e, 0xfe, 0x71, 0xfb, 0xea, 0xb0, 0x76, 0x9b,
	0x17, 0xd1, 0xc4, 0x4f, 0x20, 0x6d, 0x8a, 0xd9, 0xa8, 0xc8, 0xd9, 0xb8, 0x1a, 0x3b, 0x3e, 0x26,
	0x7c, 0x1c, 0xb8, 0x4d, 0x39, 0x15, 0x05, 0x45, 0x4c, 0x58, 0xf1, 0xab, 0x33, 0x3e, 0x7d, 0xa7,
	0x65, 0xc4, 0xba, 0xcf, 0x03, 0x6d, 0x1f, 0xd6, 0x8e, 0x08, 0x8f, 0x7b, 0x67, 0x5f, 0x9c, 0xe4,
	0x10, 0x56, 0xff, 0xee, 0x43, 0xa4, 0xd8, 0x86, 0xf2, 0x9c, 0x87, 0xd8, 0x6b, 0x7a, 0x73, 0xe1,
	0xc0, 0xf1, 0xed, 0x09, 0x56, 0xe3, 0xdb, 0xe4, 0x1c, 0xf9, 0x00, 0x1b, 0x47, 0x84, 0xf7, 0x7c,
	0x12, 0x18, 0xe1, 0x80, 0xec, 0x73, 0x83, 0x93, 0x2f, 0x4d, 0x15, 0xfd, 0x17, 0x72, 0x57, 0x24,
	0x18, 0x7a, 0x8c, 0xf2, 0x89, 0x2c, 0x45, 0xa9, 0xb1, 0x1e, 0xcb, 0xe4, 0xed, 0xd4, 0xd6, 0x21,
	0x57, 0xc4, 0xc6, 0xd7, 0x5c, 0xed, 0x25, 0x54, 0x6e, 0x8d, 0x2f, 0x8e, 0x19, 0xea, 0x5a, 0xf9,
	0xa4, 0xae, 0xb5, 0x55, 0x58, 0x11, 0x9d, 0xdc, 0x72, 0x4d, 0xcf, 0xa2, 0xee, 0x28, 0xca, 0x5c,
	0xfb, 0x0a, 0xca, 0xf3, 0xb0, 0x70, 0xf8, 0x3f, 0x28, 0x92, 0x08, 0xb8, 0xae, 0x59, 0xa9, 0xb1,
	0x16, 0x97, 0x78, 0x64, 0x1f, 0x4c, 0x7c, 0x82, 0x0b, 0x53, 0xb6, 0x28, 0xd5, 0xce, 0x11, 0xc0,
	0xb5, 0x02, 0x50, 0x1e, 0x32, 0xfd, 0xd3, 0x66, 0xb3, 0xd5, 0xef, 0xab, 0x09, 0xb4, 0x0e, 0xab,
	0xdd, 0x9e, 0xde, 0x3f, 0xdd, 0xef, 0x37, 0x71, 0xfb, 0x64, 0xd0, 0xee, 0x75, 0xf5, 0x56, 0x77,
	0x80, 0xbf, 0x51, 0x15, 0x54, 0x86, 0xe2, 0x69, 0xf7, 0x75, 0xb7, 0xf7, 0xae, 0xab, 0xb7, 0x30,
	0xee, 0x61, 0x35, 0xb9, 0xd3, 0x80, 0xd2, 0x7c, 0x41, 0x10, 0xc0, 0xf2, 0x41, 0x6b, 0xf0, 0xaa,
	0xdd, 0x51, 0x13, 0x28, 0x07, 0x4b, 0x83, 0x16, 0xee, 0xb7, 0x54, 0x45, 0x3c, 0xee, 0xe3, 0x76,
	0xeb, 0x50, 0x4d, 0xee, 0xbc, 0x82, 0x42, 0x3c, 0x35, 0x54, 0x84, 0xdc, 0x69, 0xf7, 0xa0, 0x75,
	0xd8, 0xee, 0xb6, 0x0e, 0xd4, 0x04, 0xca, 0x40, 0xea, 0xeb, 0x37, 0x1d, 0x55, 0x11, 0xf8, 0xff,
	0xfb, 0xbd, 0xae, 0xde, 0x6e, 0x0d, 0x0e, 0xd5, 0xa4, 0x70, 0x7c, 0x82, 0x7b, 0x83, 0xde, 0x33,
	0x35, 0xb5, 0xf3, 0x1c, 0xd4, 0x9b, 0x6f, 0x77, 0x54, 0x02, 0xe8, 0xf4, 0xba, 0x47, 0x7a, 0xa7,
	0xfd, 0x56, 0xfa, 0xc9, 0x43, 0xa6, 0xd7, 0x6d, 0xe9, 0xbd, 0xc3, 0x43, 0x55, 0x41, 0x59, 0x48,
	0x9f, 0xf4, 0x3a, 0x1d, 0x35, 0xd9, 0xf8, 0x33, 0x05, 0x2b, 0xd7, 0x93, 0x73, 0x30, 0xad, 0x16,
	0xea, 0x03, 0x9a, 0x95, 0x2e, 0xf2, 0x3d, 0x24, 0x68, 0x6b, 0xa1, 0x06, 0xe5, 0xdd, 0x6c, 0xc4,
	0x95, 0x31, 0x3f, 0x8f, 0xb5, 0xc4, 0x7f, 0x14, 0x44, 0xe1, 0x9e, 0x29, 0x7b, 0x73, 0x70, 0xc3,
	0xb5, 0x74, 0x82, 0x1e, 0xc6, 0x3f, 0x44, 0x17, 0x4d, 0x82, 0x0d, 0xed, 0x33, 0x2c, 0xdf, 0x9e,
	0x68, 0x09, 0x64, 0xc2, 0xfa, 0x88, 0xf0, 0x5b, 0xe3, 0x30, 0x14, 0x77, 0xb1, 0xa0, 0x97, 0x37,
	0xaa, 0x9f, 0xe4, 0x84, 0x41, 0x6c, 0xd8, 0x8c, 0x07, 0xb9, 0xa9, 0x75, 0xf4, 0x68, 0xde, 0xc7,
	0x82, 0x5e, 0xdc, 0xd8, 0xfe, 0x1c, 0x2d, 0x8c, 0x86, 0x41, 0x15, 0xdf, 0x9d, 0x31, 0xed, 0xb3,
	0xb9, 0x0b, 0xb9, 0xa5, 0x59, 0x36, 0x36, 0x17, 0xda, 0xa5, 0xcf, 0xfd, 0xef, 0x7e, 0xfd, 0xb8,
	0xa5, 0xfc, 0xfe, 0x71, 0x4b, 0xf9, 0xe3, 0xe3, 0x96, 0xf2, 0x2d, 0x1e, 0x51, 0xbe, 0x77, 0x31,
	0x76, 0xa9, 0x4f, 0x82, 0x3d, 0x97, 0xf0, 0x3a, 0x35, 0xc9, 0x90, 0x04, 0xa3, 0xfa, 0x39, 0x31,
	0x6c, 0x7e, 0x3e, 0xf4, 0xf8, 0x2e, 0x75, 0x47, 0x84, 0xf1, 0xdd, 0x0b, 0x4e, 0x77, 0x5d, 0x83,
	0xd3, 0x2b, 0x52, 0xf7, 0x2f, 0x47, 0xf5, 0x0b, 0x4e, 0xeb, 0x86, 0x65, 0xf8, 0x9c, 0x04, 0xac,
	0xae, 0x5f, 0x8c, 0x5d, 0x8f, 0xd5, 0x99, 0x79, 0x4e, 0x1c, 0x63, 0xb8, 0x2c, 0xff, 0xd7, 0x3c,
	0xfb, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x6a, 0x98, 0x4b, 0xa8, 0xe6, 0x0c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// OpenConfigTelemetryClient is the client API for OpenConfigTelemetry service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OpenConfigTelemetryClient interface {
	// Request an inline subscription for data at the specified path.
	// The device should send telemetry data back on the same
	// connection as the subscription request.
	TelemetrySubscribe(ctx context.Context, in *SubscriptionRequest, opts ...grpc.CallOption) (OpenConfigTelemetry_TelemetrySubscribeClient, error)
	// Terminates and removes an exisiting telemetry subscription
	CancelTelemetrySubscription(ctx context.Context, in *CancelSubscriptionRequest, opts ...grpc.CallOption) (*CancelSubscriptionReply, error)
	// Get the list of current telemetry subscriptions from the
	// target. This command returns a list of existing subscriptions
	// not including those that are established via configuration.
	GetTelemetrySubscriptions(ctx context.Context, in *GetSubscriptionsRequest, opts ...grpc.CallOption) (*GetSubscriptionsReply, error)
	// Get Telemetry Agent Operational States
	GetTelemetryOperationalState(ctx context.Context, in *GetOperationalStateRequest, opts ...grpc.CallOption) (*GetOperationalStateReply, error)
	// Return the set of data encodings supported by the device for
	// telemetry data
	GetDataEncodings(ctx context.Context, in *DataEncodingRequest, opts ...grpc.CallOption) (*DataEncodingReply, error)
}

type openConfigTelemetryClient struct {
	cc *grpc.ClientConn
}

func NewOpenConfigTelemetryClient(cc *grpc.ClientConn) OpenConfigTelemetryClient {
	return &openConfigTelemetryClient{cc}
}

func (c *openConfigTelemetryClient) TelemetrySubscribe(ctx context.Context, in *SubscriptionRequest, opts ...grpc.CallOption) (OpenConfigTelemetry_TelemetrySubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_OpenConfigTelemetry_serviceDesc.Streams[0], "/telemetry.OpenConfigTelemetry/telemetrySubscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &openConfigTelemetryTelemetrySubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type OpenConfigTelemetry_TelemetrySubscribeClient interface {
	Recv() (*OpenConfigData, error)
	grpc.ClientStream
}

type openConfigTelemetryTelemetrySubscribeClient struct {
	grpc.ClientStream
}

func (x *openConfigTelemetryTelemetrySubscribeClient) Recv() (*OpenConfigData, error) {
	m := new(OpenConfigData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *openConfigTelemetryClient) CancelTelemetrySubscription(ctx context.Context, in *CancelSubscriptionRequest, opts ...grpc.CallOption) (*CancelSubscriptionReply, error) {
	out := new(CancelSubscriptionReply)
	err := c.cc.Invoke(ctx, "/telemetry.OpenConfigTelemetry/cancelTelemetrySubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openConfigTelemetryClient) GetTelemetrySubscriptions(ctx context.Context, in *GetSubscriptionsRequest, opts ...grpc.CallOption) (*GetSubscriptionsReply, error) {
	out := new(GetSubscriptionsReply)
	err := c.cc.Invoke(ctx, "/telemetry.OpenConfigTelemetry/getTelemetrySubscriptions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openConfigTelemetryClient) GetTelemetryOperationalState(ctx context.Context, in *GetOperationalStateRequest, opts ...grpc.CallOption) (*GetOperationalStateReply, error) {
	out := new(GetOperationalStateReply)
	err := c.cc.Invoke(ctx, "/telemetry.OpenConfigTelemetry/getTelemetryOperationalState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openConfigTelemetryClient) GetDataEncodings(ctx context.Context, in *DataEncodingRequest, opts ...grpc.CallOption) (*DataEncodingReply, error) {
	out := new(DataEncodingReply)
	err := c.cc.Invoke(ctx, "/telemetry.OpenConfigTelemetry/getDataEncodings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OpenConfigTelemetryServer is the server API for OpenConfigTelemetry service.
type OpenConfigTelemetryServer interface {
	// Request an inline subscription for data at the specified path.
	// The device should send telemetry data back on the same
	// connection as the subscription request.
	TelemetrySubscribe(*SubscriptionRequest, OpenConfigTelemetry_TelemetrySubscribeServer) error
	// Terminates and removes an exisiting telemetry subscription
	CancelTelemetrySubscription(context.Context, *CancelSubscriptionRequest) (*CancelSubscriptionReply, error)
	// Get the list of current telemetry subscriptions from the
	// target. This command returns a list of existing subscriptions
	// not including those that are established via configuration.
	GetTelemetrySubscriptions(context.Context, *GetSubscriptionsRequest) (*GetSubscriptionsReply, error)
	// Get Telemetry Agent Operational States
	GetTelemetryOperationalState(context.Context, *GetOperationalStateRequest) (*GetOperationalStateReply, error)
	// Return the set of data encodings supported by the device for
	// telemetry data
	GetDataEncodings(context.Context, *DataEncodingRequest) (*DataEncodingReply, error)
}

// UnimplementedOpenConfigTelemetryServer can be embedded to have forward compatible implementations.
type UnimplementedOpenConfigTelemetryServer struct {
}

func (*UnimplementedOpenConfigTelemetryServer) TelemetrySubscribe(req *SubscriptionRequest, srv OpenConfigTelemetry_TelemetrySubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method TelemetrySubscribe not implemented")
}
func (*UnimplementedOpenConfigTelemetryServer) CancelTelemetrySubscription(ctx context.Context, req *CancelSubscriptionRequest) (*CancelSubscriptionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelTelemetrySubscription not implemented")
}
func (*UnimplementedOpenConfigTelemetryServer) GetTelemetrySubscriptions(ctx context.Context, req *GetSubscriptionsRequest) (*GetSubscriptionsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTelemetrySubscriptions not implemented")
}
func (*UnimplementedOpenConfigTelemetryServer) GetTelemetryOperationalState(ctx context.Context, req *GetOperationalStateRequest) (*GetOperationalStateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTelemetryOperationalState not implemented")
}
func (*UnimplementedOpenConfigTelemetryServer) GetDataEncodings(ctx context.Context, req *DataEncodingRequest) (*DataEncodingReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDataEncodings not implemented")
}

func RegisterOpenConfigTelemetryServer(s *grpc.Server, srv OpenConfigTelemetryServer) {
	s.RegisterService(&_OpenConfigTelemetry_serviceDesc, srv)
}

func _OpenConfigTelemetry_TelemetrySubscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscriptionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OpenConfigTelemetryServer).TelemetrySubscribe(m, &openConfigTelemetryTelemetrySubscribeServer{stream})
}

type OpenConfigTelemetry_TelemetrySubscribeServer interface {
	Send(*OpenConfigData) error
	grpc.ServerStream
}

type openConfigTelemetryTelemetrySubscribeServer struct {
	grpc.ServerStream
}

func (x *openConfigTelemetryTelemetrySubscribeServer) Send(m *OpenConfigData) error {
	return x.ServerStream.SendMsg(m)
}

func _OpenConfigTelemetry_CancelTelemetrySubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenConfigTelemetryServer).CancelTelemetrySubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.OpenConfigTelemetry/CancelTelemetrySubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenConfigTelemetryServer).CancelTelemetrySubscription(ctx, req.(*CancelSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenConfigTelemetry_GetTelemetrySubscriptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubscriptionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenConfigTelemetryServer).GetTelemetrySubscriptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.OpenConfigTelemetry/GetTelemetrySubscriptions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenConfigTelemetryServer).GetTelemetrySubscriptions(ctx, req.(*GetSubscriptionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenConfigTelemetry_GetTelemetryOperationalState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOperationalStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenConfigTelemetryServer).GetTelemetryOperationalState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.OpenConfigTelemetry/GetTelemetryOperationalState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenConfigTelemetryServer).GetTelemetryOperationalState(ctx, req.(*GetOperationalStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenConfigTelemetry_GetDataEncodings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataEncodingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenConfigTelemetryServer).GetDataEncodings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.OpenConfigTelemetry/GetDataEncodings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenConfigTelemetryServer).GetDataEncodings(ctx, req.(*DataEncodingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _OpenConfigTelemetry_serviceDesc = grpc.ServiceDesc{
	ServiceName: "telemetry.OpenConfigTelemetry",
	HandlerType: (*OpenConfigTelemetryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "cancelTelemetrySubscription",
			Handler:    _OpenConfigTelemetry_CancelTelemetrySubscription_Handler,
		},
		{
			MethodName: "getTelemetrySubscriptions",
			Handler:    _OpenConfigTelemetry_GetTelemetrySubscriptions_Handler,
		},
		{
			MethodName: "getTelemetryOperationalState",
			Handler:    _OpenConfigTelemetry_GetTelemetryOperationalState_Handler,
		},
		{
			MethodName: "getDataEncodings",
			Handler:    _OpenConfigTelemetry_GetDataEncodings_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "telemetrySubscribe",
			Handler:       _OpenConfigTelemetry_TelemetrySubscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "agent.proto",
}

func (m *Collector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Collector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Collector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Port != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubscriptionInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CollectorList) > 0 {
		for iNdEx := len(m.CollectorList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectorList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Path) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Path) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Path) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TargetDefined {
		i--
		if m.TargetDefined {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if len(m.Origin) > 0 {
		i -= len(m.Origin)
		copy(dAtA[i:], m.Origin)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Origin)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if m.NeedEom {
		i--
		if m.NeedEom {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.SampleFrequency != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.SampleFrequency))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxSilentInterval != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.MaxSilentInterval))
		i--
		dAtA[i] = 0x20
	}
	if m.SuppressUnchanged {
		i--
		if m.SuppressUnchanged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Filter) > 0 {
		i -= len(m.Filter)
		copy(dAtA[i:], m.Filter)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Filter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubscriptionAdditionalConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionAdditionalConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionAdditionalConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mode != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x20
	}
	if m.NeedEos {
		i--
		if m.NeedEos {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.LimitTimeSeconds != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.LimitTimeSeconds))
		i--
		dAtA[i] = 0x10
	}
	if m.LimitRecords != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.LimitRecords))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubscriptionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AdditionalConfig != nil {
		{
			size, err := m.AdditionalConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PathList) > 0 {
		for iNdEx := len(m.PathList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PathList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Input != nil {
		{
			size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubscriptionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubscriptionId != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.SubscriptionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubscriptionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PathList) > 0 {
		for iNdEx := len(m.PathList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PathList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KeyValue_DoubleValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue_DoubleValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DoubleValue))))
	i--
	dAtA[i] = 0x29
	return len(dAtA) - i, nil
}
func (m *KeyValue_IntValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue_IntValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintAgent(dAtA, i, uint64(m.IntValue))
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *KeyValue_UintValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue_UintValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintAgent(dAtA, i, uint64(m.UintValue))
	i--
	dAtA[i] = 0x38
	return len(dAtA) - i, nil
}
func (m *KeyValue_SintValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue_SintValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintAgent(dAtA, i, uint64((uint64(m.SintValue)<<1)^uint64((m.SintValue>>63))))
	i--
	dAtA[i] = 0x40
	return len(dAtA) - i, nil
}
func (m *KeyValue_BoolValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue_BoolValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.BoolValue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x48
	return len(dAtA) - i, nil
}
func (m *KeyValue_StrValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue_StrValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.StrValue)
	copy(dAtA[i:], m.StrValue)
	i = encodeVarintAgent(dAtA, i, uint64(len(m.StrValue)))
	i--
	dAtA[i] = 0x52
	return len(dAtA) - i, nil
}
func (m *KeyValue_BytesValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue_BytesValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BytesValue != nil {
		i -= len(m.BytesValue)
		copy(dAtA[i:], m.BytesValue)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.BytesValue)))
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *KeyValue_FloatValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue_FloatValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.FloatValue))))
	i--
	dAtA[i] = 0x65
	return len(dAtA) - i, nil
}
func (m *OpenConfigData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenConfigData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenConfigData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsWrap {
		i--
		if m.IsWrap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.SyncResponse {
		i--
		if m.SyncResponse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.Eom) > 0 {
		for iNdEx := len(m.Eom) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Eom[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Delete) > 0 {
		for iNdEx := len(m.Delete) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Delete[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Kv) > 0 {
		for iNdEx := len(m.Kv) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Kv[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Timestamp != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x30
	}
	if m.SequenceNumber != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.SequenceNumber))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x22
	}
	if m.SubComponentId != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.SubComponentId))
		i--
		dAtA[i] = 0x18
	}
	if m.ComponentId != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.ComponentId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SystemId) > 0 {
		i -= len(m.SystemId)
		copy(dAtA[i:], m.SystemId)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.SystemId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Delete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Delete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Delete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Eom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Eom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Eom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CancelSubscriptionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelSubscriptionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelSubscriptionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubscriptionId != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.SubscriptionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CancelSubscriptionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelSubscriptionReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelSubscriptionReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CodeStr) > 0 {
		i -= len(m.CodeStr)
		copy(dAtA[i:], m.CodeStr)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.CodeStr)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetSubscriptionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSubscriptionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSubscriptionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubscriptionId != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.SubscriptionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetSubscriptionsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSubscriptionsReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSubscriptionsReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SubscriptionList) > 0 {
		for iNdEx := len(m.SubscriptionList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SubscriptionList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetOperationalStateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOperationalStateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetOperationalStateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Verbosity != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Verbosity))
		i--
		dAtA[i] = 0x10
	}
	if m.SubscriptionId != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.SubscriptionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetOperationalStateReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOperationalStateReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetOperationalStateReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Kv) > 0 {
		for iNdEx := len(m.Kv) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Kv[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataEncodingRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataEncodingRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataEncodingRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DataEncodingReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataEncodingReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataEncodingReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EncodingList) > 0 {
		dAtA5 := make([]byte, len(m.EncodingList)*10)
		var j4 int
		for _, num := range m.EncodingList {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintAgent(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAgent(dAtA []byte, offset int, v uint64) int {
	offset -= sovAgent(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Collector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovAgent(uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscriptionInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CollectorList) > 0 {
		for _, e := range m.CollectorList {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Path) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.SuppressUnchanged {
		n += 2
	}
	if m.MaxSilentInterval != 0 {
		n += 1 + sovAgent(uint64(m.MaxSilentInterval))
	}
	if m.SampleFrequency != 0 {
		n += 1 + sovAgent(uint64(m.SampleFrequency))
	}
	if m.NeedEom {
		n += 2
	}
	l = len(m.Origin)
	if l > 0 {
		n += 2 + l + sovAgent(uint64(l))
	}
	if m.TargetDefined {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscriptionAdditionalConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LimitRecords != 0 {
		n += 1 + sovAgent(uint64(m.LimitRecords))
	}
	if m.LimitTimeSeconds != 0 {
		n += 1 + sovAgent(uint64(m.LimitTimeSeconds))
	}
	if m.NeedEos {
		n += 2
	}
	if m.Mode != 0 {
		n += 1 + sovAgent(uint64(m.Mode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscriptionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Input != nil {
		l = m.Input.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.PathList) > 0 {
		for _, e := range m.PathList {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.AdditionalConfig != nil {
		l = m.AdditionalConfig.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscriptionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubscriptionId != 0 {
		n += 1 + sovAgent(uint64(m.SubscriptionId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscriptionReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.PathList) > 0 {
		for _, e := range m.PathList {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Value != nil {
		n += m.Value.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyValue_DoubleValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *KeyValue_IntValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovAgent(uint64(m.IntValue))
	return n
}
func (m *KeyValue_UintValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovAgent(uint64(m.UintValue))
	return n
}
func (m *KeyValue_SintValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sozAgent(uint64(m.SintValue))
	return n
}
func (m *KeyValue_BoolValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *KeyValue_StrValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StrValue)
	n += 1 + l + sovAgent(uint64(l))
	return n
}
func (m *KeyValue_BytesValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BytesValue != nil {
		l = len(m.BytesValue)
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}
func (m *KeyValue_FloatValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	return n
}
func (m *OpenConfigData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SystemId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.ComponentId != 0 {
		n += 1 + sovAgent(uint64(m.ComponentId))
	}
	if m.SubComponentId != 0 {
		n += 1 + sovAgent(uint64(m.SubComponentId))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovAgent(uint64(m.SequenceNumber))
	}
	if m.Timestamp != 0 {
		n += 1 + sovAgent(uint64(m.Timestamp))
	}
	if len(m.Kv) > 0 {
		for _, e := range m.Kv {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Delete) > 0 {
		for _, e := range m.Delete {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Eom) > 0 {
		for _, e := range m.Eom {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.SyncResponse {
		n += 2
	}
	if m.IsWrap {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Delete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Eom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CancelSubscriptionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubscriptionId != 0 {
		n += 1 + sovAgent(uint64(m.SubscriptionId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CancelSubscriptionReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovAgent(uint64(m.Code))
	}
	l = len(m.CodeStr)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSubscriptionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubscriptionId != 0 {
		n += 1 + sovAgent(uint64(m.SubscriptionId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSubscriptionsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SubscriptionList) > 0 {
		for _, e := range m.SubscriptionList {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetOperationalStateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubscriptionId != 0 {
		n += 1 + sovAgent(uint64(m.SubscriptionId))
	}
	if m.Verbosity != 0 {
		n += 1 + sovAgent(uint64(m.Verbosity))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetOperationalStateReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Kv) > 0 {
		for _, e := range m.Kv {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataEncodingRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataEncodingReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EncodingList) > 0 {
		l = 0
		for _, e := range m.EncodingList {
			l += sovAgent(uint64(e))
		}
		n += 1 + sovAgent(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAgent(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAgent(x uint64) (n int) {
	return sovAgent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Collector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Collector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Collector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectorList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectorList = append(m.CollectorList, &Collector{})
			if err := m.CollectorList[len(m.CollectorList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Path) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Path: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Path: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuppressUnchanged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SuppressUnchanged = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSilentInterval", wireType)
			}
			m.MaxSilentInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSilentInterval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleFrequency", wireType)
			}
			m.SampleFrequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleFrequency |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedEom", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedEom = bool(v != 0)
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Origin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetDefined", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TargetDefined = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionAdditionalConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionAdditionalConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionAdditionalConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitRecords", wireType)
			}
			m.LimitRecords = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitRecords |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitTimeSeconds", wireType)
			}
			m.LimitTimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitTimeSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedEos", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedEos = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= SubscriptionMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &SubscriptionInput{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathList = append(m.PathList, &Path{})
			if err := m.PathList[len(m.PathList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdditionalConfig == nil {
				m.AdditionalConfig = &SubscriptionAdditionalConfig{}
			}
			if err := m.AdditionalConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionId", wireType)
			}
			m.SubscriptionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubscriptionId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &SubscriptionResponse{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathList = append(m.PathList, &Path{})
			if err := m.PathList[len(m.PathList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = &KeyValue_DoubleValue{float64(math.Float64frombits(v))}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntValue", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &KeyValue_IntValue{v}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UintValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &KeyValue_UintValue{v}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SintValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Value = &KeyValue_SintValue{int64(v)}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &KeyValue_BoolValue{b}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &KeyValue_StrValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Value = &KeyValue_BytesValue{v}
			iNdEx = postIndex
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatValue", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Value = &KeyValue_FloatValue{float32(math.Float32frombits(v))}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenConfigData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenConfigData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenConfigData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComponentId", wireType)
			}
			m.ComponentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComponentId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubComponentId", wireType)
			}
			m.SubComponentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubComponentId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kv = append(m.Kv, &KeyValue{})
			if err := m.Kv[len(m.Kv)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delete = append(m.Delete, &Delete{})
			if err := m.Delete[len(m.Delete)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Eom = append(m.Eom, &Eom{})
			if err := m.Eom[len(m.Eom)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncResponse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SyncResponse = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWrap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWrap = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Delete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Delete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Delete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Eom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Eom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Eom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelSubscriptionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelSubscriptionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelSubscriptionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionId", wireType)
			}
			m.SubscriptionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubscriptionId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelSubscriptionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelSubscriptionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelSubscriptionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= ReturnCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CodeStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSubscriptionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSubscriptionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSubscriptionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionId", wireType)
			}
			m.SubscriptionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubscriptionId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSubscriptionsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSubscriptionsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSubscriptionsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscriptionList = append(m.SubscriptionList, &SubscriptionReply{})
			if err := m.SubscriptionList[len(m.SubscriptionList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOperationalStateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOperationalStateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOperationalStateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionId", wireType)
			}
			m.SubscriptionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubscriptionId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verbosity", wireType)
			}
			m.Verbosity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Verbosity |= VerbosityLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOperationalStateReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOperationalStateReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOperationalStateReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kv = append(m.Kv, &KeyValue{})
			if err := m.Kv[len(m.Kv)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataEncodingRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataEncodingRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataEncodingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataEncodingReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataEncodingReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataEncodingReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v EncodingType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= EncodingType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EncodingList = append(m.EncodingList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAgent
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAgent
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.EncodingList) == 0 {
					m.EncodingList = make([]EncodingType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v EncodingType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAgent
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= EncodingType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EncodingList = append(m.EncodingList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodingList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAgent(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAgent
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAgent
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAgent
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAgent        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAgent          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAgent = fmt.Errorf("proto: unexpected end of group")
)
