// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ipsec_telemetry.proto

package schema

import (
	fmt "fmt"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type IPsecVPN struct {
	IpsecGlobalInfo      []*IPsecGlobalInfo    `protobuf:"bytes,1,rep,name=ipsec_global_info,json=ipsecGlobalInfo" json:"ipsec_global_info,omitempty"`
	IpsecSvcsetInfo      []*IPsecPerSvcsetInfo `protobuf:"bytes,2,rep,name=ipsec_svcset_info,json=ipsecSvcsetInfo" json:"ipsec_svcset_info,omitempty"`
	IpsecTunnelInfo      []*IPsecPerTunnelInfo `protobuf:"bytes,3,rep,name=ipsec_tunnel_info,json=ipsecTunnelInfo" json:"ipsec_tunnel_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *IPsecVPN) Reset()         { *m = IPsecVPN{} }
func (m *IPsecVPN) String() string { return proto.CompactTextString(m) }
func (*IPsecVPN) ProtoMessage()    {}
func (*IPsecVPN) Descriptor() ([]byte, []int) {
	return fileDescriptor_62544e4535d94422, []int{0}
}
func (m *IPsecVPN) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPsecVPN) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPsecVPN.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPsecVPN) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPsecVPN.Merge(m, src)
}
func (m *IPsecVPN) XXX_Size() int {
	return m.Size()
}
func (m *IPsecVPN) XXX_DiscardUnknown() {
	xxx_messageInfo_IPsecVPN.DiscardUnknown(m)
}

var xxx_messageInfo_IPsecVPN proto.InternalMessageInfo

func (m *IPsecVPN) GetIpsecGlobalInfo() []*IPsecGlobalInfo {
	if m != nil {
		return m.IpsecGlobalInfo
	}
	return nil
}

func (m *IPsecVPN) GetIpsecSvcsetInfo() []*IPsecPerSvcsetInfo {
	if m != nil {
		return m.IpsecSvcsetInfo
	}
	return nil
}

func (m *IPsecVPN) GetIpsecTunnelInfo() []*IPsecPerTunnelInfo {
	if m != nil {
		return m.IpsecTunnelInfo
	}
	return nil
}

type IPsecGlobalInfo struct {
	// RE-Pconn Connect Retry
	RePconnConnect *uint64 `protobuf:"varint,1,opt,name=re_pconn_connect,json=rePconnConnect" json:"re_pconn_connect,omitempty"`
	// RE-Pconn Status
	PconnStatus *uint64 `protobuf:"varint,2,opt,name=pconn_status,json=pconnStatus" json:"pconn_status,omitempty"`
	// Request Enq Succ
	SaTriggerEnqSuccess *uint64 `protobuf:"varint,3,opt,name=sa_trigger_enq_success,json=saTriggerEnqSuccess" json:"sa_trigger_enq_success,omitempty"`
	// Request Enq Fail
	SaTriggerEnqFail *uint64 `protobuf:"varint,4,opt,name=sa_trigger_enq_fail,json=saTriggerEnqFail" json:"sa_trigger_enq_fail,omitempty"`
	// Retry Enq Succ
	SaTriggerRetrySuccess *uint64 `protobuf:"varint,5,opt,name=sa_trigger_retry_success,json=saTriggerRetrySuccess" json:"sa_trigger_retry_success,omitempty"`
	// Retry Enq Fail
	SaTriggerRetryFail *uint64 `protobuf:"varint,6,opt,name=sa_trigger_retry_fail,json=saTriggerRetryFail" json:"sa_trigger_retry_fail,omitempty"`
	// Trigger Send Succ
	SaTriggerSent *uint64 `protobuf:"varint,7,opt,name=sa_trigger_sent,json=saTriggerSent" json:"sa_trigger_sent,omitempty"`
	// Trigger Send Fail
	SaTriggerFail *uint64 `protobuf:"varint,8,opt,name=sa_trigger_fail,json=saTriggerFail" json:"sa_trigger_fail,omitempty"`
	// Trigger Alloc
	SaTriggerAlloc *uint64 `protobuf:"varint,9,opt,name=sa_trigger_alloc,json=saTriggerAlloc" json:"sa_trigger_alloc,omitempty"`
	// Alloc Fail
	SaTriggerAllocFail *uint64 `protobuf:"varint,10,opt,name=sa_trigger_alloc_fail,json=saTriggerAllocFail" json:"sa_trigger_alloc_fail,omitempty"`
	// Trigger Free
	SaTriggerFree *uint64 `protobuf:"varint,11,opt,name=sa_trigger_free,json=saTriggerFree" json:"sa_trigger_free,omitempty"`
	// Outstanding Trig Msg in Queue
	SaTrigEnqCount       *uint64  `protobuf:"varint,12,opt,name=sa_trig_enq_count,json=saTrigEnqCount" json:"sa_trig_enq_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPsecGlobalInfo) Reset()         { *m = IPsecGlobalInfo{} }
func (m *IPsecGlobalInfo) String() string { return proto.CompactTextString(m) }
func (*IPsecGlobalInfo) ProtoMessage()    {}
func (*IPsecGlobalInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_62544e4535d94422, []int{1}
}
func (m *IPsecGlobalInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPsecGlobalInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPsecGlobalInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPsecGlobalInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPsecGlobalInfo.Merge(m, src)
}
func (m *IPsecGlobalInfo) XXX_Size() int {
	return m.Size()
}
func (m *IPsecGlobalInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_IPsecGlobalInfo.DiscardUnknown(m)
}

var xxx_messageInfo_IPsecGlobalInfo proto.InternalMessageInfo

func (m *IPsecGlobalInfo) GetRePconnConnect() uint64 {
	if m != nil && m.RePconnConnect != nil {
		return *m.RePconnConnect
	}
	return 0
}

func (m *IPsecGlobalInfo) GetPconnStatus() uint64 {
	if m != nil && m.PconnStatus != nil {
		return *m.PconnStatus
	}
	return 0
}

func (m *IPsecGlobalInfo) GetSaTriggerEnqSuccess() uint64 {
	if m != nil && m.SaTriggerEnqSuccess != nil {
		return *m.SaTriggerEnqSuccess
	}
	return 0
}

func (m *IPsecGlobalInfo) GetSaTriggerEnqFail() uint64 {
	if m != nil && m.SaTriggerEnqFail != nil {
		return *m.SaTriggerEnqFail
	}
	return 0
}

func (m *IPsecGlobalInfo) GetSaTriggerRetrySuccess() uint64 {
	if m != nil && m.SaTriggerRetrySuccess != nil {
		return *m.SaTriggerRetrySuccess
	}
	return 0
}

func (m *IPsecGlobalInfo) GetSaTriggerRetryFail() uint64 {
	if m != nil && m.SaTriggerRetryFail != nil {
		return *m.SaTriggerRetryFail
	}
	return 0
}

func (m *IPsecGlobalInfo) GetSaTriggerSent() uint64 {
	if m != nil && m.SaTriggerSent != nil {
		return *m.SaTriggerSent
	}
	return 0
}

func (m *IPsecGlobalInfo) GetSaTriggerFail() uint64 {
	if m != nil && m.SaTriggerFail != nil {
		return *m.SaTriggerFail
	}
	return 0
}

func (m *IPsecGlobalInfo) GetSaTriggerAlloc() uint64 {
	if m != nil && m.SaTriggerAlloc != nil {
		return *m.SaTriggerAlloc
	}
	return 0
}

func (m *IPsecGlobalInfo) GetSaTriggerAllocFail() uint64 {
	if m != nil && m.SaTriggerAllocFail != nil {
		return *m.SaTriggerAllocFail
	}
	return 0
}

func (m *IPsecGlobalInfo) GetSaTriggerFree() uint64 {
	if m != nil && m.SaTriggerFree != nil {
		return *m.SaTriggerFree
	}
	return 0
}

func (m *IPsecGlobalInfo) GetSaTrigEnqCount() uint64 {
	if m != nil && m.SaTrigEnqCount != nil {
		return *m.SaTrigEnqCount
	}
	return 0
}

type IPsecPerSvcsetInfo struct {
	// Service Set ID
	SvcsetId *uint64 `protobuf:"varint,1,req,name=svcset_id,json=svcsetId" json:"svcset_id,omitempty"`
	// Rule Lookup Fail
	RuleLookupFailed *uint64 `protobuf:"varint,2,opt,name=rule_lookup_failed,json=ruleLookupFailed" json:"rule_lookup_failed,omitempty"`
	// SA Lookup Fail
	SaLookupFailed *uint64 `protobuf:"varint,3,opt,name=sa_lookup_failed,json=saLookupFailed" json:"sa_lookup_failed,omitempty"`
	// Pre Frags
	ExceedsTunnelMtu *uint64 `protobuf:"varint,4,opt,name=exceeds_tunnel_mtu,json=exceedsTunnelMtu" json:"exceeds_tunnel_mtu,omitempty"`
	// Clear Pkts Recvd for encap
	ClearPktReceived *uint64 `protobuf:"varint,5,opt,name=clear_pkt_received,json=clearPktReceived" json:"clear_pkt_received,omitempty"`
	// ESP Pkts Recvd
	EspPktReceived *uint64 `protobuf:"varint,6,opt,name=esp_pkt_received,json=espPktReceived" json:"esp_pkt_received,omitempty"`
	// Encap Pkts From Crypto
	EncapCallback *uint64 `protobuf:"varint,7,opt,name=encap_callback,json=encapCallback" json:"encap_callback,omitempty"`
	// Decap Pkts From Crypto
	DecapCallback        *uint64  `protobuf:"varint,8,opt,name=decap_callback,json=decapCallback" json:"decap_callback,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPsecPerSvcsetInfo) Reset()         { *m = IPsecPerSvcsetInfo{} }
func (m *IPsecPerSvcsetInfo) String() string { return proto.CompactTextString(m) }
func (*IPsecPerSvcsetInfo) ProtoMessage()    {}
func (*IPsecPerSvcsetInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_62544e4535d94422, []int{2}
}
func (m *IPsecPerSvcsetInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPsecPerSvcsetInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPsecPerSvcsetInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPsecPerSvcsetInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPsecPerSvcsetInfo.Merge(m, src)
}
func (m *IPsecPerSvcsetInfo) XXX_Size() int {
	return m.Size()
}
func (m *IPsecPerSvcsetInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_IPsecPerSvcsetInfo.DiscardUnknown(m)
}

var xxx_messageInfo_IPsecPerSvcsetInfo proto.InternalMessageInfo

func (m *IPsecPerSvcsetInfo) GetSvcsetId() uint64 {
	if m != nil && m.SvcsetId != nil {
		return *m.SvcsetId
	}
	return 0
}

func (m *IPsecPerSvcsetInfo) GetRuleLookupFailed() uint64 {
	if m != nil && m.RuleLookupFailed != nil {
		return *m.RuleLookupFailed
	}
	return 0
}

func (m *IPsecPerSvcsetInfo) GetSaLookupFailed() uint64 {
	if m != nil && m.SaLookupFailed != nil {
		return *m.SaLookupFailed
	}
	return 0
}

func (m *IPsecPerSvcsetInfo) GetExceedsTunnelMtu() uint64 {
	if m != nil && m.ExceedsTunnelMtu != nil {
		return *m.ExceedsTunnelMtu
	}
	return 0
}

func (m *IPsecPerSvcsetInfo) GetClearPktReceived() uint64 {
	if m != nil && m.ClearPktReceived != nil {
		return *m.ClearPktReceived
	}
	return 0
}

func (m *IPsecPerSvcsetInfo) GetEspPktReceived() uint64 {
	if m != nil && m.EspPktReceived != nil {
		return *m.EspPktReceived
	}
	return 0
}

func (m *IPsecPerSvcsetInfo) GetEncapCallback() uint64 {
	if m != nil && m.EncapCallback != nil {
		return *m.EncapCallback
	}
	return 0
}

func (m *IPsecPerSvcsetInfo) GetDecapCallback() uint64 {
	if m != nil && m.DecapCallback != nil {
		return *m.DecapCallback
	}
	return 0
}

type IPsecPerTunnelInfo struct {
	// Tunnel IDs on PIC
	TunnelId *uint64 `protobuf:"varint,1,req,name=tunnel_id,json=tunnelId" json:"tunnel_id,omitempty"`
	// Seq Num Zero
	EspRplzero *uint64 `protobuf:"varint,2,opt,name=esp_rplzero,json=espRplzero" json:"esp_rplzero,omitempty"`
	// Bad Pad
	IpsecBadHeaders *uint64 `protobuf:"varint,3,opt,name=ipsec_bad_headers,json=ipsecBadHeaders" json:"ipsec_bad_headers,omitempty"`
	// ESP Tail Err
	EspBadTrailers *uint64 `protobuf:"varint,4,opt,name=esp_bad_trailers,json=espBadTrailers" json:"esp_bad_trailers,omitempty"`
	// Next Proto Err
	DecapNxtProtoErr *uint64 `protobuf:"varint,5,opt,name=decap_nxt_proto_err,json=decapNxtProtoErr" json:"decap_nxt_proto_err,omitempty"`
	// Inner Len Err
	DecapInnerLenErr *uint64 `protobuf:"varint,6,opt,name=decap_inner_len_err,json=decapInnerLenErr" json:"decap_inner_len_err,omitempty"`
	// Outer Hdr Err
	DecapHdrErr *uint64 `protobuf:"varint,7,opt,name=decap_hdr_err,json=decapHdrErr" json:"decap_hdr_err,omitempty"`
	// Inner Saddr Err
	DecapInnerSaddrErr *uint64 `protobuf:"varint,8,opt,name=decap_inner_saddr_err,json=decapInnerSaddrErr" json:"decap_inner_saddr_err,omitempty"`
	// Inner Daddr Err
	DecapInnerDaddrErr *uint64 `protobuf:"varint,9,opt,name=decap_inner_daddr_err,json=decapInnerDaddrErr" json:"decap_inner_daddr_err,omitempty"`
	// Sn Alloc Fail
	DecapSnAllocFail *uint64 `protobuf:"varint,10,opt,name=decap_sn_alloc_fail,json=decapSnAllocFail" json:"decap_sn_alloc_fail,omitempty"`
	// Sn Ext Fail
	DecapSnExtFail *uint64 `protobuf:"varint,11,opt,name=decap_sn_ext_fail,json=decapSnExtFail" json:"decap_sn_ext_fail,omitempty"`
	// Auth Fail
	EspAuthFailed *uint64 `protobuf:"varint,12,opt,name=esp_auth_failed,json=espAuthFailed" json:"esp_auth_failed,omitempty"`
	// Reinject Fail
	DecapReinjectFail *uint64 `protobuf:"varint,13,opt,name=decap_reinject_fail,json=decapReinjectFail" json:"decap_reinject_fail,omitempty"`
	// Session Transient Drop
	DecapSnTransientDrop *uint64 `protobuf:"varint,14,opt,name=decap_sn_transient_drop,json=decapSnTransientDrop" json:"decap_sn_transient_drop,omitempty"`
	// Replay Before Win
	EspRplbeforewindow *uint64 `protobuf:"varint,15,opt,name=esp_rplbeforewindow,json=espRplbeforewindow" json:"esp_rplbeforewindow,omitempty"`
	// Replayed Pkts
	EspRplduplicate *uint64 `protobuf:"varint,16,opt,name=esp_rplduplicate,json=espRplduplicate" json:"esp_rplduplicate,omitempty"`
	// Encrypted Bytes
	EspProtectedBytesSent *uint64 `protobuf:"varint,17,opt,name=esp_protected_bytes_sent,json=espProtectedBytesSent" json:"esp_protected_bytes_sent,omitempty"`
	// Decrypted Bytes
	EspProtectedBytesRecvd *uint64 `protobuf:"varint,18,opt,name=esp_protected_bytes_recvd,json=espProtectedBytesRecvd" json:"esp_protected_bytes_recvd,omitempty"`
	// Encrypted Packets
	Encrypts *uint64 `protobuf:"varint,19,opt,name=encrypts" json:"encrypts,omitempty"`
	// Decrypted Packets
	Decrypts             *uint64  `protobuf:"varint,20,opt,name=decrypts" json:"decrypts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPsecPerTunnelInfo) Reset()         { *m = IPsecPerTunnelInfo{} }
func (m *IPsecPerTunnelInfo) String() string { return proto.CompactTextString(m) }
func (*IPsecPerTunnelInfo) ProtoMessage()    {}
func (*IPsecPerTunnelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_62544e4535d94422, []int{3}
}
func (m *IPsecPerTunnelInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPsecPerTunnelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPsecPerTunnelInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPsecPerTunnelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPsecPerTunnelInfo.Merge(m, src)
}
func (m *IPsecPerTunnelInfo) XXX_Size() int {
	return m.Size()
}
func (m *IPsecPerTunnelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_IPsecPerTunnelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_IPsecPerTunnelInfo proto.InternalMessageInfo

func (m *IPsecPerTunnelInfo) GetTunnelId() uint64 {
	if m != nil && m.TunnelId != nil {
		return *m.TunnelId
	}
	return 0
}

func (m *IPsecPerTunnelInfo) GetEspRplzero() uint64 {
	if m != nil && m.EspRplzero != nil {
		return *m.EspRplzero
	}
	return 0
}

func (m *IPsecPerTunnelInfo) GetIpsecBadHeaders() uint64 {
	if m != nil && m.IpsecBadHeaders != nil {
		return *m.IpsecBadHeaders
	}
	return 0
}

func (m *IPsecPerTunnelInfo) GetEspBadTrailers() uint64 {
	if m != nil && m.EspBadTrailers != nil {
		return *m.EspBadTrailers
	}
	return 0
}

func (m *IPsecPerTunnelInfo) GetDecapNxtProtoErr() uint64 {
	if m != nil && m.DecapNxtProtoErr != nil {
		return *m.DecapNxtProtoErr
	}
	return 0
}

func (m *IPsecPerTunnelInfo) GetDecapInnerLenErr() uint64 {
	if m != nil && m.DecapInnerLenErr != nil {
		return *m.DecapInnerLenErr
	}
	return 0
}

func (m *IPsecPerTunnelInfo) GetDecapHdrErr() uint64 {
	if m != nil && m.DecapHdrErr != nil {
		return *m.DecapHdrErr
	}
	return 0
}

func (m *IPsecPerTunnelInfo) GetDecapInnerSaddrErr() uint64 {
	if m != nil && m.DecapInnerSaddrErr != nil {
		return *m.DecapInnerSaddrErr
	}
	return 0
}

func (m *IPsecPerTunnelInfo) GetDecapInnerDaddrErr() uint64 {
	if m != nil && m.DecapInnerDaddrErr != nil {
		return *m.DecapInnerDaddrErr
	}
	return 0
}

func (m *IPsecPerTunnelInfo) GetDecapSnAllocFail() uint64 {
	if m != nil && m.DecapSnAllocFail != nil {
		return *m.DecapSnAllocFail
	}
	return 0
}

func (m *IPsecPerTunnelInfo) GetDecapSnExtFail() uint64 {
	if m != nil && m.DecapSnExtFail != nil {
		return *m.DecapSnExtFail
	}
	return 0
}

func (m *IPsecPerTunnelInfo) GetEspAuthFailed() uint64 {
	if m != nil && m.EspAuthFailed != nil {
		return *m.EspAuthFailed
	}
	return 0
}

func (m *IPsecPerTunnelInfo) GetDecapReinjectFail() uint64 {
	if m != nil && m.DecapReinjectFail != nil {
		return *m.DecapReinjectFail
	}
	return 0
}

func (m *IPsecPerTunnelInfo) GetDecapSnTransientDrop() uint64 {
	if m != nil && m.DecapSnTransientDrop != nil {
		return *m.DecapSnTransientDrop
	}
	return 0
}

func (m *IPsecPerTunnelInfo) GetEspRplbeforewindow() uint64 {
	if m != nil && m.EspRplbeforewindow != nil {
		return *m.EspRplbeforewindow
	}
	return 0
}

func (m *IPsecPerTunnelInfo) GetEspRplduplicate() uint64 {
	if m != nil && m.EspRplduplicate != nil {
		return *m.EspRplduplicate
	}
	return 0
}

func (m *IPsecPerTunnelInfo) GetEspProtectedBytesSent() uint64 {
	if m != nil && m.EspProtectedBytesSent != nil {
		return *m.EspProtectedBytesSent
	}
	return 0
}

func (m *IPsecPerTunnelInfo) GetEspProtectedBytesRecvd() uint64 {
	if m != nil && m.EspProtectedBytesRecvd != nil {
		return *m.EspProtectedBytesRecvd
	}
	return 0
}

func (m *IPsecPerTunnelInfo) GetEncrypts() uint64 {
	if m != nil && m.Encrypts != nil {
		return *m.Encrypts
	}
	return 0
}

func (m *IPsecPerTunnelInfo) GetDecrypts() uint64 {
	if m != nil && m.Decrypts != nil {
		return *m.Decrypts
	}
	return 0
}

var E_JnprIPsecVPNExt = &proto.ExtensionDesc{
	ExtendedType:  (*JuniperNetworksSensors)(nil),
	ExtensionType: (*IPsecVPN)(nil),
	Field:         77,
	Name:          "jnprIPsecVPNExt",
	Tag:           "bytes,77,opt,name=jnprIPsecVPNExt",
	Filename:      "ipsec_telemetry.proto",
}

func init() {
	proto.RegisterType((*IPsecVPN)(nil), "IPsecVPN")
	proto.RegisterType((*IPsecGlobalInfo)(nil), "IPsecGlobalInfo")
	proto.RegisterType((*IPsecPerSvcsetInfo)(nil), "IPsecPerSvcsetInfo")
	proto.RegisterType((*IPsecPerTunnelInfo)(nil), "IPsecPerTunnelInfo")
	proto.RegisterExtension(E_JnprIPsecVPNExt)
}

func init() { proto.RegisterFile("ipsec_telemetry.proto", fileDescriptor_62544e4535d94422) }

var fileDescriptor_62544e4535d94422 = []byte{
	// 1016 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x95, 0xdf, 0x4e, 0x1b, 0x47,
	0x14, 0xc6, 0x65, 0xa0, 0x09, 0x8c, 0x09, 0x98, 0x71, 0x48, 0xb6, 0xa9, 0x44, 0x29, 0x52, 0x2b,
	0x53, 0x05, 0x5b, 0x49, 0x55, 0x55, 0xad, 0x2a, 0x55, 0x81, 0x90, 0x86, 0x8a, 0x20, 0xcb, 0x46,
	0xbd, 0xe8, 0xcd, 0x76, 0x3c, 0x73, 0xb0, 0xd7, 0x5e, 0x66, 0x97, 0x99, 0xb3, 0x60, 0x7a, 0xd7,
	0x17, 0xea, 0x73, 0x54, 0xbd, 0xea, 0x0b, 0x54, 0xaa, 0x78, 0x92, 0x68, 0xfe, 0xad, 0xd7, 0x86,
	0x9b, 0x48, 0xfe, 0xbe, 0xdf, 0x77, 0xe6, 0xec, 0xc9, 0x99, 0x81, 0x6c, 0x27, 0xb9, 0x06, 0x1e,
	0x23, 0xa4, 0x70, 0x09, 0xa8, 0x6e, 0xdb, 0xb9, 0xca, 0x30, 0x7b, 0xd1, 0x2c, 0x85, 0x18, 0xb3,
	0xdc, 0x89, 0x7b, 0xff, 0xd4, 0xc8, 0xea, 0x49, 0x57, 0x03, 0xff, 0xb5, 0x7b, 0x46, 0x7f, 0x24,
	0x5b, 0x2e, 0x3a, 0x4c, 0xb3, 0x01, 0x4b, 0xe3, 0x44, 0x5e, 0x64, 0x51, 0x6d, 0x77, 0xb9, 0x55,
	0x7f, 0xdd, 0x68, 0x5b, 0xea, 0x67, 0x6b, 0x9c, 0xc8, 0x8b, 0xac, 0xb7, 0x69, 0xd1, 0x99, 0x40,
	0x7f, 0x0a, 0x69, 0x7d, 0xcd, 0x35, 0xa0, 0x4b, 0x2f, 0xd9, 0x74, 0xd3, 0xa5, 0xbb, 0xa0, 0xfa,
	0xd6, 0xab, 0x14, 0x98, 0x09, 0xb3, 0x02, 0x58, 0x48, 0x09, 0xfe, 0xf8, 0xe5, 0x85, 0x02, 0xe7,
	0xd6, 0xab, 0x14, 0x98, 0x09, 0x7b, 0x7f, 0xad, 0x90, 0xcd, 0x85, 0x36, 0x69, 0x8b, 0x34, 0x14,
	0xc4, 0x39, 0xcf, 0xa4, 0x8c, 0xcd, 0x3f, 0xc0, 0x31, 0xaa, 0xed, 0xd6, 0x5a, 0x2b, 0xbd, 0x0d,
	0x05, 0x5d, 0xa3, 0x1c, 0x39, 0x95, 0x7e, 0x41, 0xd6, 0x1d, 0xa6, 0x91, 0x61, 0xa1, 0xa3, 0x25,
	0x4b, 0xd5, 0xad, 0xd6, 0xb7, 0x12, 0xfd, 0x86, 0x3c, 0xd3, 0x2c, 0x46, 0x95, 0x0c, 0x87, 0xa0,
	0x62, 0x90, 0x57, 0xb1, 0x2e, 0x38, 0x07, 0xad, 0xa3, 0x65, 0x0b, 0x37, 0x35, 0x3b, 0x77, 0xe6,
	0xb1, 0xbc, 0xea, 0x3b, 0x8b, 0x1e, 0x90, 0xe6, 0x42, 0xe8, 0x82, 0x25, 0x69, 0xb4, 0x62, 0x13,
	0x8d, 0x6a, 0xe2, 0x1d, 0x4b, 0x52, 0xfa, 0x1d, 0x89, 0x2a, 0xb8, 0xb2, 0xff, 0x5f, 0xe1, 0x94,
	0x4f, 0x6c, 0x66, 0xbb, 0xcc, 0xf4, 0x8c, 0x1b, 0xce, 0x79, 0x45, 0xb6, 0xef, 0x05, 0xed, 0x49,
	0x8f, 0x6c, 0x8a, 0xce, 0xa7, 0xec, 0x59, 0x5f, 0x91, 0xcd, 0x4a, 0x44, 0x83, 0xc4, 0xe8, 0xb1,
	0x85, 0x9f, 0x94, 0x70, 0x1f, 0x24, 0x2e, 0x70, 0xb6, 0xe8, 0xea, 0x02, 0x67, 0xeb, 0xb5, 0x48,
	0xa3, 0xc2, 0xb1, 0x34, 0xcd, 0x78, 0xb4, 0xe6, 0x86, 0x5d, 0x82, 0x6f, 0x8c, 0xba, 0xd0, 0xac,
	0x25, 0x5d, 0x5d, 0xb2, 0xd0, 0xac, 0xc5, 0x1f, 0x68, 0xf6, 0x42, 0x01, 0x44, 0xf5, 0xc5, 0x26,
	0x14, 0x00, 0xdd, 0x27, 0x5b, 0x9e, 0xb3, 0xc3, 0xe6, 0x59, 0x21, 0x31, 0x5a, 0xaf, 0x76, 0x71,
	0x2c, 0xaf, 0x8e, 0x8c, 0xba, 0xf7, 0xdf, 0x12, 0xa1, 0xf7, 0x37, 0x93, 0x7e, 0x46, 0xd6, 0xc2,
	0x0e, 0x8b, 0xa8, 0xb6, 0xbb, 0xd4, 0x5a, 0xe9, 0xad, 0x3a, 0xe1, 0x44, 0xd0, 0x97, 0x84, 0xaa,
	0x22, 0x85, 0x38, 0xcd, 0xb2, 0x49, 0x91, 0xdb, 0xa6, 0x41, 0xf8, 0x65, 0x69, 0x18, 0xe7, 0xd4,
	0x1a, 0xef, 0xac, 0xee, 0x27, 0x32, 0xcf, 0x2e, 0x87, 0x5e, 0xe6, 0xc8, 0x97, 0x84, 0xc2, 0x94,
	0x03, 0x08, 0x1d, 0xf6, 0xff, 0x12, 0x8b, 0xb0, 0x25, 0xde, 0x71, 0xbb, 0xfe, 0x01, 0x0b, 0x43,
	0xf3, 0x14, 0x98, 0x8a, 0xf3, 0x09, 0xc6, 0x0a, 0x38, 0x24, 0xd7, 0x20, 0xfc, 0x7e, 0x34, 0xac,
	0xd3, 0x9d, 0x60, 0xcf, 0xeb, 0xa6, 0x0b, 0xd0, 0xf9, 0x3c, 0xeb, 0xb6, 0x62, 0x03, 0x74, 0x5e,
	0x25, 0xbf, 0x24, 0x1b, 0x20, 0x39, 0xcb, 0x63, 0xce, 0xd2, 0x74, 0xc0, 0xf8, 0x24, 0x2c, 0x84,
	0x55, 0x8f, 0xbc, 0x68, 0x30, 0x01, 0x73, 0x98, 0xdf, 0x07, 0xab, 0x06, 0x6c, 0xef, 0xcf, 0xc7,
	0xb3, 0xf9, 0xce, 0xee, 0xa9, 0x99, 0x6f, 0xb8, 0xe2, 0xe5, 0x7c, 0x9d, 0x70, 0x22, 0xe8, 0xe7,
	0xa4, 0x6e, 0x7a, 0x55, 0x79, 0xfa, 0x07, 0xa8, 0xcc, 0x0f, 0x96, 0x80, 0xce, 0x7b, 0x4e, 0xa1,
	0x5f, 0x87, 0x67, 0x62, 0xc0, 0x44, 0x3c, 0x02, 0x26, 0x40, 0x85, 0xfb, 0xe7, 0x5e, 0x84, 0x43,
	0x26, 0xde, 0x3b, 0x39, 0x7c, 0xb8, 0x21, 0x51, 0x99, 0x39, 0x2b, 0xed, 0x47, 0x6a, 0x3e, 0xfc,
	0x90, 0x89, 0x73, 0xaf, 0x9a, 0x5b, 0xea, 0xbe, 0x48, 0x4e, 0x31, 0xb6, 0x6f, 0x63, 0x0c, 0x4a,
	0x85, 0x89, 0x5a, 0xeb, 0x6c, 0x8a, 0x5d, 0x63, 0x1c, 0x2b, 0x35, 0xc3, 0x13, 0x29, 0x41, 0xc5,
	0x29, 0x48, 0x8b, 0x3f, 0xaa, 0xe0, 0x27, 0xc6, 0x39, 0x05, 0x69, 0xf0, 0x3d, 0xe2, 0x26, 0x13,
	0x8f, 0x84, 0xb2, 0xa0, 0x9b, 0x6a, 0xdd, 0x8a, 0xef, 0x85, 0x32, 0xcc, 0x2b, 0xb2, 0x5d, 0x2d,
	0xa9, 0x99, 0xf0, 0xac, 0x1b, 0x2d, 0x9d, 0x15, 0xed, 0x1b, 0xeb, 0x81, 0x88, 0x28, 0x23, 0x6b,
	0x8b, 0x91, 0xb7, 0x21, 0x52, 0x36, 0xae, 0xe5, 0xfd, 0x6b, 0xe7, 0x1a, 0xef, 0xcb, 0xd9, 0xa5,
	0xdb, 0x27, 0x5b, 0x25, 0x0e, 0x53, 0x74, 0xb0, 0xbb, 0x76, 0x1b, 0x1e, 0x3e, 0x9e, 0x62, 0xb8,
	0x9f, 0x66, 0xd6, 0xac, 0xc0, 0x51, 0xd8, 0xf4, 0x75, 0xbf, 0x3b, 0x3a, 0x7f, 0x53, 0xe0, 0xc8,
	0x2f, 0x7a, 0x3b, 0x74, 0xa0, 0x20, 0x91, 0x63, 0xe0, 0xbe, 0xe8, 0x13, 0xcb, 0xba, 0xd3, 0x7a,
	0xde, 0xb1, 0x75, 0xbf, 0x25, 0xcf, 0xcb, 0x16, 0x50, 0x31, 0xa9, 0x13, 0x90, 0x18, 0x0b, 0x95,
	0xe5, 0xd1, 0x86, 0xcd, 0x3c, 0xf5, 0x8d, 0x9c, 0x07, 0xf3, 0xad, 0xca, 0x72, 0xda, 0x21, 0x4d,
	0xbf, 0x47, 0x03, 0xb8, 0xc8, 0x14, 0xdc, 0x24, 0x52, 0x64, 0x37, 0xd1, 0xa6, 0x9b, 0x8c, 0xdb,
	0xa7, 0xaa, 0x43, 0xf7, 0xdd, 0xae, 0xa8, 0x3c, 0x15, 0x45, 0x9e, 0x26, 0x9c, 0x21, 0x44, 0x0d,
	0xb7, 0x56, 0x8e, 0x2e, 0x65, 0xf3, 0x46, 0xdb, 0xfb, 0xa4, 0x32, 0x04, 0x8e, 0x20, 0xe2, 0xc1,
	0x2d, 0x82, 0x76, 0x0f, 0xe8, 0x96, 0x7b, 0xa3, 0xcd, 0xbd, 0x0a, 0xf6, 0xa1, 0x71, 0xed, 0x43,
	0xfa, 0x3d, 0xf9, 0xf4, 0xa1, 0xa0, 0x02, 0x7e, 0x2d, 0x22, 0x6a, 0x93, 0xcf, 0xee, 0x25, 0x7b,
	0xc6, 0xa5, 0x2f, 0xc8, 0x2a, 0x48, 0xae, 0x6e, 0x73, 0xd4, 0x51, 0xd3, 0x92, 0xe5, 0x6f, 0xe3,
	0x09, 0xf0, 0xde, 0x53, 0xe7, 0x85, 0xdf, 0x3f, 0x9c, 0x92, 0xcd, 0xb1, 0xcc, 0x55, 0xf8, 0x23,
	0x7f, 0x3c, 0x45, 0xfa, 0xbc, 0xfd, 0x4b, 0x21, 0x93, 0x1c, 0xd4, 0x19, 0xe0, 0x4d, 0xa6, 0x26,
	0xa6, 0x37, 0x9d, 0x29, 0x1d, 0x7d, 0xd8, 0xad, 0xb5, 0xea, 0xaf, 0xd7, 0xda, 0x01, 0xee, 0x2d,
	0x46, 0x0f, 0x7f, 0xff, 0xfb, 0x6e, 0xa7, 0xf6, 0xef, 0xdd, 0x4e, 0xed, 0xff, 0xbb, 0x9d, 0xda,
	0x6f, 0xbd, 0x61, 0x82, 0xed, 0xb1, 0xab, 0xd5, 0x96, 0x80, 0x9d, 0x84, 0xc3, 0x00, 0xd4, 0xb0,
	0x33, 0x02, 0x96, 0xe2, 0x68, 0x90, 0xe1, 0x41, 0x22, 0x87, 0xa0, 0xf1, 0x60, 0x8c, 0xc9, 0x81,
	0x64, 0x98, 0x5c, 0x43, 0x27, 0x9f, 0x0c, 0x3b, 0x63, 0x4c, 0x3a, 0x4c, 0xb0, 0x1c, 0x41, 0xe9,
	0x4e, 0x3c, 0x2e, 0x64, 0xa6, 0x3b, 0x9a, 0x8f, 0xe0, 0x92, 0x7d, 0x0c, 0x00, 0x00, 0xff, 0xff,
	0x97, 0xd7, 0xde, 0xeb, 0xbe, 0x08, 0x00, 0x00,
}

func (m *IPsecVPN) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPsecVPN) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPsecVPN) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IpsecTunnelInfo) > 0 {
		for iNdEx := len(m.IpsecTunnelInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IpsecTunnelInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIpsecTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.IpsecSvcsetInfo) > 0 {
		for iNdEx := len(m.IpsecSvcsetInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IpsecSvcsetInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIpsecTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.IpsecGlobalInfo) > 0 {
		for iNdEx := len(m.IpsecGlobalInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IpsecGlobalInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIpsecTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IPsecGlobalInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPsecGlobalInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPsecGlobalInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SaTrigEnqCount != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.SaTrigEnqCount))
		i--
		dAtA[i] = 0x60
	}
	if m.SaTriggerFree != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.SaTriggerFree))
		i--
		dAtA[i] = 0x58
	}
	if m.SaTriggerAllocFail != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.SaTriggerAllocFail))
		i--
		dAtA[i] = 0x50
	}
	if m.SaTriggerAlloc != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.SaTriggerAlloc))
		i--
		dAtA[i] = 0x48
	}
	if m.SaTriggerFail != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.SaTriggerFail))
		i--
		dAtA[i] = 0x40
	}
	if m.SaTriggerSent != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.SaTriggerSent))
		i--
		dAtA[i] = 0x38
	}
	if m.SaTriggerRetryFail != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.SaTriggerRetryFail))
		i--
		dAtA[i] = 0x30
	}
	if m.SaTriggerRetrySuccess != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.SaTriggerRetrySuccess))
		i--
		dAtA[i] = 0x28
	}
	if m.SaTriggerEnqFail != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.SaTriggerEnqFail))
		i--
		dAtA[i] = 0x20
	}
	if m.SaTriggerEnqSuccess != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.SaTriggerEnqSuccess))
		i--
		dAtA[i] = 0x18
	}
	if m.PconnStatus != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.PconnStatus))
		i--
		dAtA[i] = 0x10
	}
	if m.RePconnConnect != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.RePconnConnect))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IPsecPerSvcsetInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPsecPerSvcsetInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPsecPerSvcsetInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DecapCallback != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.DecapCallback))
		i--
		dAtA[i] = 0x40
	}
	if m.EncapCallback != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.EncapCallback))
		i--
		dAtA[i] = 0x38
	}
	if m.EspPktReceived != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.EspPktReceived))
		i--
		dAtA[i] = 0x30
	}
	if m.ClearPktReceived != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.ClearPktReceived))
		i--
		dAtA[i] = 0x28
	}
	if m.ExceedsTunnelMtu != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.ExceedsTunnelMtu))
		i--
		dAtA[i] = 0x20
	}
	if m.SaLookupFailed != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.SaLookupFailed))
		i--
		dAtA[i] = 0x18
	}
	if m.RuleLookupFailed != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.RuleLookupFailed))
		i--
		dAtA[i] = 0x10
	}
	if m.SvcsetId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("svcset_id")
	} else {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.SvcsetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IPsecPerTunnelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPsecPerTunnelInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPsecPerTunnelInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Decrypts != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.Decrypts))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Encrypts != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.Encrypts))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.EspProtectedBytesRecvd != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.EspProtectedBytesRecvd))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.EspProtectedBytesSent != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.EspProtectedBytesSent))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.EspRplduplicate != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.EspRplduplicate))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.EspRplbeforewindow != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.EspRplbeforewindow))
		i--
		dAtA[i] = 0x78
	}
	if m.DecapSnTransientDrop != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.DecapSnTransientDrop))
		i--
		dAtA[i] = 0x70
	}
	if m.DecapReinjectFail != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.DecapReinjectFail))
		i--
		dAtA[i] = 0x68
	}
	if m.EspAuthFailed != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.EspAuthFailed))
		i--
		dAtA[i] = 0x60
	}
	if m.DecapSnExtFail != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.DecapSnExtFail))
		i--
		dAtA[i] = 0x58
	}
	if m.DecapSnAllocFail != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.DecapSnAllocFail))
		i--
		dAtA[i] = 0x50
	}
	if m.DecapInnerDaddrErr != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.DecapInnerDaddrErr))
		i--
		dAtA[i] = 0x48
	}
	if m.DecapInnerSaddrErr != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.DecapInnerSaddrErr))
		i--
		dAtA[i] = 0x40
	}
	if m.DecapHdrErr != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.DecapHdrErr))
		i--
		dAtA[i] = 0x38
	}
	if m.DecapInnerLenErr != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.DecapInnerLenErr))
		i--
		dAtA[i] = 0x30
	}
	if m.DecapNxtProtoErr != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.DecapNxtProtoErr))
		i--
		dAtA[i] = 0x28
	}
	if m.EspBadTrailers != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.EspBadTrailers))
		i--
		dAtA[i] = 0x20
	}
	if m.IpsecBadHeaders != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.IpsecBadHeaders))
		i--
		dAtA[i] = 0x18
	}
	if m.EspRplzero != nil {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.EspRplzero))
		i--
		dAtA[i] = 0x10
	}
	if m.TunnelId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("tunnel_id")
	} else {
		i = encodeVarintIpsecTelemetry(dAtA, i, uint64(*m.TunnelId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintIpsecTelemetry(dAtA []byte, offset int, v uint64) int {
	offset -= sovIpsecTelemetry(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *IPsecVPN) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IpsecGlobalInfo) > 0 {
		for _, e := range m.IpsecGlobalInfo {
			l = e.Size()
			n += 1 + l + sovIpsecTelemetry(uint64(l))
		}
	}
	if len(m.IpsecSvcsetInfo) > 0 {
		for _, e := range m.IpsecSvcsetInfo {
			l = e.Size()
			n += 1 + l + sovIpsecTelemetry(uint64(l))
		}
	}
	if len(m.IpsecTunnelInfo) > 0 {
		for _, e := range m.IpsecTunnelInfo {
			l = e.Size()
			n += 1 + l + sovIpsecTelemetry(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IPsecGlobalInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RePconnConnect != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.RePconnConnect))
	}
	if m.PconnStatus != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.PconnStatus))
	}
	if m.SaTriggerEnqSuccess != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.SaTriggerEnqSuccess))
	}
	if m.SaTriggerEnqFail != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.SaTriggerEnqFail))
	}
	if m.SaTriggerRetrySuccess != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.SaTriggerRetrySuccess))
	}
	if m.SaTriggerRetryFail != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.SaTriggerRetryFail))
	}
	if m.SaTriggerSent != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.SaTriggerSent))
	}
	if m.SaTriggerFail != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.SaTriggerFail))
	}
	if m.SaTriggerAlloc != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.SaTriggerAlloc))
	}
	if m.SaTriggerAllocFail != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.SaTriggerAllocFail))
	}
	if m.SaTriggerFree != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.SaTriggerFree))
	}
	if m.SaTrigEnqCount != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.SaTrigEnqCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IPsecPerSvcsetInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SvcsetId != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.SvcsetId))
	}
	if m.RuleLookupFailed != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.RuleLookupFailed))
	}
	if m.SaLookupFailed != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.SaLookupFailed))
	}
	if m.ExceedsTunnelMtu != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.ExceedsTunnelMtu))
	}
	if m.ClearPktReceived != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.ClearPktReceived))
	}
	if m.EspPktReceived != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.EspPktReceived))
	}
	if m.EncapCallback != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.EncapCallback))
	}
	if m.DecapCallback != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.DecapCallback))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IPsecPerTunnelInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TunnelId != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.TunnelId))
	}
	if m.EspRplzero != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.EspRplzero))
	}
	if m.IpsecBadHeaders != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.IpsecBadHeaders))
	}
	if m.EspBadTrailers != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.EspBadTrailers))
	}
	if m.DecapNxtProtoErr != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.DecapNxtProtoErr))
	}
	if m.DecapInnerLenErr != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.DecapInnerLenErr))
	}
	if m.DecapHdrErr != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.DecapHdrErr))
	}
	if m.DecapInnerSaddrErr != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.DecapInnerSaddrErr))
	}
	if m.DecapInnerDaddrErr != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.DecapInnerDaddrErr))
	}
	if m.DecapSnAllocFail != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.DecapSnAllocFail))
	}
	if m.DecapSnExtFail != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.DecapSnExtFail))
	}
	if m.EspAuthFailed != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.EspAuthFailed))
	}
	if m.DecapReinjectFail != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.DecapReinjectFail))
	}
	if m.DecapSnTransientDrop != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.DecapSnTransientDrop))
	}
	if m.EspRplbeforewindow != nil {
		n += 1 + sovIpsecTelemetry(uint64(*m.EspRplbeforewindow))
	}
	if m.EspRplduplicate != nil {
		n += 2 + sovIpsecTelemetry(uint64(*m.EspRplduplicate))
	}
	if m.EspProtectedBytesSent != nil {
		n += 2 + sovIpsecTelemetry(uint64(*m.EspProtectedBytesSent))
	}
	if m.EspProtectedBytesRecvd != nil {
		n += 2 + sovIpsecTelemetry(uint64(*m.EspProtectedBytesRecvd))
	}
	if m.Encrypts != nil {
		n += 2 + sovIpsecTelemetry(uint64(*m.Encrypts))
	}
	if m.Decrypts != nil {
		n += 2 + sovIpsecTelemetry(uint64(*m.Decrypts))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovIpsecTelemetry(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozIpsecTelemetry(x uint64) (n int) {
	return sovIpsecTelemetry(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IPsecVPN) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPsecVPN: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPsecVPN: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpsecGlobalInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsecTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpsecGlobalInfo = append(m.IpsecGlobalInfo, &IPsecGlobalInfo{})
			if err := m.IpsecGlobalInfo[len(m.IpsecGlobalInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpsecSvcsetInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsecTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpsecSvcsetInfo = append(m.IpsecSvcsetInfo, &IPsecPerSvcsetInfo{})
			if err := m.IpsecSvcsetInfo[len(m.IpsecSvcsetInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpsecTunnelInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpsecTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpsecTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpsecTunnelInfo = append(m.IpsecTunnelInfo, &IPsecPerTunnelInfo{})
			if err := m.IpsecTunnelInfo[len(m.IpsecTunnelInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecTelemetry
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsecTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPsecGlobalInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPsecGlobalInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPsecGlobalInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RePconnConnect", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RePconnConnect = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PconnStatus", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PconnStatus = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaTriggerEnqSuccess", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SaTriggerEnqSuccess = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaTriggerEnqFail", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SaTriggerEnqFail = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaTriggerRetrySuccess", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SaTriggerRetrySuccess = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaTriggerRetryFail", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SaTriggerRetryFail = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaTriggerSent", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SaTriggerSent = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaTriggerFail", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SaTriggerFail = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaTriggerAlloc", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SaTriggerAlloc = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaTriggerAllocFail", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SaTriggerAllocFail = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaTriggerFree", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SaTriggerFree = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaTrigEnqCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SaTrigEnqCount = &v
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecTelemetry
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsecTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPsecPerSvcsetInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPsecPerSvcsetInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPsecPerSvcsetInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SvcsetId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SvcsetId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleLookupFailed", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RuleLookupFailed = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaLookupFailed", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SaLookupFailed = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExceedsTunnelMtu", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExceedsTunnelMtu = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearPktReceived", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClearPktReceived = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EspPktReceived", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EspPktReceived = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncapCallback", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EncapCallback = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecapCallback", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DecapCallback = &v
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecTelemetry
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsecTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("svcset_id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPsecPerTunnelInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpsecTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPsecPerTunnelInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPsecPerTunnelInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TunnelId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EspRplzero", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EspRplzero = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpsecBadHeaders", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpsecBadHeaders = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EspBadTrailers", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EspBadTrailers = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecapNxtProtoErr", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DecapNxtProtoErr = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecapInnerLenErr", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DecapInnerLenErr = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecapHdrErr", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DecapHdrErr = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecapInnerSaddrErr", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DecapInnerSaddrErr = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecapInnerDaddrErr", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DecapInnerDaddrErr = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecapSnAllocFail", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DecapSnAllocFail = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecapSnExtFail", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DecapSnExtFail = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EspAuthFailed", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EspAuthFailed = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecapReinjectFail", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DecapReinjectFail = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecapSnTransientDrop", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DecapSnTransientDrop = &v
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EspRplbeforewindow", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EspRplbeforewindow = &v
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EspRplduplicate", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EspRplduplicate = &v
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EspProtectedBytesSent", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EspProtectedBytesSent = &v
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EspProtectedBytesRecvd", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EspProtectedBytesRecvd = &v
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encrypts", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Encrypts = &v
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decrypts", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Decrypts = &v
		default:
			iNdEx = preIndex
			skippy, err := skipIpsecTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpsecTelemetry
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIpsecTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("tunnel_id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIpsecTelemetry(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIpsecTelemetry
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIpsecTelemetry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthIpsecTelemetry
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupIpsecTelemetry
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthIpsecTelemetry
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthIpsecTelemetry        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIpsecTelemetry          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupIpsecTelemetry = fmt.Errorf("proto: unexpected end of group")
)
