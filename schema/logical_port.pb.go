// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: logical_port.proto

package schema

import (
	fmt "fmt"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

//
// Top-level message
//
type LogicalPort struct {
	InterfaceInfo        []*LogicalInterfaceInfo `protobuf:"bytes,1,rep,name=interface_info,json=interfaceInfo" json:"interface_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *LogicalPort) Reset()         { *m = LogicalPort{} }
func (m *LogicalPort) String() string { return proto.CompactTextString(m) }
func (*LogicalPort) ProtoMessage()    {}
func (*LogicalPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed53654dcd9b9a05, []int{0}
}
func (m *LogicalPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogicalPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogicalPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogicalPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogicalPort.Merge(m, src)
}
func (m *LogicalPort) XXX_Size() int {
	return m.Size()
}
func (m *LogicalPort) XXX_DiscardUnknown() {
	xxx_messageInfo_LogicalPort.DiscardUnknown(m)
}

var xxx_messageInfo_LogicalPort proto.InternalMessageInfo

func (m *LogicalPort) GetInterfaceInfo() []*LogicalInterfaceInfo {
	if m != nil {
		return m.InterfaceInfo
	}
	return nil
}

//
// Logical Interaface information
//
type LogicalInterfaceInfo struct {
	// Logical interface name (e.g. xe-0/0/0.0)
	IfName *string `protobuf:"bytes,1,req,name=if_name,json=ifName" json:"if_name,omitempty"`
	// Time reset
	InitTime *uint64 `protobuf:"varint,2,req,name=init_time,json=initTime" json:"init_time,omitempty"`
	// Global Index
	SnmpIfIndex *uint32 `protobuf:"varint,3,opt,name=snmp_if_index,json=snmpIfIndex" json:"snmp_if_index,omitempty"`
	// Name of the aggregate bundle
	ParentAeName *string `protobuf:"bytes,4,opt,name=parent_ae_name,json=parentAeName" json:"parent_ae_name,omitempty"`
	// Inbound traffic statistics
	IngressStats *IngressInterfaceStats `protobuf:"bytes,5,opt,name=ingress_stats,json=ingressStats" json:"ingress_stats,omitempty"`
	// Outbound traffic statistics
	EgressStats *EgressInterfaceStats `protobuf:"bytes,6,opt,name=egress_stats,json=egressStats" json:"egress_stats,omitempty"`
	// Link state UP\DOWN etc.
	OpState *OperationalState `protobuf:"bytes,7,opt,name=op_state,json=opState" json:"op_state,omitempty"`
	// administrative status, i.e.. enabled/disabled
	AdministractiveStatus *string `protobuf:"bytes,8,opt,name=administractive_status,json=administractiveStatus" json:"administractive_status,omitempty"`
	// Description of the interface
	Description *string `protobuf:"bytes,9,opt,name=description" json:"description,omitempty"`
	// This corresponds to the ifLastChange object in the standard interface MIB
	LastChange *uint32 `protobuf:"varint,10,opt,name=last_change,json=lastChange" json:"last_change,omitempty"`
	// This corresponds to the ifHighSpeed object in the standard interface MIB
	HighSpeed *uint32 `protobuf:"varint,11,opt,name=high_speed,json=highSpeed" json:"high_speed,omitempty"`
	// Ingress queue information
	IngressQueueInfo []*LogicalInterfaceQueueStats `protobuf:"bytes,12,rep,name=ingress_queue_info,json=ingressQueueInfo" json:"ingress_queue_info,omitempty"`
	// Egress queue information
	EgressQueueInfo      []*LogicalInterfaceQueueStats `protobuf:"bytes,13,rep,name=egress_queue_info,json=egressQueueInfo" json:"egress_queue_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *LogicalInterfaceInfo) Reset()         { *m = LogicalInterfaceInfo{} }
func (m *LogicalInterfaceInfo) String() string { return proto.CompactTextString(m) }
func (*LogicalInterfaceInfo) ProtoMessage()    {}
func (*LogicalInterfaceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed53654dcd9b9a05, []int{1}
}
func (m *LogicalInterfaceInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogicalInterfaceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogicalInterfaceInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogicalInterfaceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogicalInterfaceInfo.Merge(m, src)
}
func (m *LogicalInterfaceInfo) XXX_Size() int {
	return m.Size()
}
func (m *LogicalInterfaceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LogicalInterfaceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LogicalInterfaceInfo proto.InternalMessageInfo

func (m *LogicalInterfaceInfo) GetIfName() string {
	if m != nil && m.IfName != nil {
		return *m.IfName
	}
	return ""
}

func (m *LogicalInterfaceInfo) GetInitTime() uint64 {
	if m != nil && m.InitTime != nil {
		return *m.InitTime
	}
	return 0
}

func (m *LogicalInterfaceInfo) GetSnmpIfIndex() uint32 {
	if m != nil && m.SnmpIfIndex != nil {
		return *m.SnmpIfIndex
	}
	return 0
}

func (m *LogicalInterfaceInfo) GetParentAeName() string {
	if m != nil && m.ParentAeName != nil {
		return *m.ParentAeName
	}
	return ""
}

func (m *LogicalInterfaceInfo) GetIngressStats() *IngressInterfaceStats {
	if m != nil {
		return m.IngressStats
	}
	return nil
}

func (m *LogicalInterfaceInfo) GetEgressStats() *EgressInterfaceStats {
	if m != nil {
		return m.EgressStats
	}
	return nil
}

func (m *LogicalInterfaceInfo) GetOpState() *OperationalState {
	if m != nil {
		return m.OpState
	}
	return nil
}

func (m *LogicalInterfaceInfo) GetAdministractiveStatus() string {
	if m != nil && m.AdministractiveStatus != nil {
		return *m.AdministractiveStatus
	}
	return ""
}

func (m *LogicalInterfaceInfo) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *LogicalInterfaceInfo) GetLastChange() uint32 {
	if m != nil && m.LastChange != nil {
		return *m.LastChange
	}
	return 0
}

func (m *LogicalInterfaceInfo) GetHighSpeed() uint32 {
	if m != nil && m.HighSpeed != nil {
		return *m.HighSpeed
	}
	return 0
}

func (m *LogicalInterfaceInfo) GetIngressQueueInfo() []*LogicalInterfaceQueueStats {
	if m != nil {
		return m.IngressQueueInfo
	}
	return nil
}

func (m *LogicalInterfaceInfo) GetEgressQueueInfo() []*LogicalInterfaceQueueStats {
	if m != nil {
		return m.EgressQueueInfo
	}
	return nil
}

//
//  Interface inbound/Ingress traffic statistics
//
type IngressInterfaceStats struct {
	// Count of packets
	IfPackets *uint64 `protobuf:"varint,1,req,name=if_packets,json=ifPackets" json:"if_packets,omitempty"`
	// Count of bytes
	IfOctets *uint64 `protobuf:"varint,2,req,name=if_octets,json=ifOctets" json:"if_octets,omitempty"`
	// Count of unicast packets
	IfUcastPackets *uint64 `protobuf:"varint,3,opt,name=if_ucast_packets,json=ifUcastPackets" json:"if_ucast_packets,omitempty"`
	// Count of multicast packets
	IfMcastPackets       *uint64                      `protobuf:"varint,4,opt,name=if_mcast_packets,json=ifMcastPackets" json:"if_mcast_packets,omitempty"`
	IfFcStats            []*ForwardingClassAccounting `protobuf:"bytes,5,rep,name=if_fc_stats,json=ifFcStats" json:"if_fc_stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *IngressInterfaceStats) Reset()         { *m = IngressInterfaceStats{} }
func (m *IngressInterfaceStats) String() string { return proto.CompactTextString(m) }
func (*IngressInterfaceStats) ProtoMessage()    {}
func (*IngressInterfaceStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed53654dcd9b9a05, []int{2}
}
func (m *IngressInterfaceStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngressInterfaceStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngressInterfaceStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngressInterfaceStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngressInterfaceStats.Merge(m, src)
}
func (m *IngressInterfaceStats) XXX_Size() int {
	return m.Size()
}
func (m *IngressInterfaceStats) XXX_DiscardUnknown() {
	xxx_messageInfo_IngressInterfaceStats.DiscardUnknown(m)
}

var xxx_messageInfo_IngressInterfaceStats proto.InternalMessageInfo

func (m *IngressInterfaceStats) GetIfPackets() uint64 {
	if m != nil && m.IfPackets != nil {
		return *m.IfPackets
	}
	return 0
}

func (m *IngressInterfaceStats) GetIfOctets() uint64 {
	if m != nil && m.IfOctets != nil {
		return *m.IfOctets
	}
	return 0
}

func (m *IngressInterfaceStats) GetIfUcastPackets() uint64 {
	if m != nil && m.IfUcastPackets != nil {
		return *m.IfUcastPackets
	}
	return 0
}

func (m *IngressInterfaceStats) GetIfMcastPackets() uint64 {
	if m != nil && m.IfMcastPackets != nil {
		return *m.IfMcastPackets
	}
	return 0
}

func (m *IngressInterfaceStats) GetIfFcStats() []*ForwardingClassAccounting {
	if m != nil {
		return m.IfFcStats
	}
	return nil
}

//
//  Interface outbound/Egress traffic statistics
//
type EgressInterfaceStats struct {
	// Count of packets
	IfPackets *uint64 `protobuf:"varint,1,req,name=if_packets,json=ifPackets" json:"if_packets,omitempty"`
	// Count of bytes
	IfOctets *uint64 `protobuf:"varint,2,req,name=if_octets,json=ifOctets" json:"if_octets,omitempty"`
	// Count of unicast packets
	IfUcastPackets *uint64 `protobuf:"varint,3,opt,name=if_ucast_packets,json=ifUcastPackets" json:"if_ucast_packets,omitempty"`
	// Count of multicast packets
	IfMcastPackets       *uint64  `protobuf:"varint,4,opt,name=if_mcast_packets,json=ifMcastPackets" json:"if_mcast_packets,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EgressInterfaceStats) Reset()         { *m = EgressInterfaceStats{} }
func (m *EgressInterfaceStats) String() string { return proto.CompactTextString(m) }
func (*EgressInterfaceStats) ProtoMessage()    {}
func (*EgressInterfaceStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed53654dcd9b9a05, []int{3}
}
func (m *EgressInterfaceStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EgressInterfaceStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EgressInterfaceStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EgressInterfaceStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EgressInterfaceStats.Merge(m, src)
}
func (m *EgressInterfaceStats) XXX_Size() int {
	return m.Size()
}
func (m *EgressInterfaceStats) XXX_DiscardUnknown() {
	xxx_messageInfo_EgressInterfaceStats.DiscardUnknown(m)
}

var xxx_messageInfo_EgressInterfaceStats proto.InternalMessageInfo

func (m *EgressInterfaceStats) GetIfPackets() uint64 {
	if m != nil && m.IfPackets != nil {
		return *m.IfPackets
	}
	return 0
}

func (m *EgressInterfaceStats) GetIfOctets() uint64 {
	if m != nil && m.IfOctets != nil {
		return *m.IfOctets
	}
	return 0
}

func (m *EgressInterfaceStats) GetIfUcastPackets() uint64 {
	if m != nil && m.IfUcastPackets != nil {
		return *m.IfUcastPackets
	}
	return 0
}

func (m *EgressInterfaceStats) GetIfMcastPackets() uint64 {
	if m != nil && m.IfMcastPackets != nil {
		return *m.IfMcastPackets
	}
	return 0
}

//
//  Interface operational State details
//
type OperationalState struct {
	// If the link is up/down
	OperationalStatus    *string  `protobuf:"bytes,1,opt,name=operational_status,json=operationalStatus" json:"operational_status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OperationalState) Reset()         { *m = OperationalState{} }
func (m *OperationalState) String() string { return proto.CompactTextString(m) }
func (*OperationalState) ProtoMessage()    {}
func (*OperationalState) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed53654dcd9b9a05, []int{4}
}
func (m *OperationalState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperationalState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperationalState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperationalState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperationalState.Merge(m, src)
}
func (m *OperationalState) XXX_Size() int {
	return m.Size()
}
func (m *OperationalState) XXX_DiscardUnknown() {
	xxx_messageInfo_OperationalState.DiscardUnknown(m)
}

var xxx_messageInfo_OperationalState proto.InternalMessageInfo

func (m *OperationalState) GetOperationalStatus() string {
	if m != nil && m.OperationalStatus != nil {
		return *m.OperationalStatus
	}
	return ""
}

//
//  Interface forwarding class accounting
//
type ForwardingClassAccounting struct {
	// Interface protocol
	IfFamily *string `protobuf:"bytes,1,opt,name=if_family,json=ifFamily" json:"if_family,omitempty"`
	// Forwarding class number
	FcNumber *uint32 `protobuf:"varint,2,opt,name=fc_number,json=fcNumber" json:"fc_number,omitempty"`
	// Count of packets
	IfPackets *uint64 `protobuf:"varint,3,opt,name=if_packets,json=ifPackets" json:"if_packets,omitempty"`
	// Count of bytes
	IfOctets             *uint64  `protobuf:"varint,4,opt,name=if_octets,json=ifOctets" json:"if_octets,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ForwardingClassAccounting) Reset()         { *m = ForwardingClassAccounting{} }
func (m *ForwardingClassAccounting) String() string { return proto.CompactTextString(m) }
func (*ForwardingClassAccounting) ProtoMessage()    {}
func (*ForwardingClassAccounting) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed53654dcd9b9a05, []int{5}
}
func (m *ForwardingClassAccounting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForwardingClassAccounting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForwardingClassAccounting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForwardingClassAccounting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForwardingClassAccounting.Merge(m, src)
}
func (m *ForwardingClassAccounting) XXX_Size() int {
	return m.Size()
}
func (m *ForwardingClassAccounting) XXX_DiscardUnknown() {
	xxx_messageInfo_ForwardingClassAccounting.DiscardUnknown(m)
}

var xxx_messageInfo_ForwardingClassAccounting proto.InternalMessageInfo

func (m *ForwardingClassAccounting) GetIfFamily() string {
	if m != nil && m.IfFamily != nil {
		return *m.IfFamily
	}
	return ""
}

func (m *ForwardingClassAccounting) GetFcNumber() uint32 {
	if m != nil && m.FcNumber != nil {
		return *m.FcNumber
	}
	return 0
}

func (m *ForwardingClassAccounting) GetIfPackets() uint64 {
	if m != nil && m.IfPackets != nil {
		return *m.IfPackets
	}
	return 0
}

func (m *ForwardingClassAccounting) GetIfOctets() uint64 {
	if m != nil && m.IfOctets != nil {
		return *m.IfOctets
	}
	return 0
}

//
//  logical Interface family stats accounting
//
type FamilyAccounting struct {
	// Interface protocol
	IfFamily *string `protobuf:"bytes,1,opt,name=if_family,json=ifFamily" json:"if_family,omitempty"`
	// Count of packets
	IfPackets *uint64 `protobuf:"varint,2,opt,name=if_packets,json=ifPackets" json:"if_packets,omitempty"`
	// Count of v4 bytes
	IfOctets *uint64 `protobuf:"varint,3,opt,name=if_octets,json=ifOctets" json:"if_octets,omitempty"`
	// Count of v6 packets
	IfV6Packets *uint64 `protobuf:"varint,4,opt,name=if_v6_packets,json=ifV6Packets" json:"if_v6_packets,omitempty"`
	// Count of v6 bytes
	IfV6Octets *uint64 `protobuf:"varint,5,opt,name=if_v6_octets,json=ifV6Octets" json:"if_v6_octets,omitempty"`
	// Count of multicast packets
	IfMcastPackets *uint64 `protobuf:"varint,6,opt,name=if_mcast_packets,json=ifMcastPackets" json:"if_mcast_packets,omitempty"`
	// Count of multicast bytes
	IfMcastOctets        *uint64  `protobuf:"varint,7,opt,name=if_mcast_octets,json=ifMcastOctets" json:"if_mcast_octets,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FamilyAccounting) Reset()         { *m = FamilyAccounting{} }
func (m *FamilyAccounting) String() string { return proto.CompactTextString(m) }
func (*FamilyAccounting) ProtoMessage()    {}
func (*FamilyAccounting) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed53654dcd9b9a05, []int{6}
}
func (m *FamilyAccounting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FamilyAccounting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FamilyAccounting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FamilyAccounting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FamilyAccounting.Merge(m, src)
}
func (m *FamilyAccounting) XXX_Size() int {
	return m.Size()
}
func (m *FamilyAccounting) XXX_DiscardUnknown() {
	xxx_messageInfo_FamilyAccounting.DiscardUnknown(m)
}

var xxx_messageInfo_FamilyAccounting proto.InternalMessageInfo

func (m *FamilyAccounting) GetIfFamily() string {
	if m != nil && m.IfFamily != nil {
		return *m.IfFamily
	}
	return ""
}

func (m *FamilyAccounting) GetIfPackets() uint64 {
	if m != nil && m.IfPackets != nil {
		return *m.IfPackets
	}
	return 0
}

func (m *FamilyAccounting) GetIfOctets() uint64 {
	if m != nil && m.IfOctets != nil {
		return *m.IfOctets
	}
	return 0
}

func (m *FamilyAccounting) GetIfV6Packets() uint64 {
	if m != nil && m.IfV6Packets != nil {
		return *m.IfV6Packets
	}
	return 0
}

func (m *FamilyAccounting) GetIfV6Octets() uint64 {
	if m != nil && m.IfV6Octets != nil {
		return *m.IfV6Octets
	}
	return 0
}

func (m *FamilyAccounting) GetIfMcastPackets() uint64 {
	if m != nil && m.IfMcastPackets != nil {
		return *m.IfMcastPackets
	}
	return 0
}

func (m *FamilyAccounting) GetIfMcastOctets() uint64 {
	if m != nil && m.IfMcastOctets != nil {
		return *m.IfMcastOctets
	}
	return 0
}

//
// Interface queue statistics
//
type LogicalInterfaceQueueStats struct {
	// Queue number
	QueueNumber *uint32 `protobuf:"varint,1,opt,name=queue_number,json=queueNumber" json:"queue_number,omitempty"`
	// The total number of packets that have been added to this queue
	Packets *uint64 `protobuf:"varint,2,opt,name=packets" json:"packets,omitempty"`
	// The total number of bytes that have been added to this queue
	Bytes *uint64 `protobuf:"varint,3,opt,name=bytes" json:"bytes,omitempty"`
	// The total number of tail dropped packets
	TailDropPackets *uint64 `protobuf:"varint,4,opt,name=tail_drop_packets,json=tailDropPackets" json:"tail_drop_packets,omitempty"`
	// The total number of rate-limited packets
	RateLimitDropPackets *uint64 `protobuf:"varint,5,opt,name=rate_limit_drop_packets,json=rateLimitDropPackets" json:"rate_limit_drop_packets,omitempty"`
	// The total number of rate-limited bytes
	RateLimitDropBytes *uint64 `protobuf:"varint,6,opt,name=rate_limit_drop_bytes,json=rateLimitDropBytes" json:"rate_limit_drop_bytes,omitempty"`
	// The total number of red-dropped packets
	RedDropPackets *uint64 `protobuf:"varint,7,opt,name=red_drop_packets,json=redDropPackets" json:"red_drop_packets,omitempty"`
	// The total number of red-dropped bytes
	RedDropBytes *uint64 `protobuf:"varint,8,opt,name=red_drop_bytes,json=redDropBytes" json:"red_drop_bytes,omitempty"`
	// Average queue depth, in packets
	AverageBufferOccupancy *uint64 `protobuf:"varint,9,opt,name=average_buffer_occupancy,json=averageBufferOccupancy" json:"average_buffer_occupancy,omitempty"`
	// Current queue depth, in packets
	CurrentBufferOccupancy *uint64 `protobuf:"varint,10,opt,name=current_buffer_occupancy,json=currentBufferOccupancy" json:"current_buffer_occupancy,omitempty"`
	// The max measured queue depth, in packets, across all measurements since boot
	PeakBufferOccupancy *uint64 `protobuf:"varint,11,opt,name=peak_buffer_occupancy,json=peakBufferOccupancy" json:"peak_buffer_occupancy,omitempty"`
	// Allocated buffer size
	AllocatedBufferSize  *uint64  `protobuf:"varint,12,opt,name=allocated_buffer_size,json=allocatedBufferSize" json:"allocated_buffer_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogicalInterfaceQueueStats) Reset()         { *m = LogicalInterfaceQueueStats{} }
func (m *LogicalInterfaceQueueStats) String() string { return proto.CompactTextString(m) }
func (*LogicalInterfaceQueueStats) ProtoMessage()    {}
func (*LogicalInterfaceQueueStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed53654dcd9b9a05, []int{7}
}
func (m *LogicalInterfaceQueueStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogicalInterfaceQueueStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogicalInterfaceQueueStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogicalInterfaceQueueStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogicalInterfaceQueueStats.Merge(m, src)
}
func (m *LogicalInterfaceQueueStats) XXX_Size() int {
	return m.Size()
}
func (m *LogicalInterfaceQueueStats) XXX_DiscardUnknown() {
	xxx_messageInfo_LogicalInterfaceQueueStats.DiscardUnknown(m)
}

var xxx_messageInfo_LogicalInterfaceQueueStats proto.InternalMessageInfo

func (m *LogicalInterfaceQueueStats) GetQueueNumber() uint32 {
	if m != nil && m.QueueNumber != nil {
		return *m.QueueNumber
	}
	return 0
}

func (m *LogicalInterfaceQueueStats) GetPackets() uint64 {
	if m != nil && m.Packets != nil {
		return *m.Packets
	}
	return 0
}

func (m *LogicalInterfaceQueueStats) GetBytes() uint64 {
	if m != nil && m.Bytes != nil {
		return *m.Bytes
	}
	return 0
}

func (m *LogicalInterfaceQueueStats) GetTailDropPackets() uint64 {
	if m != nil && m.TailDropPackets != nil {
		return *m.TailDropPackets
	}
	return 0
}

func (m *LogicalInterfaceQueueStats) GetRateLimitDropPackets() uint64 {
	if m != nil && m.RateLimitDropPackets != nil {
		return *m.RateLimitDropPackets
	}
	return 0
}

func (m *LogicalInterfaceQueueStats) GetRateLimitDropBytes() uint64 {
	if m != nil && m.RateLimitDropBytes != nil {
		return *m.RateLimitDropBytes
	}
	return 0
}

func (m *LogicalInterfaceQueueStats) GetRedDropPackets() uint64 {
	if m != nil && m.RedDropPackets != nil {
		return *m.RedDropPackets
	}
	return 0
}

func (m *LogicalInterfaceQueueStats) GetRedDropBytes() uint64 {
	if m != nil && m.RedDropBytes != nil {
		return *m.RedDropBytes
	}
	return 0
}

func (m *LogicalInterfaceQueueStats) GetAverageBufferOccupancy() uint64 {
	if m != nil && m.AverageBufferOccupancy != nil {
		return *m.AverageBufferOccupancy
	}
	return 0
}

func (m *LogicalInterfaceQueueStats) GetCurrentBufferOccupancy() uint64 {
	if m != nil && m.CurrentBufferOccupancy != nil {
		return *m.CurrentBufferOccupancy
	}
	return 0
}

func (m *LogicalInterfaceQueueStats) GetPeakBufferOccupancy() uint64 {
	if m != nil && m.PeakBufferOccupancy != nil {
		return *m.PeakBufferOccupancy
	}
	return 0
}

func (m *LogicalInterfaceQueueStats) GetAllocatedBufferSize() uint64 {
	if m != nil && m.AllocatedBufferSize != nil {
		return *m.AllocatedBufferSize
	}
	return 0
}

var E_JnprLogicalInterfaceExt = &proto.ExtensionDesc{
	ExtendedType:  (*JuniperNetworksSensors)(nil),
	ExtensionType: (*LogicalPort)(nil),
	Field:         7,
	Name:          "jnprLogicalInterfaceExt",
	Tag:           "bytes,7,opt,name=jnprLogicalInterfaceExt",
	Filename:      "logical_port.proto",
}

func init() {
	proto.RegisterType((*LogicalPort)(nil), "LogicalPort")
	proto.RegisterType((*LogicalInterfaceInfo)(nil), "LogicalInterfaceInfo")
	proto.RegisterType((*IngressInterfaceStats)(nil), "IngressInterfaceStats")
	proto.RegisterType((*EgressInterfaceStats)(nil), "EgressInterfaceStats")
	proto.RegisterType((*OperationalState)(nil), "OperationalState")
	proto.RegisterType((*ForwardingClassAccounting)(nil), "ForwardingClassAccounting")
	proto.RegisterType((*FamilyAccounting)(nil), "FamilyAccounting")
	proto.RegisterType((*LogicalInterfaceQueueStats)(nil), "logicalInterfaceQueueStats")
	proto.RegisterExtension(E_JnprLogicalInterfaceExt)
}

func init() { proto.RegisterFile("logical_port.proto", fileDescriptor_ed53654dcd9b9a05) }

var fileDescriptor_ed53654dcd9b9a05 = []byte{
	// 1046 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x56, 0x5d, 0x73, 0xdb, 0x44,
	0x14, 0x1d, 0xb9, 0x75, 0xe2, 0x5c, 0xdb, 0x89, 0xa3, 0xc6, 0x89, 0x48, 0x87, 0xd4, 0xe3, 0x61,
	0x06, 0x33, 0x25, 0xf6, 0xd0, 0x19, 0x3a, 0xa5, 0x74, 0x06, 0x92, 0x92, 0x30, 0x86, 0x92, 0x14,
	0x07, 0x78, 0xe0, 0x65, 0xd9, 0xc8, 0x77, 0xed, 0x4d, 0xa4, 0x5d, 0xb1, 0x5a, 0xa5, 0x4d, 0x1f,
	0x19, 0xf8, 0x39, 0xbc, 0xf1, 0x0b, 0x78, 0xe2, 0x91, 0x9f, 0xc0, 0xe4, 0x8f, 0xc0, 0xec, 0x4a,
	0x72, 0x25, 0xc7, 0xe1, 0xe3, 0x91, 0x37, 0xfb, 0xdc, 0x73, 0xce, 0xee, 0x3d, 0x7b, 0xb5, 0x12,
	0xb8, 0x81, 0x9c, 0x70, 0x9f, 0x06, 0x24, 0x92, 0x4a, 0xf7, 0x23, 0x25, 0xb5, 0xdc, 0xbe, 0xa3,
	0x31, 0xc0, 0x10, 0xb5, 0xba, 0x24, 0x5a, 0x46, 0x29, 0xd8, 0xfd, 0x1c, 0xea, 0xcf, 0x52, 0xea,
	0x73, 0xa9, 0xb4, 0xfb, 0x04, 0x56, 0xb9, 0xd0, 0xa8, 0x18, 0xf5, 0x91, 0x70, 0xc1, 0xa4, 0xe7,
	0x74, 0x6e, 0xf5, 0xea, 0x0f, 0xda, 0xfd, 0x8c, 0x35, 0xcc, 0xab, 0x43, 0xc1, 0xe4, 0xa8, 0xc9,
	0x8b, 0x7f, 0xbb, 0x3f, 0x56, 0x61, 0x63, 0x11, 0xcf, 0xdd, 0x81, 0x65, 0xce, 0x88, 0xa0, 0x21,
	0x7a, 0x4e, 0xa7, 0xd2, 0x5b, 0xd9, 0xaf, 0xfe, 0xf0, 0x71, 0xa5, 0xe6, 0x8c, 0x96, 0x38, 0x3b,
	0xa2, 0x21, 0xba, 0x5d, 0x58, 0xe1, 0x82, 0x6b, 0xa2, 0x79, 0x88, 0x5e, 0xa5, 0x53, 0xe9, 0xdd,
	0xb6, 0x8c, 0x96, 0x33, 0xaa, 0x19, 0xfc, 0x2b, 0x1e, 0xa2, 0xfb, 0x0e, 0x34, 0x63, 0x11, 0x46,
	0x84, 0x33, 0xc2, 0xc5, 0x18, 0x5f, 0x7a, 0xb7, 0x3a, 0x4e, 0xaf, 0x99, 0x3b, 0xd5, 0x4d, 0x6d,
	0xc8, 0x86, 0xa6, 0xe2, 0xde, 0x87, 0xd5, 0x88, 0x2a, 0x14, 0x9a, 0x50, 0x4c, 0x57, 0xbd, 0xdd,
	0x71, 0x5e, 0xaf, 0xda, 0x48, 0x8b, 0x7b, 0x68, 0xd7, 0xfe, 0x10, 0x9a, 0x5c, 0x4c, 0x14, 0xc6,
	0x31, 0x89, 0x35, 0xd5, 0xb1, 0x57, 0xed, 0x38, 0xbd, 0xfa, 0x83, 0xcd, 0xfe, 0x30, 0x45, 0x67,
	0x9d, 0x9c, 0x98, 0xea, 0xa8, 0x91, 0x91, 0xed, 0x3f, 0xf7, 0x11, 0x34, 0xb0, 0xa8, 0x5d, 0xb2,
	0xda, 0x76, 0xff, 0x60, 0x91, 0xb4, 0x8e, 0x05, 0xe5, 0xbb, 0x50, 0x93, 0x91, 0x55, 0xa1, 0xb7,
	0x6c, 0x55, 0xeb, 0xfd, 0xe3, 0x08, 0x15, 0xd5, 0x5c, 0x0a, 0x1a, 0x18, 0x12, 0x8e, 0x96, 0x65,
	0x64, 0x7f, 0xb8, 0xef, 0xc3, 0x26, 0x1d, 0x87, 0x5c, 0xf0, 0x58, 0x2b, 0xea, 0x6b, 0x7e, 0x81,
	0x56, 0x9a, 0xc4, 0x5e, 0xcd, 0x74, 0x36, 0x6a, 0xcf, 0x55, 0x4f, 0x6c, 0xd1, 0xed, 0x40, 0x7d,
	0x8c, 0xb1, 0xaf, 0x78, 0x64, 0x5c, 0xbd, 0x15, 0xcb, 0x2d, 0x42, 0xee, 0x3d, 0xa8, 0x07, 0x34,
	0xd6, 0xc4, 0x9f, 0x52, 0x31, 0x41, 0x0f, 0x4c, 0xa6, 0x23, 0x30, 0xd0, 0x53, 0x8b, 0xb8, 0x6f,
	0x02, 0x4c, 0xf9, 0x64, 0x4a, 0xe2, 0x08, 0x71, 0xec, 0xd5, 0x6d, 0x7d, 0xc5, 0x20, 0x27, 0x06,
	0x70, 0x87, 0xe0, 0xe6, 0xe9, 0x7d, 0x9f, 0x60, 0x92, 0x0d, 0x4d, 0xc3, 0x0e, 0xcd, 0xdd, 0x7e,
	0x30, 0x37, 0x0c, 0x5f, 0x1a, 0x4a, 0x1a, 0x46, 0x2b, 0x93, 0x59, 0xc8, 0x0e, 0xc9, 0xa7, 0xb0,
	0x8e, 0xd7, 0x9c, 0x9a, 0xff, 0xec, 0xb4, 0x86, 0x65, 0xa3, 0xee, 0x9f, 0x0e, 0xb4, 0x17, 0x1e,
	0x9e, 0xfb, 0x16, 0x00, 0x67, 0x24, 0xa2, 0xfe, 0x39, 0xea, 0xd8, 0x8e, 0x62, 0x3a, 0x68, 0x9e,
	0x33, 0x5a, 0xe1, 0xec, 0x79, 0x8a, 0xdb, 0x69, 0x64, 0x44, 0xfa, 0xda, 0x90, 0x2a, 0x45, 0x52,
	0x8d, 0xb3, 0x63, 0x0b, 0xbb, 0x03, 0x68, 0x71, 0x46, 0x12, 0xdf, 0x64, 0x97, 0xfb, 0x99, 0x81,
	0x9c, 0x51, 0x57, 0x39, 0xfb, 0xda, 0x54, 0x73, 0xd3, 0x54, 0x10, 0x96, 0x04, 0xb7, 0xe7, 0x04,
	0x5f, 0x14, 0x05, 0x8f, 0xa1, 0xce, 0x19, 0x61, 0xfe, 0x6c, 0x2a, 0x4d, 0x10, 0xdb, 0xfd, 0x43,
	0xa9, 0x5e, 0x50, 0x35, 0xe6, 0x62, 0xf2, 0x34, 0xa0, 0x71, 0xbc, 0xe7, 0xfb, 0x32, 0x11, 0x9a,
	0x8b, 0x89, 0xe9, 0xe0, 0xd0, 0xb7, 0x7d, 0x76, 0x7f, 0x75, 0x60, 0xe3, 0xe0, 0x7f, 0x1e, 0x40,
	0x77, 0x0f, 0x5a, 0xf3, 0x0f, 0x84, 0xbb, 0x0b, 0xae, 0x7c, 0x8d, 0xe5, 0xcf, 0x80, 0x63, 0xe7,
	0x7a, 0x5d, 0x96, 0xd9, 0x49, 0xdc, 0xfd, 0xd9, 0x81, 0x37, 0x6e, 0x0c, 0x2c, 0x6b, 0x93, 0xd1,
	0x90, 0x07, 0x97, 0xa9, 0x47, 0x7e, 0x43, 0xd4, 0x38, 0x3b, 0xb4, 0xb0, 0xe1, 0x30, 0x9f, 0x88,
	0x24, 0x3c, 0x45, 0xe5, 0x55, 0x8a, 0x37, 0x4e, 0x8d, 0xf9, 0x47, 0x16, 0x9e, 0x0b, 0xb5, 0x14,
	0xc2, 0x4d, 0xa1, 0x96, 0x1a, 0x9f, 0x85, 0xda, 0xfd, 0xa5, 0x02, 0xad, 0x74, 0xe1, 0xff, 0xb8,
	0xcd, 0xf2, 0x16, 0x2a, 0xff, 0x66, 0x0b, 0xb7, 0x16, 0x6e, 0xc1, 0x5c, 0xb3, 0x9c, 0x91, 0x8b,
	0x87, 0x8b, 0xcf, 0xa8, 0xce, 0xd9, 0x37, 0x0f, 0x73, 0xbb, 0xb7, 0xa1, 0x91, 0x52, 0x33, 0xc7,
	0x6a, 0x91, 0x09, 0x86, 0x59, 0x9a, 0x95, 0xf2, 0xd1, 0x2f, 0xfd, 0xdd, 0xec, 0xef, 0xc2, 0xda,
	0x4c, 0x90, 0x99, 0x2f, 0x17, 0xf9, 0xcd, 0x8c, 0x9f, 0xc5, 0xf6, 0x53, 0x15, 0xb6, 0x6f, 0xbe,
	0x20, 0xdc, 0x1e, 0x34, 0xd2, 0x1b, 0x25, 0x3b, 0x46, 0xa7, 0xf4, 0xe2, 0xb0, 0xa5, 0xec, 0x24,
	0xef, 0xc1, 0xf2, 0xc2, 0x0c, 0x73, 0xd4, 0xbd, 0x0b, 0xd5, 0xd3, 0x4b, 0x8d, 0x73, 0xe9, 0xa5,
	0x98, 0xfb, 0x1e, 0xac, 0x6b, 0xca, 0x03, 0x32, 0x56, 0x32, 0x5a, 0x1c, 0xdf, 0x9a, 0xa9, 0x7f,
	0xa2, 0x64, 0x94, 0x37, 0xfa, 0x04, 0xb6, 0x14, 0xd5, 0x48, 0x02, 0x1e, 0x72, 0x5d, 0x16, 0x96,
	0xd2, 0xdc, 0x30, 0xac, 0x67, 0x86, 0x54, 0x54, 0x3f, 0x82, 0xf6, 0xbc, 0x3a, 0xdd, 0x5d, 0x29,
	0x5c, 0xb7, 0xa4, 0xdd, 0xb7, 0x5b, 0x1d, 0x40, 0x4b, 0xe1, 0xb8, 0xbc, 0x60, 0x29, 0xe1, 0x55,
	0x85, 0xe3, 0xe2, 0x52, 0xf7, 0x61, 0x75, 0x26, 0x48, 0xd7, 0xa8, 0x15, 0xe9, 0x8d, 0x8c, 0x9e,
	0xba, 0x7f, 0x04, 0x1e, 0xbd, 0x40, 0x45, 0x27, 0x48, 0x4e, 0x13, 0xc6, 0x50, 0x11, 0xe9, 0xfb,
	0x49, 0x44, 0x85, 0x7f, 0x69, 0xdf, 0x41, 0xa9, 0xac, 0xe3, 0x8c, 0x36, 0x33, 0xda, 0xbe, 0x65,
	0x1d, 0xe7, 0x24, 0x63, 0xe0, 0x27, 0xca, 0xbe, 0xc1, 0xaf, 0x19, 0x40, 0xc9, 0x20, 0xa3, 0xcd,
	0x1b, 0x7c, 0x00, 0xed, 0x08, 0xe9, 0xf9, 0x75, 0x75, 0xbd, 0xa8, 0xbe, 0x63, 0x38, 0x0b, 0xa4,
	0x34, 0x08, 0xa4, 0x4f, 0x35, 0x8e, 0x73, 0x7d, 0xcc, 0x5f, 0xa1, 0xd7, 0x28, 0x49, 0x67, 0x9c,
	0x54, 0x7f, 0xc2, 0x5f, 0xe1, 0x63, 0x02, 0x5b, 0x67, 0x22, 0x52, 0xf3, 0x9f, 0x40, 0x07, 0x2f,
	0xb5, 0xbb, 0xd5, 0xff, 0x2c, 0x11, 0x3c, 0x42, 0x75, 0x84, 0xfa, 0x85, 0x54, 0xe7, 0xf1, 0x09,
	0x8a, 0x58, 0xaa, 0x38, 0x7b, 0xf7, 0x37, 0xfa, 0x85, 0xaf, 0xb0, 0xd1, 0x4d, 0x2e, 0xfb, 0xdf,
	0xfd, 0x76, 0xb5, 0xe3, 0xfc, 0x7e, 0xb5, 0xe3, 0xfc, 0x71, 0xb5, 0xe3, 0x7c, 0x3b, 0x9a, 0x70,
	0xdd, 0x3f, 0x4b, 0x6d, 0xfb, 0x02, 0xf5, 0x80, 0xfb, 0x78, 0x8a, 0x6a, 0x32, 0x98, 0x22, 0x0d,
	0xf4, 0xf4, 0x54, 0xea, 0x5d, 0x2e, 0x26, 0x18, 0xeb, 0xdd, 0x33, 0xcd, 0x77, 0x05, 0x35, 0x1f,
	0x06, 0x83, 0xe8, 0x7c, 0x32, 0x38, 0xd3, 0x7c, 0x40, 0xc7, 0x34, 0xd2, 0xa8, 0xe2, 0x01, 0x39,
	0x4b, 0x84, 0x8c, 0x07, 0xb1, 0x3f, 0xc5, 0x90, 0xfe, 0x15, 0x00, 0x00, 0xff, 0xff, 0x38, 0x55,
	0xa2, 0x25, 0x39, 0x0a, 0x00, 0x00,
}

func (m *LogicalPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogicalPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogicalPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InterfaceInfo) > 0 {
		for iNdEx := len(m.InterfaceInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InterfaceInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLogicalPort(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LogicalInterfaceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogicalInterfaceInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogicalInterfaceInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EgressQueueInfo) > 0 {
		for iNdEx := len(m.EgressQueueInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EgressQueueInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLogicalPort(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.IngressQueueInfo) > 0 {
		for iNdEx := len(m.IngressQueueInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IngressQueueInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLogicalPort(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.HighSpeed != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.HighSpeed))
		i--
		dAtA[i] = 0x58
	}
	if m.LastChange != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.LastChange))
		i--
		dAtA[i] = 0x50
	}
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintLogicalPort(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x4a
	}
	if m.AdministractiveStatus != nil {
		i -= len(*m.AdministractiveStatus)
		copy(dAtA[i:], *m.AdministractiveStatus)
		i = encodeVarintLogicalPort(dAtA, i, uint64(len(*m.AdministractiveStatus)))
		i--
		dAtA[i] = 0x42
	}
	if m.OpState != nil {
		{
			size, err := m.OpState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLogicalPort(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.EgressStats != nil {
		{
			size, err := m.EgressStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLogicalPort(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.IngressStats != nil {
		{
			size, err := m.IngressStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLogicalPort(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ParentAeName != nil {
		i -= len(*m.ParentAeName)
		copy(dAtA[i:], *m.ParentAeName)
		i = encodeVarintLogicalPort(dAtA, i, uint64(len(*m.ParentAeName)))
		i--
		dAtA[i] = 0x22
	}
	if m.SnmpIfIndex != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.SnmpIfIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.InitTime == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("init_time")
	} else {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.InitTime))
		i--
		dAtA[i] = 0x10
	}
	if m.IfName == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("if_name")
	} else {
		i -= len(*m.IfName)
		copy(dAtA[i:], *m.IfName)
		i = encodeVarintLogicalPort(dAtA, i, uint64(len(*m.IfName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IngressInterfaceStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngressInterfaceStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngressInterfaceStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IfFcStats) > 0 {
		for iNdEx := len(m.IfFcStats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IfFcStats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLogicalPort(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.IfMcastPackets != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.IfMcastPackets))
		i--
		dAtA[i] = 0x20
	}
	if m.IfUcastPackets != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.IfUcastPackets))
		i--
		dAtA[i] = 0x18
	}
	if m.IfOctets == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("if_octets")
	} else {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.IfOctets))
		i--
		dAtA[i] = 0x10
	}
	if m.IfPackets == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("if_packets")
	} else {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.IfPackets))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EgressInterfaceStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EgressInterfaceStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EgressInterfaceStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IfMcastPackets != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.IfMcastPackets))
		i--
		dAtA[i] = 0x20
	}
	if m.IfUcastPackets != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.IfUcastPackets))
		i--
		dAtA[i] = 0x18
	}
	if m.IfOctets == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("if_octets")
	} else {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.IfOctets))
		i--
		dAtA[i] = 0x10
	}
	if m.IfPackets == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("if_packets")
	} else {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.IfPackets))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OperationalState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperationalState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperationalState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OperationalStatus != nil {
		i -= len(*m.OperationalStatus)
		copy(dAtA[i:], *m.OperationalStatus)
		i = encodeVarintLogicalPort(dAtA, i, uint64(len(*m.OperationalStatus)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ForwardingClassAccounting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForwardingClassAccounting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForwardingClassAccounting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IfOctets != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.IfOctets))
		i--
		dAtA[i] = 0x20
	}
	if m.IfPackets != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.IfPackets))
		i--
		dAtA[i] = 0x18
	}
	if m.FcNumber != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.FcNumber))
		i--
		dAtA[i] = 0x10
	}
	if m.IfFamily != nil {
		i -= len(*m.IfFamily)
		copy(dAtA[i:], *m.IfFamily)
		i = encodeVarintLogicalPort(dAtA, i, uint64(len(*m.IfFamily)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FamilyAccounting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FamilyAccounting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FamilyAccounting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IfMcastOctets != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.IfMcastOctets))
		i--
		dAtA[i] = 0x38
	}
	if m.IfMcastPackets != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.IfMcastPackets))
		i--
		dAtA[i] = 0x30
	}
	if m.IfV6Octets != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.IfV6Octets))
		i--
		dAtA[i] = 0x28
	}
	if m.IfV6Packets != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.IfV6Packets))
		i--
		dAtA[i] = 0x20
	}
	if m.IfOctets != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.IfOctets))
		i--
		dAtA[i] = 0x18
	}
	if m.IfPackets != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.IfPackets))
		i--
		dAtA[i] = 0x10
	}
	if m.IfFamily != nil {
		i -= len(*m.IfFamily)
		copy(dAtA[i:], *m.IfFamily)
		i = encodeVarintLogicalPort(dAtA, i, uint64(len(*m.IfFamily)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogicalInterfaceQueueStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogicalInterfaceQueueStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogicalInterfaceQueueStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AllocatedBufferSize != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.AllocatedBufferSize))
		i--
		dAtA[i] = 0x60
	}
	if m.PeakBufferOccupancy != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.PeakBufferOccupancy))
		i--
		dAtA[i] = 0x58
	}
	if m.CurrentBufferOccupancy != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.CurrentBufferOccupancy))
		i--
		dAtA[i] = 0x50
	}
	if m.AverageBufferOccupancy != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.AverageBufferOccupancy))
		i--
		dAtA[i] = 0x48
	}
	if m.RedDropBytes != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.RedDropBytes))
		i--
		dAtA[i] = 0x40
	}
	if m.RedDropPackets != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.RedDropPackets))
		i--
		dAtA[i] = 0x38
	}
	if m.RateLimitDropBytes != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.RateLimitDropBytes))
		i--
		dAtA[i] = 0x30
	}
	if m.RateLimitDropPackets != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.RateLimitDropPackets))
		i--
		dAtA[i] = 0x28
	}
	if m.TailDropPackets != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.TailDropPackets))
		i--
		dAtA[i] = 0x20
	}
	if m.Bytes != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.Bytes))
		i--
		dAtA[i] = 0x18
	}
	if m.Packets != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.Packets))
		i--
		dAtA[i] = 0x10
	}
	if m.QueueNumber != nil {
		i = encodeVarintLogicalPort(dAtA, i, uint64(*m.QueueNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintLogicalPort(dAtA []byte, offset int, v uint64) int {
	offset -= sovLogicalPort(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LogicalPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InterfaceInfo) > 0 {
		for _, e := range m.InterfaceInfo {
			l = e.Size()
			n += 1 + l + sovLogicalPort(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LogicalInterfaceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfName != nil {
		l = len(*m.IfName)
		n += 1 + l + sovLogicalPort(uint64(l))
	}
	if m.InitTime != nil {
		n += 1 + sovLogicalPort(uint64(*m.InitTime))
	}
	if m.SnmpIfIndex != nil {
		n += 1 + sovLogicalPort(uint64(*m.SnmpIfIndex))
	}
	if m.ParentAeName != nil {
		l = len(*m.ParentAeName)
		n += 1 + l + sovLogicalPort(uint64(l))
	}
	if m.IngressStats != nil {
		l = m.IngressStats.Size()
		n += 1 + l + sovLogicalPort(uint64(l))
	}
	if m.EgressStats != nil {
		l = m.EgressStats.Size()
		n += 1 + l + sovLogicalPort(uint64(l))
	}
	if m.OpState != nil {
		l = m.OpState.Size()
		n += 1 + l + sovLogicalPort(uint64(l))
	}
	if m.AdministractiveStatus != nil {
		l = len(*m.AdministractiveStatus)
		n += 1 + l + sovLogicalPort(uint64(l))
	}
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovLogicalPort(uint64(l))
	}
	if m.LastChange != nil {
		n += 1 + sovLogicalPort(uint64(*m.LastChange))
	}
	if m.HighSpeed != nil {
		n += 1 + sovLogicalPort(uint64(*m.HighSpeed))
	}
	if len(m.IngressQueueInfo) > 0 {
		for _, e := range m.IngressQueueInfo {
			l = e.Size()
			n += 1 + l + sovLogicalPort(uint64(l))
		}
	}
	if len(m.EgressQueueInfo) > 0 {
		for _, e := range m.EgressQueueInfo {
			l = e.Size()
			n += 1 + l + sovLogicalPort(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngressInterfaceStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfPackets != nil {
		n += 1 + sovLogicalPort(uint64(*m.IfPackets))
	}
	if m.IfOctets != nil {
		n += 1 + sovLogicalPort(uint64(*m.IfOctets))
	}
	if m.IfUcastPackets != nil {
		n += 1 + sovLogicalPort(uint64(*m.IfUcastPackets))
	}
	if m.IfMcastPackets != nil {
		n += 1 + sovLogicalPort(uint64(*m.IfMcastPackets))
	}
	if len(m.IfFcStats) > 0 {
		for _, e := range m.IfFcStats {
			l = e.Size()
			n += 1 + l + sovLogicalPort(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EgressInterfaceStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfPackets != nil {
		n += 1 + sovLogicalPort(uint64(*m.IfPackets))
	}
	if m.IfOctets != nil {
		n += 1 + sovLogicalPort(uint64(*m.IfOctets))
	}
	if m.IfUcastPackets != nil {
		n += 1 + sovLogicalPort(uint64(*m.IfUcastPackets))
	}
	if m.IfMcastPackets != nil {
		n += 1 + sovLogicalPort(uint64(*m.IfMcastPackets))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OperationalState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperationalStatus != nil {
		l = len(*m.OperationalStatus)
		n += 1 + l + sovLogicalPort(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ForwardingClassAccounting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfFamily != nil {
		l = len(*m.IfFamily)
		n += 1 + l + sovLogicalPort(uint64(l))
	}
	if m.FcNumber != nil {
		n += 1 + sovLogicalPort(uint64(*m.FcNumber))
	}
	if m.IfPackets != nil {
		n += 1 + sovLogicalPort(uint64(*m.IfPackets))
	}
	if m.IfOctets != nil {
		n += 1 + sovLogicalPort(uint64(*m.IfOctets))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FamilyAccounting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfFamily != nil {
		l = len(*m.IfFamily)
		n += 1 + l + sovLogicalPort(uint64(l))
	}
	if m.IfPackets != nil {
		n += 1 + sovLogicalPort(uint64(*m.IfPackets))
	}
	if m.IfOctets != nil {
		n += 1 + sovLogicalPort(uint64(*m.IfOctets))
	}
	if m.IfV6Packets != nil {
		n += 1 + sovLogicalPort(uint64(*m.IfV6Packets))
	}
	if m.IfV6Octets != nil {
		n += 1 + sovLogicalPort(uint64(*m.IfV6Octets))
	}
	if m.IfMcastPackets != nil {
		n += 1 + sovLogicalPort(uint64(*m.IfMcastPackets))
	}
	if m.IfMcastOctets != nil {
		n += 1 + sovLogicalPort(uint64(*m.IfMcastOctets))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LogicalInterfaceQueueStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueueNumber != nil {
		n += 1 + sovLogicalPort(uint64(*m.QueueNumber))
	}
	if m.Packets != nil {
		n += 1 + sovLogicalPort(uint64(*m.Packets))
	}
	if m.Bytes != nil {
		n += 1 + sovLogicalPort(uint64(*m.Bytes))
	}
	if m.TailDropPackets != nil {
		n += 1 + sovLogicalPort(uint64(*m.TailDropPackets))
	}
	if m.RateLimitDropPackets != nil {
		n += 1 + sovLogicalPort(uint64(*m.RateLimitDropPackets))
	}
	if m.RateLimitDropBytes != nil {
		n += 1 + sovLogicalPort(uint64(*m.RateLimitDropBytes))
	}
	if m.RedDropPackets != nil {
		n += 1 + sovLogicalPort(uint64(*m.RedDropPackets))
	}
	if m.RedDropBytes != nil {
		n += 1 + sovLogicalPort(uint64(*m.RedDropBytes))
	}
	if m.AverageBufferOccupancy != nil {
		n += 1 + sovLogicalPort(uint64(*m.AverageBufferOccupancy))
	}
	if m.CurrentBufferOccupancy != nil {
		n += 1 + sovLogicalPort(uint64(*m.CurrentBufferOccupancy))
	}
	if m.PeakBufferOccupancy != nil {
		n += 1 + sovLogicalPort(uint64(*m.PeakBufferOccupancy))
	}
	if m.AllocatedBufferSize != nil {
		n += 1 + sovLogicalPort(uint64(*m.AllocatedBufferSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovLogicalPort(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLogicalPort(x uint64) (n int) {
	return sovLogicalPort(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LogicalPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogicalPort
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogicalPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogicalPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogicalPort
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceInfo = append(m.InterfaceInfo, &LogicalInterfaceInfo{})
			if err := m.InterfaceInfo[len(m.InterfaceInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogicalPort(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogicalInterfaceInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogicalPort
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogicalInterfaceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogicalInterfaceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogicalPort
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IfName = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InitTime = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnmpIfIndex", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SnmpIfIndex = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentAeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogicalPort
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ParentAeName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogicalPort
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IngressStats == nil {
				m.IngressStats = &IngressInterfaceStats{}
			}
			if err := m.IngressStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogicalPort
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EgressStats == nil {
				m.EgressStats = &EgressInterfaceStats{}
			}
			if err := m.EgressStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogicalPort
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpState == nil {
				m.OpState = &OperationalState{}
			}
			if err := m.OpState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdministractiveStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogicalPort
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AdministractiveStatus = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogicalPort
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastChange", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastChange = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighSpeed", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HighSpeed = &v
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressQueueInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogicalPort
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressQueueInfo = append(m.IngressQueueInfo, &LogicalInterfaceQueueStats{})
			if err := m.IngressQueueInfo[len(m.IngressQueueInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressQueueInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogicalPort
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressQueueInfo = append(m.EgressQueueInfo, &LogicalInterfaceQueueStats{})
			if err := m.EgressQueueInfo[len(m.EgressQueueInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogicalPort(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("if_name")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("init_time")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressInterfaceStats) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogicalPort
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressInterfaceStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressInterfaceStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfPackets = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfOctets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfOctets = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfUcastPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfUcastPackets = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfMcastPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfMcastPackets = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfFcStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogicalPort
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IfFcStats = append(m.IfFcStats, &ForwardingClassAccounting{})
			if err := m.IfFcStats[len(m.IfFcStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogicalPort(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("if_packets")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("if_octets")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EgressInterfaceStats) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogicalPort
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EgressInterfaceStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EgressInterfaceStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfPackets = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfOctets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfOctets = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfUcastPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfUcastPackets = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfMcastPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfMcastPackets = &v
		default:
			iNdEx = preIndex
			skippy, err := skipLogicalPort(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("if_packets")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("if_octets")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperationalState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogicalPort
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperationalState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperationalState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationalStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogicalPort
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OperationalStatus = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogicalPort(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForwardingClassAccounting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogicalPort
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForwardingClassAccounting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForwardingClassAccounting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfFamily", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogicalPort
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IfFamily = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FcNumber", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FcNumber = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfPackets = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfOctets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfOctets = &v
		default:
			iNdEx = preIndex
			skippy, err := skipLogicalPort(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FamilyAccounting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogicalPort
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FamilyAccounting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FamilyAccounting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfFamily", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogicalPort
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IfFamily = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfPackets = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfOctets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfOctets = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfV6Packets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfV6Packets = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfV6Octets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfV6Octets = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfMcastPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfMcastPackets = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfMcastOctets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfMcastOctets = &v
		default:
			iNdEx = preIndex
			skippy, err := skipLogicalPort(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogicalInterfaceQueueStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogicalPort
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: logicalInterfaceQueueStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: logicalInterfaceQueueStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueNumber", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueueNumber = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Packets = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bytes = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TailDropPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TailDropPackets = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimitDropPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RateLimitDropPackets = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimitDropBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RateLimitDropBytes = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedDropPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RedDropPackets = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedDropBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RedDropBytes = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AverageBufferOccupancy", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AverageBufferOccupancy = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentBufferOccupancy", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CurrentBufferOccupancy = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeakBufferOccupancy", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PeakBufferOccupancy = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatedBufferSize", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllocatedBufferSize = &v
		default:
			iNdEx = preIndex
			skippy, err := skipLogicalPort(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogicalPort
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLogicalPort(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLogicalPort
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLogicalPort
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLogicalPort
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupLogicalPort
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthLogicalPort
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthLogicalPort        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLogicalPort          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupLogicalPort = fmt.Errorf("proto: unexpected end of group")
)
