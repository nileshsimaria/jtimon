// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mib2d_oc.proto

package schema

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type InterfacesMib struct {
	Interface            []*InterfacesMibInterfaceList `protobuf:"bytes,151,rep,name=interface" json:"interface,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *InterfacesMib) Reset()         { *m = InterfacesMib{} }
func (m *InterfacesMib) String() string { return proto.CompactTextString(m) }
func (*InterfacesMib) ProtoMessage()    {}
func (*InterfacesMib) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0}
}
func (m *InterfacesMib) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMib) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMib.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMib) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMib.Merge(m, src)
}
func (m *InterfacesMib) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMib) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMib.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMib proto.InternalMessageInfo

func (m *InterfacesMib) GetInterface() []*InterfacesMibInterfaceList {
	if m != nil {
		return m.Interface
	}
	return nil
}

type InterfacesMibInterfaceList struct {
	Name                 *string                                      `protobuf:"bytes,51,opt,name=name" json:"name,omitempty"`
	State                *InterfacesMibInterfaceListStateType         `protobuf:"bytes,151,opt,name=state" json:"state,omitempty"`
	Subinterfaces        *InterfacesMibInterfaceListSubinterfacesType `protobuf:"bytes,152,opt,name=subinterfaces" json:"subinterfaces,omitempty"`
	HoldTime             *InterfacesMibInterfaceListHoldTimeType      `protobuf:"bytes,155,opt,name=hold_time,json=holdTime" json:"hold_time,omitempty"`
	Ethernet             *InterfacesMibInterfaceListEthernetType      `protobuf:"bytes,153,opt,name=ethernet" json:"ethernet,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                     `json:"-"`
	XXX_unrecognized     []byte                                       `json:"-"`
	XXX_sizecache        int32                                        `json:"-"`
}

func (m *InterfacesMibInterfaceList) Reset()         { *m = InterfacesMibInterfaceList{} }
func (m *InterfacesMibInterfaceList) String() string { return proto.CompactTextString(m) }
func (*InterfacesMibInterfaceList) ProtoMessage()    {}
func (*InterfacesMibInterfaceList) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0}
}
func (m *InterfacesMibInterfaceList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceList.Merge(m, src)
}
func (m *InterfacesMibInterfaceList) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceList) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceList.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceList proto.InternalMessageInfo

func (m *InterfacesMibInterfaceList) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *InterfacesMibInterfaceList) GetState() *InterfacesMibInterfaceListStateType {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *InterfacesMibInterfaceList) GetSubinterfaces() *InterfacesMibInterfaceListSubinterfacesType {
	if m != nil {
		return m.Subinterfaces
	}
	return nil
}

func (m *InterfacesMibInterfaceList) GetHoldTime() *InterfacesMibInterfaceListHoldTimeType {
	if m != nil {
		return m.HoldTime
	}
	return nil
}

func (m *InterfacesMibInterfaceList) GetEthernet() *InterfacesMibInterfaceListEthernetType {
	if m != nil {
		return m.Ethernet
	}
	return nil
}

type InterfacesMibInterfaceListStateType struct {
	Name                 *string  `protobuf:"bytes,51,opt,name=name" json:"name,omitempty"`
	Type                 *string  `protobuf:"bytes,52,opt,name=type" json:"type,omitempty"`
	Mtu                  *uint32  `protobuf:"varint,53,opt,name=mtu" json:"mtu,omitempty"`
	LoopbackMode         *bool    `protobuf:"varint,56,opt,name=loopback_mode,json=loopbackMode" json:"loopback_mode,omitempty"`
	Description          *string  `protobuf:"bytes,54,opt,name=description" json:"description,omitempty"`
	Enabled              *bool    `protobuf:"varint,55,opt,name=enabled" json:"enabled,omitempty"`
	Ifindex              *uint32  `protobuf:"varint,61,opt,name=ifindex" json:"ifindex,omitempty"`
	AdminStatus          *string  `protobuf:"bytes,62,opt,name=admin_status,json=adminStatus" json:"admin_status,omitempty"`
	OperStatus           *string  `protobuf:"bytes,63,opt,name=oper_status,json=operStatus" json:"oper_status,omitempty"`
	LastChange           *uint64  `protobuf:"varint,64,opt,name=last_change,json=lastChange" json:"last_change,omitempty"`
	Logical              *bool    `protobuf:"varint,65,opt,name=logical" json:"logical,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InterfacesMibInterfaceListStateType) Reset()         { *m = InterfacesMibInterfaceListStateType{} }
func (m *InterfacesMibInterfaceListStateType) String() string { return proto.CompactTextString(m) }
func (*InterfacesMibInterfaceListStateType) ProtoMessage()    {}
func (*InterfacesMibInterfaceListStateType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 0}
}
func (m *InterfacesMibInterfaceListStateType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListStateType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListStateType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListStateType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListStateType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListStateType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListStateType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListStateType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListStateType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListStateType) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *InterfacesMibInterfaceListStateType) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *InterfacesMibInterfaceListStateType) GetMtu() uint32 {
	if m != nil && m.Mtu != nil {
		return *m.Mtu
	}
	return 0
}

func (m *InterfacesMibInterfaceListStateType) GetLoopbackMode() bool {
	if m != nil && m.LoopbackMode != nil {
		return *m.LoopbackMode
	}
	return false
}

func (m *InterfacesMibInterfaceListStateType) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *InterfacesMibInterfaceListStateType) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

func (m *InterfacesMibInterfaceListStateType) GetIfindex() uint32 {
	if m != nil && m.Ifindex != nil {
		return *m.Ifindex
	}
	return 0
}

func (m *InterfacesMibInterfaceListStateType) GetAdminStatus() string {
	if m != nil && m.AdminStatus != nil {
		return *m.AdminStatus
	}
	return ""
}

func (m *InterfacesMibInterfaceListStateType) GetOperStatus() string {
	if m != nil && m.OperStatus != nil {
		return *m.OperStatus
	}
	return ""
}

func (m *InterfacesMibInterfaceListStateType) GetLastChange() uint64 {
	if m != nil && m.LastChange != nil {
		return *m.LastChange
	}
	return 0
}

func (m *InterfacesMibInterfaceListStateType) GetLogical() bool {
	if m != nil && m.Logical != nil {
		return *m.Logical
	}
	return false
}

type InterfacesMibInterfaceListSubinterfacesType struct {
	Subinterface         []*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList `protobuf:"bytes,151,rep,name=subinterface" json:"subinterface,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                       `json:"-"`
	XXX_unrecognized     []byte                                                         `json:"-"`
	XXX_sizecache        int32                                                          `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesType) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesType{}
}
func (m *InterfacesMibInterfaceListSubinterfacesType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesType) ProtoMessage() {}
func (*InterfacesMibInterfaceListSubinterfacesType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1}
}
func (m *InterfacesMibInterfaceListSubinterfacesType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesType) GetSubinterface() []*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList {
	if m != nil {
		return m.Subinterface
	}
	return nil
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList struct {
	Index                *uint32                                                               `protobuf:"varint,51,opt,name=index" json:"index,omitempty"`
	State                *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType `protobuf:"bytes,151,opt,name=state" json:"state,omitempty"`
	Ipv4                 *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type  `protobuf:"bytes,152,opt,name=ipv4" json:"ipv4,omitempty"`
	Ipv6                 *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type  `protobuf:"bytes,153,opt,name=ipv6" json:"ipv6,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                              `json:"-"`
	XXX_unrecognized     []byte                                                                `json:"-"`
	XXX_sizecache        int32                                                                 `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList) ProtoMessage() {}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList) GetIndex() uint32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList) GetState() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList) GetIpv4() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type {
	if m != nil {
		return m.Ipv4
	}
	return nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList) GetIpv6() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type {
	if m != nil {
		return m.Ipv6
	}
	return nil
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType struct {
	Index                *uint32  `protobuf:"varint,51,opt,name=index" json:"index,omitempty"`
	Description          *string  `protobuf:"bytes,53,opt,name=description" json:"description,omitempty"`
	Enabled              *bool    `protobuf:"varint,54,opt,name=enabled" json:"enabled,omitempty"`
	Name                 *string  `protobuf:"bytes,52,opt,name=name" json:"name,omitempty"`
	Ifindex              *uint32  `protobuf:"varint,55,opt,name=ifindex" json:"ifindex,omitempty"`
	AdminStatus          *string  `protobuf:"bytes,56,opt,name=admin_status,json=adminStatus" json:"admin_status,omitempty"`
	OperStatus           *string  `protobuf:"bytes,57,opt,name=oper_status,json=operStatus" json:"oper_status,omitempty"`
	LastChange           *uint64  `protobuf:"varint,58,opt,name=last_change,json=lastChange" json:"last_change,omitempty"`
	Logical              *bool    `protobuf:"varint,65,opt,name=logical" json:"logical,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) ProtoMessage() {}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 0}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) GetIndex() uint32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) GetIfindex() uint32 {
	if m != nil && m.Ifindex != nil {
		return *m.Ifindex
	}
	return 0
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) GetAdminStatus() string {
	if m != nil && m.AdminStatus != nil {
		return *m.AdminStatus
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) GetOperStatus() string {
	if m != nil && m.OperStatus != nil {
		return *m.OperStatus
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) GetLastChange() uint64 {
	if m != nil && m.LastChange != nil {
		return *m.LastChange
	}
	return 0
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) GetLogical() bool {
	if m != nil && m.Logical != nil {
		return *m.Logical
	}
	return false
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type struct {
	Addresses            *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType  `protobuf:"bytes,151,opt,name=addresses" json:"addresses,omitempty"`
	Neighbors            *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType  `protobuf:"bytes,152,opt,name=neighbors" json:"neighbors,omitempty"`
	Unnumbered           *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType `protobuf:"bytes,153,opt,name=unnumbered" json:"unnumbered,omitempty"`
	State                *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType      `protobuf:"bytes,154,opt,name=state" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                           `json:"-"`
	XXX_unrecognized     []byte                                                                             `json:"-"`
	XXX_sizecache        int32                                                                              `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type) ProtoMessage() {}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 1}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type) GetAddresses() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type) GetNeighbors() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType {
	if m != nil {
		return m.Neighbors
	}
	return nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type) GetUnnumbered() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType {
	if m != nil {
		return m.Unnumbered
	}
	return nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type) GetState() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType {
	if m != nil {
		return m.State
	}
	return nil
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType struct {
	Address              []*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList `protobuf:"bytes,151,rep,name=address" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                                       `json:"-"`
	XXX_unrecognized     []byte                                                                                         `json:"-"`
	XXX_sizecache        int32                                                                                          `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType) ProtoMessage() {
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 1, 0}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType) GetAddress() []*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList {
	if m != nil {
		return m.Address
	}
	return nil
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList struct {
	Ip                   *string                                                                                               `protobuf:"bytes,51,opt,name=ip" json:"ip,omitempty"`
	State                *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType `protobuf:"bytes,151,opt,name=state" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                                              `json:"-"`
	XXX_unrecognized     []byte                                                                                                `json:"-"`
	XXX_sizecache        int32                                                                                                 `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList) ProtoMessage() {
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 1, 0, 0}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList) GetIp() string {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList) GetState() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType {
	if m != nil {
		return m.State
	}
	return nil
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType struct {
	Ip                   *string  `protobuf:"bytes,51,opt,name=ip" json:"ip,omitempty"`
	PrefixLength         *uint32  `protobuf:"varint,52,opt,name=prefix_length,json=prefixLength" json:"prefix_length,omitempty"`
	Origin               *string  `protobuf:"bytes,53,opt,name=origin" json:"origin,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType) ProtoMessage() {
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 1, 0, 0, 0}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType) GetIp() string {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType) GetPrefixLength() uint32 {
	if m != nil && m.PrefixLength != nil {
		return *m.PrefixLength
	}
	return 0
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType) GetOrigin() string {
	if m != nil && m.Origin != nil {
		return *m.Origin
	}
	return ""
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType struct {
	Neighbor             []*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList `protobuf:"bytes,151,rep,name=neighbor" json:"neighbor,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                                        `json:"-"`
	XXX_unrecognized     []byte                                                                                          `json:"-"`
	XXX_sizecache        int32                                                                                           `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType) ProtoMessage() {
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 1, 1}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType) GetNeighbor() []*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList {
	if m != nil {
		return m.Neighbor
	}
	return nil
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList struct {
	Ip                   *string                                                                                                `protobuf:"bytes,51,opt,name=ip" json:"ip,omitempty"`
	State                *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType `protobuf:"bytes,151,opt,name=state" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                                               `json:"-"`
	XXX_unrecognized     []byte                                                                                                 `json:"-"`
	XXX_sizecache        int32                                                                                                  `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList) ProtoMessage() {
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 1, 1, 0}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList) GetIp() string {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList) GetState() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType {
	if m != nil {
		return m.State
	}
	return nil
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType struct {
	Ip                   *string  `protobuf:"bytes,51,opt,name=ip" json:"ip,omitempty"`
	LinkLayerAddress     *string  `protobuf:"bytes,52,opt,name=link_layer_address,json=linkLayerAddress" json:"link_layer_address,omitempty"`
	Origin               *string  `protobuf:"bytes,53,opt,name=origin" json:"origin,omitempty"`
	HostName             *string  `protobuf:"bytes,54,opt,name=host_name,json=hostName" json:"host_name,omitempty"`
	TableId              *uint32  `protobuf:"varint,55,opt,name=table_id,json=tableId" json:"table_id,omitempty"`
	NeighborState        *string  `protobuf:"bytes,56,opt,name=neighbor_state,json=neighborState" json:"neighbor_state,omitempty"`
	Expiry               *uint32  `protobuf:"varint,57,opt,name=expiry" json:"expiry,omitempty"`
	IsPublish            *bool    `protobuf:"varint,58,opt,name=is_publish,json=isPublish" json:"is_publish,omitempty"`
	InterfaceName        *string  `protobuf:"bytes,59,opt,name=interface_name,json=interfaceName" json:"interface_name,omitempty"`
	LogicalRouterId      *uint32  `protobuf:"varint,60,opt,name=logical_router_id,json=logicalRouterId" json:"logical_router_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) ProtoMessage() {
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 1, 1, 0, 0}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) GetIp() string {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) GetLinkLayerAddress() string {
	if m != nil && m.LinkLayerAddress != nil {
		return *m.LinkLayerAddress
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) GetOrigin() string {
	if m != nil && m.Origin != nil {
		return *m.Origin
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) GetHostName() string {
	if m != nil && m.HostName != nil {
		return *m.HostName
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) GetTableId() uint32 {
	if m != nil && m.TableId != nil {
		return *m.TableId
	}
	return 0
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) GetNeighborState() string {
	if m != nil && m.NeighborState != nil {
		return *m.NeighborState
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) GetExpiry() uint32 {
	if m != nil && m.Expiry != nil {
		return *m.Expiry
	}
	return 0
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) GetIsPublish() bool {
	if m != nil && m.IsPublish != nil {
		return *m.IsPublish
	}
	return false
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) GetInterfaceName() string {
	if m != nil && m.InterfaceName != nil {
		return *m.InterfaceName
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) GetLogicalRouterId() uint32 {
	if m != nil && m.LogicalRouterId != nil {
		return *m.LogicalRouterId
	}
	return 0
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType struct {
	State                *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType        `protobuf:"bytes,151,opt,name=state" json:"state,omitempty"`
	InterfaceRef         *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType `protobuf:"bytes,152,opt,name=interface_ref,json=interfaceRef" json:"interface_ref,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                                           `json:"-"`
	XXX_unrecognized     []byte                                                                                             `json:"-"`
	XXX_sizecache        int32                                                                                              `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType) ProtoMessage() {
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 1, 2}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType) GetState() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType) GetInterfaceRef() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType {
	if m != nil {
		return m.InterfaceRef
	}
	return nil
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType struct {
	Enabled              *bool    `protobuf:"varint,51,opt,name=enabled" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType) ProtoMessage() {
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 1, 2, 0}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType struct {
	State                *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType `protobuf:"bytes,151,opt,name=state" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                                                    `json:"-"`
	XXX_unrecognized     []byte                                                                                                      `json:"-"`
	XXX_sizecache        int32                                                                                                       `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType) ProtoMessage() {
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 1, 2, 1}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType) GetState() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType {
	if m != nil {
		return m.State
	}
	return nil
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType struct {
	Interface            *string  `protobuf:"bytes,51,opt,name=interface" json:"interface,omitempty"`
	Subinterface         *uint32  `protobuf:"varint,52,opt,name=subinterface" json:"subinterface,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType) ProtoMessage() {
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 1, 2, 1, 0}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType) GetInterface() string {
	if m != nil && m.Interface != nil {
		return *m.Interface
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType) GetSubinterface() uint32 {
	if m != nil && m.Subinterface != nil {
		return *m.Subinterface
	}
	return 0
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType struct {
	Enabled              *bool    `protobuf:"varint,51,opt,name=enabled" json:"enabled,omitempty"`
	Mtu                  *uint32  `protobuf:"varint,52,opt,name=mtu" json:"mtu,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType) ProtoMessage() {}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 1, 3}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType) GetMtu() uint32 {
	if m != nil && m.Mtu != nil {
		return *m.Mtu
	}
	return 0
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type struct {
	Addresses            *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType  `protobuf:"bytes,151,opt,name=addresses" json:"addresses,omitempty"`
	Neighbors            *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType  `protobuf:"bytes,152,opt,name=neighbors" json:"neighbors,omitempty"`
	Unnumbered           *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType `protobuf:"bytes,153,opt,name=unnumbered" json:"unnumbered,omitempty"`
	State                *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType      `protobuf:"bytes,154,opt,name=state" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                           `json:"-"`
	XXX_unrecognized     []byte                                                                             `json:"-"`
	XXX_sizecache        int32                                                                              `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type) ProtoMessage() {}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 2}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type) GetAddresses() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type) GetNeighbors() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType {
	if m != nil {
		return m.Neighbors
	}
	return nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type) GetUnnumbered() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType {
	if m != nil {
		return m.Unnumbered
	}
	return nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type) GetState() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType {
	if m != nil {
		return m.State
	}
	return nil
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType struct {
	Address              []*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList `protobuf:"bytes,151,rep,name=address" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                                       `json:"-"`
	XXX_unrecognized     []byte                                                                                         `json:"-"`
	XXX_sizecache        int32                                                                                          `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType) ProtoMessage() {
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 2, 0}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType) GetAddress() []*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList {
	if m != nil {
		return m.Address
	}
	return nil
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList struct {
	Ip                   *string                                                                                               `protobuf:"bytes,51,opt,name=ip" json:"ip,omitempty"`
	State                *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType `protobuf:"bytes,151,opt,name=state" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                                              `json:"-"`
	XXX_unrecognized     []byte                                                                                                `json:"-"`
	XXX_sizecache        int32                                                                                                 `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList) ProtoMessage() {
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 2, 0, 0}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList) GetIp() string {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList) GetState() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType {
	if m != nil {
		return m.State
	}
	return nil
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType struct {
	Ip                   *string  `protobuf:"bytes,51,opt,name=ip" json:"ip,omitempty"`
	PrefixLength         *uint32  `protobuf:"varint,52,opt,name=prefix_length,json=prefixLength" json:"prefix_length,omitempty"`
	Origin               *string  `protobuf:"bytes,53,opt,name=origin" json:"origin,omitempty"`
	Status               *string  `protobuf:"bytes,54,opt,name=status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType) ProtoMessage() {
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 2, 0, 0, 0}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType) GetIp() string {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType) GetPrefixLength() uint32 {
	if m != nil && m.PrefixLength != nil {
		return *m.PrefixLength
	}
	return 0
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType) GetOrigin() string {
	if m != nil && m.Origin != nil {
		return *m.Origin
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType) GetStatus() string {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return ""
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType struct {
	Neighbor             []*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList `protobuf:"bytes,151,rep,name=neighbor" json:"neighbor,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                                        `json:"-"`
	XXX_unrecognized     []byte                                                                                          `json:"-"`
	XXX_sizecache        int32                                                                                           `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType) ProtoMessage() {
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 2, 1}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType) GetNeighbor() []*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList {
	if m != nil {
		return m.Neighbor
	}
	return nil
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList struct {
	Ip                   *string                                                                                                `protobuf:"bytes,51,opt,name=ip" json:"ip,omitempty"`
	State                *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType `protobuf:"bytes,151,opt,name=state" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                                               `json:"-"`
	XXX_unrecognized     []byte                                                                                                 `json:"-"`
	XXX_sizecache        int32                                                                                                  `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList) ProtoMessage() {
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 2, 1, 0}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList) GetIp() string {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList) GetState() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType {
	if m != nil {
		return m.State
	}
	return nil
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType struct {
	Ip                   *string  `protobuf:"bytes,51,opt,name=ip" json:"ip,omitempty"`
	LinkLayerAddress     *string  `protobuf:"bytes,52,opt,name=link_layer_address,json=linkLayerAddress" json:"link_layer_address,omitempty"`
	Origin               *string  `protobuf:"bytes,53,opt,name=origin" json:"origin,omitempty"`
	IsRouter             *bool    `protobuf:"varint,54,opt,name=is_router,json=isRouter" json:"is_router,omitempty"`
	NeighborState        *string  `protobuf:"bytes,55,opt,name=neighbor_state,json=neighborState" json:"neighbor_state,omitempty"`
	TableId              *uint32  `protobuf:"varint,56,opt,name=table_id,json=tableId" json:"table_id,omitempty"`
	IsSecure             *bool    `protobuf:"varint,57,opt,name=is_secure,json=isSecure" json:"is_secure,omitempty"`
	Expiry               *uint32  `protobuf:"varint,59,opt,name=expiry" json:"expiry,omitempty"`
	IsPublish            *bool    `protobuf:"varint,58,opt,name=is_publish,json=isPublish" json:"is_publish,omitempty"`
	InterfaceName        *string  `protobuf:"bytes,60,opt,name=interface_name,json=interfaceName" json:"interface_name,omitempty"`
	LogicalRouterId      *uint32  `protobuf:"varint,61,opt,name=logical_router_id,json=logicalRouterId" json:"logical_router_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) ProtoMessage() {
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 2, 1, 0, 0}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) GetIp() string {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) GetLinkLayerAddress() string {
	if m != nil && m.LinkLayerAddress != nil {
		return *m.LinkLayerAddress
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) GetOrigin() string {
	if m != nil && m.Origin != nil {
		return *m.Origin
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) GetIsRouter() bool {
	if m != nil && m.IsRouter != nil {
		return *m.IsRouter
	}
	return false
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) GetNeighborState() string {
	if m != nil && m.NeighborState != nil {
		return *m.NeighborState
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) GetTableId() uint32 {
	if m != nil && m.TableId != nil {
		return *m.TableId
	}
	return 0
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) GetIsSecure() bool {
	if m != nil && m.IsSecure != nil {
		return *m.IsSecure
	}
	return false
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) GetExpiry() uint32 {
	if m != nil && m.Expiry != nil {
		return *m.Expiry
	}
	return 0
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) GetIsPublish() bool {
	if m != nil && m.IsPublish != nil {
		return *m.IsPublish
	}
	return false
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) GetInterfaceName() string {
	if m != nil && m.InterfaceName != nil {
		return *m.InterfaceName
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) GetLogicalRouterId() uint32 {
	if m != nil && m.LogicalRouterId != nil {
		return *m.LogicalRouterId
	}
	return 0
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType struct {
	State                *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType        `protobuf:"bytes,151,opt,name=state" json:"state,omitempty"`
	InterfaceRef         *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType `protobuf:"bytes,152,opt,name=interface_ref,json=interfaceRef" json:"interface_ref,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                                           `json:"-"`
	XXX_unrecognized     []byte                                                                                             `json:"-"`
	XXX_sizecache        int32                                                                                              `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType) ProtoMessage() {
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 2, 2}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType) GetState() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType) GetInterfaceRef() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType {
	if m != nil {
		return m.InterfaceRef
	}
	return nil
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType struct {
	Enabled              *bool    `protobuf:"varint,51,opt,name=enabled" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType) ProtoMessage() {
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 2, 2, 0}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType struct {
	State                *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType `protobuf:"bytes,151,opt,name=state" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                                                                    `json:"-"`
	XXX_unrecognized     []byte                                                                                                      `json:"-"`
	XXX_sizecache        int32                                                                                                       `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType) ProtoMessage() {
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 2, 2, 1}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType) GetState() *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType {
	if m != nil {
		return m.State
	}
	return nil
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType struct {
	Interface            *string  `protobuf:"bytes,51,opt,name=interface" json:"interface,omitempty"`
	Subinterface         *uint32  `protobuf:"varint,52,opt,name=subinterface" json:"subinterface,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType) ProtoMessage() {
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 2, 2, 1, 0}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType) GetInterface() string {
	if m != nil && m.Interface != nil {
		return *m.Interface
	}
	return ""
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType) GetSubinterface() uint32 {
	if m != nil && m.Subinterface != nil {
		return *m.Subinterface
	}
	return 0
}

type InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType struct {
	Enabled              *bool    `protobuf:"varint,51,opt,name=enabled" json:"enabled,omitempty"`
	Mtu                  *uint32  `protobuf:"varint,52,opt,name=mtu" json:"mtu,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType) Reset() {
	*m = InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType{}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType) ProtoMessage() {}
func (*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 1, 0, 2, 3}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType) GetMtu() uint32 {
	if m != nil && m.Mtu != nil {
		return *m.Mtu
	}
	return 0
}

type InterfacesMibInterfaceListHoldTimeType struct {
	State                *InterfacesMibInterfaceListHoldTimeTypeStateType `protobuf:"bytes,151,opt,name=state" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                         `json:"-"`
	XXX_unrecognized     []byte                                           `json:"-"`
	XXX_sizecache        int32                                            `json:"-"`
}

func (m *InterfacesMibInterfaceListHoldTimeType) Reset() {
	*m = InterfacesMibInterfaceListHoldTimeType{}
}
func (m *InterfacesMibInterfaceListHoldTimeType) String() string { return proto.CompactTextString(m) }
func (*InterfacesMibInterfaceListHoldTimeType) ProtoMessage()    {}
func (*InterfacesMibInterfaceListHoldTimeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 2}
}
func (m *InterfacesMibInterfaceListHoldTimeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListHoldTimeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListHoldTimeType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListHoldTimeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListHoldTimeType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListHoldTimeType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListHoldTimeType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListHoldTimeType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListHoldTimeType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListHoldTimeType) GetState() *InterfacesMibInterfaceListHoldTimeTypeStateType {
	if m != nil {
		return m.State
	}
	return nil
}

type InterfacesMibInterfaceListHoldTimeTypeStateType struct {
	Up                   *uint32  `protobuf:"varint,51,opt,name=up" json:"up,omitempty"`
	Down                 *uint32  `protobuf:"varint,52,opt,name=down" json:"down,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InterfacesMibInterfaceListHoldTimeTypeStateType) Reset() {
	*m = InterfacesMibInterfaceListHoldTimeTypeStateType{}
}
func (m *InterfacesMibInterfaceListHoldTimeTypeStateType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListHoldTimeTypeStateType) ProtoMessage() {}
func (*InterfacesMibInterfaceListHoldTimeTypeStateType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 2, 0}
}
func (m *InterfacesMibInterfaceListHoldTimeTypeStateType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListHoldTimeTypeStateType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListHoldTimeTypeStateType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListHoldTimeTypeStateType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListHoldTimeTypeStateType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListHoldTimeTypeStateType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListHoldTimeTypeStateType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListHoldTimeTypeStateType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListHoldTimeTypeStateType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListHoldTimeTypeStateType) GetUp() uint32 {
	if m != nil && m.Up != nil {
		return *m.Up
	}
	return 0
}

func (m *InterfacesMibInterfaceListHoldTimeTypeStateType) GetDown() uint32 {
	if m != nil && m.Down != nil {
		return *m.Down
	}
	return 0
}

type InterfacesMibInterfaceListEthernetType struct {
	State                *InterfacesMibInterfaceListEthernetTypeStateType `protobuf:"bytes,151,opt,name=state" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                         `json:"-"`
	XXX_unrecognized     []byte                                           `json:"-"`
	XXX_sizecache        int32                                            `json:"-"`
}

func (m *InterfacesMibInterfaceListEthernetType) Reset() {
	*m = InterfacesMibInterfaceListEthernetType{}
}
func (m *InterfacesMibInterfaceListEthernetType) String() string { return proto.CompactTextString(m) }
func (*InterfacesMibInterfaceListEthernetType) ProtoMessage()    {}
func (*InterfacesMibInterfaceListEthernetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 3}
}
func (m *InterfacesMibInterfaceListEthernetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListEthernetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListEthernetType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListEthernetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListEthernetType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListEthernetType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListEthernetType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListEthernetType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListEthernetType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListEthernetType) GetState() *InterfacesMibInterfaceListEthernetTypeStateType {
	if m != nil {
		return m.State
	}
	return nil
}

type InterfacesMibInterfaceListEthernetTypeStateType struct {
	MacAddress           *string                                                      `protobuf:"bytes,51,opt,name=mac_address,json=macAddress" json:"mac_address,omitempty"`
	AutoNegotiate        *bool                                                        `protobuf:"varint,52,opt,name=auto_negotiate,json=autoNegotiate" json:"auto_negotiate,omitempty"`
	DuplexMode           *string                                                      `protobuf:"bytes,53,opt,name=duplex_mode,json=duplexMode" json:"duplex_mode,omitempty"`
	PortSpeed            *string                                                      `protobuf:"bytes,54,opt,name=port_speed,json=portSpeed" json:"port_speed,omitempty"`
	EnableFlowControl    *bool                                                        `protobuf:"varint,55,opt,name=enable_flow_control,json=enableFlowControl" json:"enable_flow_control,omitempty"`
	HwMacAddress         *string                                                      `protobuf:"bytes,56,opt,name=hw_mac_address,json=hwMacAddress" json:"hw_mac_address,omitempty"`
	NegotiatedDuplexMode *string                                                      `protobuf:"bytes,57,opt,name=negotiated_duplex_mode,json=negotiatedDuplexMode" json:"negotiated_duplex_mode,omitempty"`
	NegotiatedPortSpeed  *string                                                      `protobuf:"bytes,58,opt,name=negotiated_port_speed,json=negotiatedPortSpeed" json:"negotiated_port_speed,omitempty"`
	Counters             *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType `protobuf:"bytes,151,opt,name=counters" json:"counters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                     `json:"-"`
	XXX_unrecognized     []byte                                                       `json:"-"`
	XXX_sizecache        int32                                                        `json:"-"`
}

func (m *InterfacesMibInterfaceListEthernetTypeStateType) Reset() {
	*m = InterfacesMibInterfaceListEthernetTypeStateType{}
}
func (m *InterfacesMibInterfaceListEthernetTypeStateType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListEthernetTypeStateType) ProtoMessage() {}
func (*InterfacesMibInterfaceListEthernetTypeStateType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 3, 0}
}
func (m *InterfacesMibInterfaceListEthernetTypeStateType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListEthernetTypeStateType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListEthernetTypeStateType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListEthernetTypeStateType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListEthernetTypeStateType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListEthernetTypeStateType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListEthernetTypeStateType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListEthernetTypeStateType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListEthernetTypeStateType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListEthernetTypeStateType) GetMacAddress() string {
	if m != nil && m.MacAddress != nil {
		return *m.MacAddress
	}
	return ""
}

func (m *InterfacesMibInterfaceListEthernetTypeStateType) GetAutoNegotiate() bool {
	if m != nil && m.AutoNegotiate != nil {
		return *m.AutoNegotiate
	}
	return false
}

func (m *InterfacesMibInterfaceListEthernetTypeStateType) GetDuplexMode() string {
	if m != nil && m.DuplexMode != nil {
		return *m.DuplexMode
	}
	return ""
}

func (m *InterfacesMibInterfaceListEthernetTypeStateType) GetPortSpeed() string {
	if m != nil && m.PortSpeed != nil {
		return *m.PortSpeed
	}
	return ""
}

func (m *InterfacesMibInterfaceListEthernetTypeStateType) GetEnableFlowControl() bool {
	if m != nil && m.EnableFlowControl != nil {
		return *m.EnableFlowControl
	}
	return false
}

func (m *InterfacesMibInterfaceListEthernetTypeStateType) GetHwMacAddress() string {
	if m != nil && m.HwMacAddress != nil {
		return *m.HwMacAddress
	}
	return ""
}

func (m *InterfacesMibInterfaceListEthernetTypeStateType) GetNegotiatedDuplexMode() string {
	if m != nil && m.NegotiatedDuplexMode != nil {
		return *m.NegotiatedDuplexMode
	}
	return ""
}

func (m *InterfacesMibInterfaceListEthernetTypeStateType) GetNegotiatedPortSpeed() string {
	if m != nil && m.NegotiatedPortSpeed != nil {
		return *m.NegotiatedPortSpeed
	}
	return ""
}

func (m *InterfacesMibInterfaceListEthernetTypeStateType) GetCounters() *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType {
	if m != nil {
		return m.Counters
	}
	return nil
}

type InterfacesMibInterfaceListEthernetTypeStateTypeCountersType struct {
	InMacControlFrames   *uint64  `protobuf:"varint,51,opt,name=in_mac_control_frames,json=inMacControlFrames" json:"in_mac_control_frames,omitempty"`
	InMacPauseFrames     *uint64  `protobuf:"varint,52,opt,name=in_mac_pause_frames,json=inMacPauseFrames" json:"in_mac_pause_frames,omitempty"`
	InOversizeFrames     *uint64  `protobuf:"varint,53,opt,name=in_oversize_frames,json=inOversizeFrames" json:"in_oversize_frames,omitempty"`
	InJabberFrames       *uint64  `protobuf:"varint,54,opt,name=in_jabber_frames,json=inJabberFrames" json:"in_jabber_frames,omitempty"`
	InFragmentFrames     *uint64  `protobuf:"varint,55,opt,name=in_fragment_frames,json=inFragmentFrames" json:"in_fragment_frames,omitempty"`
	In_8021QFrames       *uint64  `protobuf:"varint,56,opt,name=in_8021q_frames,json=in8021qFrames" json:"in_8021q_frames,omitempty"`
	InCrcErrors          *uint64  `protobuf:"varint,57,opt,name=in_crc_errors,json=inCrcErrors" json:"in_crc_errors,omitempty"`
	InBlockErrors        *uint64  `protobuf:"varint,58,opt,name=in_block_errors,json=inBlockErrors" json:"in_block_errors,omitempty"`
	OutMacControlFrames  *uint64  `protobuf:"varint,60,opt,name=out_mac_control_frames,json=outMacControlFrames" json:"out_mac_control_frames,omitempty"`
	OutMacPauseFrames    *uint64  `protobuf:"varint,59,opt,name=out_mac_pause_frames,json=outMacPauseFrames" json:"out_mac_pause_frames,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) Reset() {
	*m = InterfacesMibInterfaceListEthernetTypeStateTypeCountersType{}
}
func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) String() string {
	return proto.CompactTextString(m)
}
func (*InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) ProtoMessage() {}
func (*InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) Descriptor() ([]byte, []int) {
	return fileDescriptor_152d1f4638f28fa5, []int{0, 0, 3, 0, 0}
}
func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfacesMibInterfaceListEthernetTypeStateTypeCountersType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfacesMibInterfaceListEthernetTypeStateTypeCountersType.Merge(m, src)
}
func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) XXX_Size() int {
	return m.Size()
}
func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfacesMibInterfaceListEthernetTypeStateTypeCountersType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfacesMibInterfaceListEthernetTypeStateTypeCountersType proto.InternalMessageInfo

func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) GetInMacControlFrames() uint64 {
	if m != nil && m.InMacControlFrames != nil {
		return *m.InMacControlFrames
	}
	return 0
}

func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) GetInMacPauseFrames() uint64 {
	if m != nil && m.InMacPauseFrames != nil {
		return *m.InMacPauseFrames
	}
	return 0
}

func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) GetInOversizeFrames() uint64 {
	if m != nil && m.InOversizeFrames != nil {
		return *m.InOversizeFrames
	}
	return 0
}

func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) GetInJabberFrames() uint64 {
	if m != nil && m.InJabberFrames != nil {
		return *m.InJabberFrames
	}
	return 0
}

func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) GetInFragmentFrames() uint64 {
	if m != nil && m.InFragmentFrames != nil {
		return *m.InFragmentFrames
	}
	return 0
}

func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) GetIn_8021QFrames() uint64 {
	if m != nil && m.In_8021QFrames != nil {
		return *m.In_8021QFrames
	}
	return 0
}

func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) GetInCrcErrors() uint64 {
	if m != nil && m.InCrcErrors != nil {
		return *m.InCrcErrors
	}
	return 0
}

func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) GetInBlockErrors() uint64 {
	if m != nil && m.InBlockErrors != nil {
		return *m.InBlockErrors
	}
	return 0
}

func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) GetOutMacControlFrames() uint64 {
	if m != nil && m.OutMacControlFrames != nil {
		return *m.OutMacControlFrames
	}
	return 0
}

func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) GetOutMacPauseFrames() uint64 {
	if m != nil && m.OutMacPauseFrames != nil {
		return *m.OutMacPauseFrames
	}
	return 0
}

var E_JnprInterfacesMibExt = &proto.ExtensionDesc{
	ExtendedType:  (*JuniperNetworksSensors)(nil),
	ExtensionType: (*InterfacesMib)(nil),
	Field:         55,
	Name:          "jnpr_interfaces_mib_ext",
	Tag:           "bytes,55,opt,name=jnpr_interfaces_mib_ext",
	Filename:      "mib2d_oc.proto",
}

func init() {
	proto.RegisterType((*InterfacesMib)(nil), "interfaces_mib")
	proto.RegisterType((*InterfacesMibInterfaceList)(nil), "interfaces_mib.interface_list")
	proto.RegisterType((*InterfacesMibInterfaceListStateType)(nil), "interfaces_mib.interface_list.state_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesType)(nil), "interfaces_mib.interface_list.subinterfaces_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.state_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv4_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv4_type.addresses_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv4_type.addresses_type.address_list")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv4_type.addresses_type.address_list.state_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv4_type.neighbors_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv4_type.neighbors_type.neighbor_list")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv4_type.neighbors_type.neighbor_list.state_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv4_type.unnumbered_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv4_type.unnumbered_type.state_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv4_type.unnumbered_type.interface_ref_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv4_type.unnumbered_type.interface_ref_type.state_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv4_type.state_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv6_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv6_type.addresses_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv6_type.addresses_type.address_list")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv6_type.addresses_type.address_list.state_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv6_type.neighbors_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv6_type.neighbors_type.neighbor_list")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv6_type.neighbors_type.neighbor_list.state_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv6_type.unnumbered_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv6_type.unnumbered_type.state_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv6_type.unnumbered_type.interface_ref_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv6_type.unnumbered_type.interface_ref_type.state_type")
	proto.RegisterType((*InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType)(nil), "interfaces_mib.interface_list.subinterfaces_type.subinterface_list.ipv6_type.state_type")
	proto.RegisterType((*InterfacesMibInterfaceListHoldTimeType)(nil), "interfaces_mib.interface_list.hold_time_type")
	proto.RegisterType((*InterfacesMibInterfaceListHoldTimeTypeStateType)(nil), "interfaces_mib.interface_list.hold_time_type.state_type")
	proto.RegisterType((*InterfacesMibInterfaceListEthernetType)(nil), "interfaces_mib.interface_list.ethernet_type")
	proto.RegisterType((*InterfacesMibInterfaceListEthernetTypeStateType)(nil), "interfaces_mib.interface_list.ethernet_type.state_type")
	proto.RegisterType((*InterfacesMibInterfaceListEthernetTypeStateTypeCountersType)(nil), "interfaces_mib.interface_list.ethernet_type.state_type.counters_type")
	proto.RegisterExtension(E_JnprInterfacesMibExt)
}

func init() { proto.RegisterFile("mib2d_oc.proto", fileDescriptor_152d1f4638f28fa5) }

var fileDescriptor_152d1f4638f28fa5 = []byte{
	// 1741 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x59, 0xcb, 0x6f, 0x1b, 0xc7,
	0x19, 0xc7, 0xca, 0x74, 0x4c, 0x7e, 0x12, 0x69, 0x6b, 0x64, 0x3b, 0xcc, 0xa6, 0x71, 0x54, 0xa7,
	0x09, 0x98, 0xc2, 0x22, 0x63, 0x59, 0x5e, 0x31, 0x7e, 0xb4, 0x8e, 0x5d, 0x1b, 0x50, 0x1a, 0x29,
	0x06, 0xd5, 0x43, 0x5a, 0xb4, 0x98, 0xee, 0x63, 0x48, 0x8e, 0xb4, 0xdc, 0xd9, 0xec, 0xce, 0x5a,
	0x52, 0x03, 0xb4, 0x40, 0x1f, 0xe8, 0x21, 0x41, 0x0f, 0x2d, 0xd0, 0xe7, 0x25, 0xa7, 0xa2, 0xff,
	0x44, 0x81, 0xdc, 0x9a, 0xa2, 0x87, 0xa6, 0xff, 0x41, 0xe1, 0x53, 0x4f, 0xbd, 0xf5, 0xd0, 0x5b,
	0x31, 0x33, 0x3b, 0xfb, 0xa0, 0x68, 0x29, 0x72, 0xf5, 0x08, 0x7c, 0xd3, 0xfc, 0xe6, 0x9b, 0xef,
	0xfb, 0xf8, 0xbd, 0xe6, 0xb7, 0x23, 0x68, 0x8c, 0xa8, 0xb3, 0xe8, 0x61, 0xe6, 0xb6, 0xc3, 0x88,
	0x71, 0x66, 0xce, 0x71, 0xe2, 0x93, 0x11, 0xe1, 0xd1, 0x0e, 0xe6, 0x2c, 0x54, 0xe0, 0xe5, 0xbf,
	0x74, 0xa1, 0x41, 0x03, 0x4e, 0xa2, 0xbe, 0xed, 0x92, 0x18, 0x8f, 0xa8, 0x83, 0x6e, 0x43, 0x2d,
	0x43, 0x9a, 0xbf, 0x31, 0xe6, 0x4f, 0xb5, 0xa6, 0x17, 0x2f, 0xb5, 0xcb, 0x42, 0xf9, 0x12, 0xfb,
	0x34, 0xe6, 0xbd, 0xfc, 0x84, 0xf9, 0x9f, 0xe5, 0x82, 0x46, 0xb9, 0x8b, 0x5e, 0x80, 0x4a, 0x60,
	0x8f, 0x48, 0xf3, 0xda, 0xbc, 0xd1, 0xaa, 0xdd, 0x3d, 0xfd, 0xe3, 0x3b, 0x53, 0x55, 0xa3, 0x27,
	0x21, 0x74, 0x07, 0x4e, 0xc7, 0xdc, 0xe6, 0xd2, 0x90, 0xd1, 0x9a, 0x5e, 0x7c, 0x7d, 0x6f, 0x43,
	0x6d, 0x29, 0x8c, 0xf9, 0x4e, 0x48, 0x7a, 0xea, 0x20, 0x7a, 0x0f, 0xea, 0x71, 0xe2, 0xe4, 0xa7,
	0x9a, 0xbf, 0x55, 0x9a, 0xae, 0xee, 0xa7, 0xa9, 0x78, 0x48, 0x69, 0x2c, 0x2b, 0x42, 0xdf, 0x84,
	0xda, 0x90, 0xf9, 0x1e, 0xe6, 0x74, 0x44, 0x9a, 0x7f, 0x50, 0x5a, 0x17, 0xf6, 0xd1, 0x9a, 0x1d,
	0x50, 0x1a, 0xab, 0x62, 0xfd, 0x2d, 0x3a, 0x22, 0x68, 0x05, 0xaa, 0x84, 0x0f, 0x49, 0x14, 0x10,
	0xde, 0xfc, 0x9d, 0xd2, 0x75, 0x65, 0x1f, 0x5d, 0x5a, 0x3e, 0x55, 0xa5, 0x97, 0xe6, 0x27, 0x53,
	0x00, 0x79, 0x1c, 0x10, 0x2a, 0x46, 0x37, 0x0d, 0x2b, 0x82, 0x8a, 0xd8, 0x6b, 0x2e, 0x29, 0x4c,
	0xca, 0x9d, 0x83, 0x53, 0x23, 0x9e, 0x34, 0xaf, 0xcf, 0x1b, 0xad, 0x7a, 0x4f, 0xfc, 0x89, 0x5e,
	0x81, 0xba, 0xcf, 0x58, 0xe8, 0xd8, 0xee, 0x26, 0x1e, 0x31, 0x8f, 0x34, 0xbb, 0xf3, 0x46, 0xab,
	0xda, 0x9b, 0xd1, 0xe0, 0x2a, 0xf3, 0x08, 0x9a, 0x87, 0x69, 0x8f, 0xc4, 0x6e, 0x44, 0x43, 0x4e,
	0x59, 0xd0, 0xb4, 0xa4, 0xc6, 0x22, 0x84, 0x9a, 0x70, 0x86, 0x04, 0xb6, 0xe3, 0x13, 0xaf, 0xb9,
	0x2c, 0x15, 0xe8, 0xa5, 0xd8, 0xa1, 0x7d, 0x1a, 0x78, 0x64, 0xbb, 0x79, 0x5b, 0x9a, 0xd5, 0x4b,
	0xf4, 0x65, 0x98, 0xb1, 0xbd, 0x11, 0x0d, 0xb0, 0xf8, 0x21, 0x49, 0xdc, 0xfc, 0x9a, 0x52, 0x2b,
	0xb1, 0x75, 0x09, 0xa1, 0x97, 0x61, 0x9a, 0x85, 0x24, 0xd2, 0x12, 0x5f, 0x97, 0x12, 0x20, 0xa0,
	0x5c, 0xc0, 0xb7, 0x63, 0x8e, 0xdd, 0xa1, 0x1d, 0x0c, 0x48, 0xf3, 0xce, 0xbc, 0xd1, 0xaa, 0xf4,
	0x40, 0x40, 0xf7, 0x24, 0x22, 0xcc, 0xfb, 0x6c, 0x40, 0x5d, 0xdb, 0x6f, 0xbe, 0xa5, 0x1c, 0x4b,
	0x97, 0xe6, 0x5f, 0x5f, 0x07, 0xb4, 0xbb, 0x00, 0xd0, 0x10, 0x66, 0x8a, 0xa8, 0xae, 0xfe, 0x7b,
	0x07, 0x2e, 0xa5, 0x12, 0xa4, 0x5a, 0xa4, 0xa4, 0xd9, 0xfc, 0xb4, 0x05, 0xb3, 0xbb, 0x64, 0xd0,
	0x8b, 0x70, 0x5a, 0x45, 0x4b, 0xe4, 0xb2, 0xae, 0x3b, 0x45, 0x61, 0x88, 0x8c, 0xb5, 0xca, 0xda,
	0x21, 0x78, 0x35, 0xa1, 0x9f, 0x1c, 0xa8, 0xd0, 0xf0, 0xd1, 0x92, 0x6e, 0xa3, 0xd5, 0xc3, 0xb0,
	0x22, 0x14, 0x2a, 0x23, 0x52, 0x77, 0x6a, 0xc3, 0xd2, 0x8d, 0x70, 0x58, 0x36, 0xac, 0xdc, 0x86,
	0x65, 0x7e, 0x58, 0xee, 0x92, 0xf3, 0xa5, 0xd0, 0xea, 0x98, 0x8e, 0x15, 0xf7, 0xf5, 0x3d, 0x8b,
	0xdb, 0x2a, 0x17, 0xb7, 0xee, 0xbb, 0xa5, 0x42, 0xdf, 0x15, 0x0a, 0x7e, 0x79, 0xef, 0x82, 0xef,
	0xee, 0x5b, 0xf0, 0x6f, 0xee, 0x57, 0xf0, 0x37, 0x0e, 0x50, 0xf0, 0x9f, 0xcd, 0x42, 0x2d, 0xcb,
	0x02, 0xfa, 0x00, 0x6a, 0xb6, 0xe7, 0x45, 0x24, 0x8e, 0x49, 0xac, 0xcb, 0xe9, 0xbb, 0x87, 0x9a,
	0xe8, 0x76, 0xa6, 0x5f, 0xe5, 0x24, 0xb7, 0x27, 0x8c, 0x07, 0x84, 0x0e, 0x86, 0x0e, 0x8b, 0xb2,
	0x61, 0x7d, 0xc8, 0xc6, 0x33, 0xfd, 0xa9, 0xf1, 0x6c, 0x8d, 0x7e, 0x08, 0x90, 0x04, 0x41, 0x32,
	0x72, 0x48, 0x44, 0x3c, 0x5d, 0x7f, 0xdf, 0x3b, 0x5c, 0xeb, 0xb9, 0x01, 0x65, 0xbe, 0x60, 0x11,
	0x31, 0xdd, 0xc4, 0xbf, 0x57, 0xa6, 0xdf, 0x3b, 0x5c, 0xd3, 0xbb, 0xda, 0xd9, 0xfc, 0xd3, 0x29,
	0x68, 0x94, 0x73, 0x81, 0x7e, 0x6a, 0xc0, 0x99, 0x14, 0xd2, 0x13, 0x8e, 0x1e, 0x65, 0xf2, 0xf5,
	0x52, 0xcd, 0x41, 0x6d, 0xda, 0xfc, 0xc5, 0x94, 0x68, 0x89, 0x7c, 0x07, 0x5d, 0x80, 0x29, 0x1a,
	0x96, 0x49, 0xc2, 0x14, 0x0d, 0xd1, 0x87, 0xc6, 0xd8, 0xe0, 0xe3, 0xc7, 0xe6, 0xec, 0x84, 0x78,
	0x7e, 0xbb, 0x34, 0x55, 0x1a, 0xb9, 0xcb, 0xd2, 0xd7, 0x57, 0xa0, 0x1e, 0x46, 0xa4, 0x4f, 0xb7,
	0xb1, 0x4f, 0x82, 0x01, 0x1f, 0xca, 0xe1, 0x50, 0xef, 0xcd, 0x28, 0xf0, 0x1d, 0x89, 0xa1, 0x8b,
	0xf0, 0x1c, 0x8b, 0xe8, 0x80, 0xea, 0x79, 0x93, 0xae, 0xcc, 0x8f, 0x4f, 0x43, 0xa3, 0x5c, 0xb9,
	0xe8, 0xe7, 0x06, 0x54, 0x35, 0xa4, 0x73, 0xb5, 0x71, 0x94, 0xbd, 0x92, 0x2d, 0x55, 0xb2, 0x32,
	0xe3, 0xe6, 0x4f, 0x2a, 0x50, 0x2f, 0xed, 0x3d, 0x29, 0x5d, 0x1f, 0x8d, 0xa7, 0x2b, 0x39, 0x3e,
	0x7f, 0x27, 0xe4, 0xeb, 0x6f, 0x53, 0x7b, 0x26, 0xec, 0x0a, 0x20, 0x9f, 0x06, 0x9b, 0xd8, 0xb7,
	0x77, 0x48, 0x84, 0x75, 0x57, 0xa8, 0x91, 0x7e, 0x4e, 0xec, 0xbc, 0x23, 0x36, 0xde, 0x52, 0xf8,
	0x93, 0x32, 0x87, 0x5e, 0x14, 0x4c, 0x31, 0xe6, 0x58, 0xde, 0x07, 0x8a, 0x21, 0x55, 0x05, 0xb0,
	0x26, 0xee, 0x84, 0x17, 0xa0, 0xca, 0xc5, 0x8d, 0x81, 0xa9, 0xa7, 0x2f, 0x05, 0xb9, 0x5e, 0xf1,
	0xd0, 0xab, 0x79, 0xc2, 0xb1, 0x8a, 0x99, 0xba, 0x16, 0xb2, 0x48, 0xaf, 0xcb, 0x2b, 0xf9, 0x22,
	0x3c, 0x47, 0xb6, 0x43, 0x1a, 0xed, 0xc8, 0x3b, 0xa1, 0xde, 0x4b, 0x57, 0xe8, 0x25, 0x00, 0x1a,
	0xe3, 0x30, 0x71, 0x7c, 0x1a, 0x0f, 0xe5, 0x75, 0x50, 0xed, 0xd5, 0x68, 0xfc, 0x50, 0x01, 0x42,
	0x7b, 0x1e, 0x45, 0xe9, 0xda, 0x4d, 0xa5, 0x3d, 0x43, 0xa5, 0x7f, 0x5f, 0x85, 0xd9, 0xf4, 0x96,
	0xc0, 0x11, 0x4b, 0x38, 0x89, 0x84, 0xa3, 0xb7, 0xa4, 0xa1, 0xb3, 0xe9, 0x46, 0x4f, 0xe2, 0x2b,
	0x9e, 0xf9, 0xf7, 0x0a, 0x9c, 0x1d, 0x1b, 0x6f, 0xe8, 0x47, 0x63, 0xf9, 0x1e, 0x1e, 0xe9, 0x34,
	0x9d, 0xc0, 0x58, 0x7e, 0x6d, 0x40, 0xfe, 0x93, 0x70, 0x44, 0xfa, 0xfa, 0x56, 0x09, 0x8f, 0xd6,
	0x93, 0x92, 0x4d, 0xe5, 0xd1, 0x4c, 0x86, 0xf5, 0x48, 0xdf, 0x7c, 0xad, 0x54, 0x7a, 0x05, 0x26,
	0x71, 0xad, 0xc4, 0x24, 0xcc, 0xff, 0x1a, 0x80, 0x76, 0x2b, 0x43, 0xbf, 0x1c, 0xef, 0xa4, 0x0f,
	0x8e, 0xfb, 0xf7, 0x4c, 0xe8, 0xa7, 0xb5, 0xd2, 0x6f, 0xfa, 0x52, 0xf1, 0x5b, 0x51, 0x75, 0x55,
	0x0e, 0xa0, 0xcb, 0x63, 0x74, 0x3a, 0x1d, 0x86, 0x25, 0x22, 0xdc, 0xfd, 0x7c, 0x31, 0xd2, 0x5f,
	0x2f, 0x4b, 0xd9, 0xd7, 0x8b, 0xf9, 0x33, 0x24, 0x29, 0x8d, 0x75, 0xf4, 0x94, 0xc6, 0x3a, 0x49,
	0x4a, 0x63, 0x9d, 0x28, 0xa5, 0xb1, 0x4e, 0x8e, 0xd2, 0x58, 0x4f, 0x2a, 0xc1, 0x4f, 0x8e, 0x95,
	0xd2, 0x58, 0x07, 0xa0, 0x34, 0x7f, 0x3c, 0x69, 0x4a, 0x63, 0x3d, 0x0d, 0xa5, 0x79, 0xff, 0xc8,
	0x28, 0x8d, 0xc0, 0xd3, 0xaf, 0x19, 0x75, 0x2b, 0xa6, 0x2b, 0xf3, 0xcf, 0xc7, 0x4b, 0x75, 0xac,
	0x03, 0x51, 0x9d, 0x8f, 0x4f, 0x9c, 0xea, 0x58, 0x4f, 0x45, 0x75, 0xfe, 0x75, 0x4c, 0x54, 0x87,
	0xc6, 0x29, 0x51, 0x48, 0xbf, 0x88, 0xab, 0x34, 0x56, 0x04, 0x61, 0x02, 0x9f, 0x59, 0x9e, 0xc4,
	0x67, 0x8a, 0x8c, 0xa8, 0x5b, 0x66, 0x44, 0x4a, 0x7d, 0x4c, 0xdc, 0x24, 0x22, 0x92, 0xed, 0x48,
	0xf5, 0xeb, 0x72, 0x5d, 0xe0, 0x41, 0x37, 0xff, 0x3f, 0x1e, 0x74, 0xeb, 0x73, 0xf3, 0xa0, 0xdb,
	0x27, 0xcf, 0x83, 0xac, 0x2f, 0x0c, 0x0f, 0xb2, 0x9e, 0x31, 0x1e, 0x64, 0x3d, 0x13, 0x3c, 0xe8,
	0x57, 0x06, 0x34, 0xca, 0xcf, 0xce, 0xe8, 0xdd, 0xb1, 0x80, 0x75, 0x0f, 0xf4, 0x6a, 0x3d, 0xe1,
	0xd7, 0xbe, 0x31, 0x3e, 0x59, 0x92, 0x30, 0x7d, 0x48, 0x9b, 0x4a, 0x42, 0x84, 0xa0, 0xe2, 0xb1,
	0xad, 0x20, 0x75, 0x4a, 0xfe, 0x6d, 0xfe, 0xfb, 0x0c, 0xd4, 0x4b, 0x0f, 0xd8, 0x68, 0x6d, 0xcc,
	0xa9, 0xe5, 0x83, 0x3c, 0x7f, 0x4f, 0xf0, 0xe9, 0xa3, 0x33, 0x25, 0xa7, 0x5e, 0x86, 0xe9, 0x91,
	0xed, 0x66, 0x73, 0x4d, 0x25, 0x01, 0x46, 0xb6, 0xab, 0x27, 0xda, 0xab, 0xd0, 0xb0, 0x13, 0xce,
	0x70, 0x40, 0x06, 0x8c, 0x53, 0xe1, 0xc8, 0x92, 0x0c, 0x6d, 0x5d, 0xa0, 0x6b, 0x1a, 0x14, 0x7a,
	0xbc, 0x24, 0xf4, 0xc9, 0xb6, 0x7a, 0x12, 0x57, 0xd3, 0x0f, 0x14, 0x24, 0x1f, 0xc4, 0x5f, 0x02,
	0x08, 0x59, 0xc4, 0x71, 0x1c, 0x92, 0xf4, 0x51, 0xb0, 0xd6, 0xab, 0x09, 0x64, 0x5d, 0x00, 0xa8,
	0x0d, 0x73, 0x2a, 0x57, 0xb8, 0xef, 0xb3, 0x2d, 0xec, 0xb2, 0x80, 0x47, 0xcc, 0x4f, 0x5f, 0xc6,
	0x67, 0xd5, 0xd6, 0x03, 0x9f, 0x6d, 0xdd, 0x53, 0x1b, 0xe8, 0x2b, 0xd0, 0x18, 0x6e, 0xe1, 0xa2,
	0xeb, 0xea, 0x1b, 0x70, 0x66, 0xb8, 0xb5, 0x9a, 0x3b, 0xbf, 0x04, 0x17, 0x33, 0xbf, 0x3d, 0x5c,
	0x74, 0x50, 0x3d, 0x13, 0x9e, 0xcf, 0x77, 0xbf, 0x91, 0xbb, 0xba, 0x08, 0x17, 0x0a, 0xa7, 0x0a,
	0x5e, 0xdf, 0x90, 0x87, 0xe6, 0xf2, 0xcd, 0x87, 0x99, 0xff, 0x0e, 0x54, 0x5d, 0x96, 0x88, 0x54,
	0x64, 0x3c, 0xfa, 0xfe, 0x53, 0x66, 0xaa, 0xad, 0x15, 0xa5, 0xff, 0xc1, 0xd0, 0x4b, 0xf3, 0x1f,
	0xa7, 0xa0, 0x5e, 0xda, 0x43, 0x57, 0xe1, 0x02, 0x0d, 0x64, 0x14, 0xd2, 0x80, 0xe1, 0x7e, 0x64,
	0x8f, 0x88, 0xca, 0x63, 0xa5, 0x87, 0x68, 0xb0, 0x6a, 0xbb, 0x69, 0xc8, 0x1e, 0xc8, 0x1d, 0xb4,
	0x00, 0x73, 0xe9, 0x91, 0xd0, 0x4e, 0x62, 0xa2, 0x0f, 0x2c, 0xc9, 0x03, 0xe7, 0xe4, 0x81, 0x87,
	0x62, 0x23, 0x15, 0xbf, 0x22, 0x66, 0x0b, 0x66, 0x8f, 0x48, 0x14, 0xd3, 0x1f, 0x64, 0xd2, 0xd7,
	0xb5, 0xf4, 0xbb, 0xe9, 0x46, 0x2a, 0xdd, 0x82, 0x73, 0x34, 0xc0, 0x1b, 0xb6, 0xe3, 0x90, 0x48,
	0xcb, 0x5a, 0x52, 0xb6, 0x41, 0x83, 0xb7, 0x25, 0x5c, 0xd2, 0xdb, 0x8f, 0xec, 0xc1, 0x88, 0x04,
	0x5c, 0xcb, 0x2e, 0x6b, 0xbd, 0x0f, 0xd2, 0x8d, 0x54, 0xfa, 0x35, 0x38, 0x4b, 0x03, 0xdc, 0x7d,
	0x63, 0xf1, 0xea, 0xfb, 0x5a, 0xb4, 0x2b, 0x45, 0xeb, 0x34, 0x90, 0x68, 0x2a, 0x77, 0x59, 0x8c,
	0x72, 0xec, 0x46, 0x2e, 0x26, 0x51, 0x24, 0xbe, 0x2a, 0xde, 0x94, 0x52, 0xd3, 0x34, 0xb8, 0x17,
	0xb9, 0xf7, 0x25, 0x94, 0xea, 0x72, 0x7c, 0xe6, 0x6e, 0x6a, 0xa9, 0x1b, 0x5a, 0xd7, 0x5d, 0x81,
	0xa6, 0x72, 0xd7, 0xe0, 0x22, 0x4b, 0xf8, 0xa4, 0xe0, 0xde, 0x92, 0xe2, 0x73, 0x2c, 0xe1, 0xbb,
	0xa2, 0xdb, 0x81, 0xf3, 0xfa, 0x50, 0x29, 0xbc, 0x37, 0xe5, 0x91, 0x59, 0x75, 0xa4, 0x10, 0xdf,
	0x1b, 0x18, 0x9e, 0xdf, 0x08, 0xc2, 0x08, 0x97, 0x4b, 0x05, 0x93, 0x6d, 0x8e, 0x9e, 0x6f, 0xbf,
	0x9d, 0x04, 0x34, 0x24, 0xd1, 0x1a, 0xe1, 0x5b, 0x2c, 0xda, 0x8c, 0xd7, 0x49, 0x10, 0x0b, 0x77,
	0x97, 0x65, 0x79, 0x9d, 0x1d, 0x2b, 0xaf, 0xde, 0x79, 0xa1, 0x68, 0x25, 0xc3, 0x56, 0xa9, 0x73,
	0x7f, 0x9b, 0xdf, 0xfd, 0xfe, 0xa7, 0x8f, 0x2f, 0x19, 0x9f, 0x3d, 0xbe, 0x64, 0xfc, 0xf3, 0xf1,
	0x25, 0xe3, 0x3b, 0xbd, 0x01, 0xe5, 0xed, 0x0d, 0xa5, 0xb6, 0x1d, 0x10, 0xde, 0xa1, 0x2e, 0x71,
	0x48, 0x34, 0xe8, 0x0c, 0x89, 0xed, 0xf3, 0xa1, 0xc3, 0xf8, 0x02, 0x0d, 0x06, 0x24, 0xe6, 0x0b,
	0x1b, 0x9c, 0x2e, 0x04, 0x36, 0xa7, 0x8f, 0x48, 0x27, 0xdc, 0x1c, 0x74, 0x36, 0x38, 0xed, 0xd8,
	0x9e, 0x1d, 0x8a, 0xda, 0xeb, 0xe0, 0x8d, 0x24, 0x60, 0x71, 0x27, 0x76, 0x87, 0x64, 0x64, 0xff,
	0x2f, 0x00, 0x00, 0xff, 0xff, 0xae, 0x49, 0x7d, 0x87, 0x32, 0x1d, 0x00, 0x00,
}

func (m *InterfacesMib) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMib) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMib) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Interface) > 0 {
		for iNdEx := len(m.Interface) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Interface[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMib2DOc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x9
			i--
			dAtA[i] = 0xba
		}
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HoldTime != nil {
		{
			size, err := m.HoldTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xda
	}
	if m.Ethernet != nil {
		{
			size, err := m.Ethernet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xca
	}
	if m.Subinterfaces != nil {
		{
			size, err := m.Subinterfaces.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xc2
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xba
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListStateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListStateType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListStateType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Logical != nil {
		i--
		if *m.Logical {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x88
	}
	if m.LastChange != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.LastChange))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x80
	}
	if m.OperStatus != nil {
		i -= len(*m.OperStatus)
		copy(dAtA[i:], *m.OperStatus)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.OperStatus)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xfa
	}
	if m.AdminStatus != nil {
		i -= len(*m.AdminStatus)
		copy(dAtA[i:], *m.AdminStatus)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.AdminStatus)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf2
	}
	if m.Ifindex != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.Ifindex))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe8
	}
	if m.LoopbackMode != nil {
		i--
		if *m.LoopbackMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc0
	}
	if m.Enabled != nil {
		i--
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb2
	}
	if m.Mtu != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.Mtu))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa8
	}
	if m.Type != nil {
		i -= len(*m.Type)
		copy(dAtA[i:], *m.Type)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Type)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Subinterface) > 0 {
		for iNdEx := len(m.Subinterface) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subinterface[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMib2DOc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x9
			i--
			dAtA[i] = 0xba
		}
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ipv6 != nil {
		{
			size, err := m.Ipv6.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xca
	}
	if m.Ipv4 != nil {
		{
			size, err := m.Ipv4.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xc2
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xba
	}
	if m.Index != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.Index))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Logical != nil {
		i--
		if *m.Logical {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x88
	}
	if m.LastChange != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.LastChange))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd0
	}
	if m.OperStatus != nil {
		i -= len(*m.OperStatus)
		copy(dAtA[i:], *m.OperStatus)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.OperStatus)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xca
	}
	if m.AdminStatus != nil {
		i -= len(*m.AdminStatus)
		copy(dAtA[i:], *m.AdminStatus)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.AdminStatus)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc2
	}
	if m.Ifindex != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.Ifindex))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if m.Enabled != nil {
		i--
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.Description != nil {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xaa
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	if m.Index != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.Index))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xd2
	}
	if m.Unnumbered != nil {
		{
			size, err := m.Unnumbered.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xca
	}
	if m.Neighbors != nil {
		{
			size, err := m.Neighbors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xc2
	}
	if m.Addresses != nil {
		{
			size, err := m.Addresses.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Address) > 0 {
		for iNdEx := len(m.Address) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Address[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMib2DOc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x9
			i--
			dAtA[i] = 0xba
		}
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xba
	}
	if m.Ip != nil {
		i -= len(*m.Ip)
		copy(dAtA[i:], *m.Ip)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Ip)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Origin != nil {
		i -= len(*m.Origin)
		copy(dAtA[i:], *m.Origin)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Origin)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xaa
	}
	if m.PrefixLength != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.PrefixLength))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.Ip != nil {
		i -= len(*m.Ip)
		copy(dAtA[i:], *m.Ip)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Ip)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Neighbor) > 0 {
		for iNdEx := len(m.Neighbor) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Neighbor[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMib2DOc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x9
			i--
			dAtA[i] = 0xba
		}
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xba
	}
	if m.Ip != nil {
		i -= len(*m.Ip)
		copy(dAtA[i:], *m.Ip)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Ip)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LogicalRouterId != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.LogicalRouterId))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe0
	}
	if m.InterfaceName != nil {
		i -= len(*m.InterfaceName)
		copy(dAtA[i:], *m.InterfaceName)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.InterfaceName)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xda
	}
	if m.IsPublish != nil {
		i--
		if *m.IsPublish {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd0
	}
	if m.Expiry != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.Expiry))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc8
	}
	if m.NeighborState != nil {
		i -= len(*m.NeighborState)
		copy(dAtA[i:], *m.NeighborState)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.NeighborState)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc2
	}
	if m.TableId != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.TableId))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if m.HostName != nil {
		i -= len(*m.HostName)
		copy(dAtA[i:], *m.HostName)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.HostName)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb2
	}
	if m.Origin != nil {
		i -= len(*m.Origin)
		copy(dAtA[i:], *m.Origin)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Origin)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xaa
	}
	if m.LinkLayerAddress != nil {
		i -= len(*m.LinkLayerAddress)
		copy(dAtA[i:], *m.LinkLayerAddress)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.LinkLayerAddress)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	if m.Ip != nil {
		i -= len(*m.Ip)
		copy(dAtA[i:], *m.Ip)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Ip)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.InterfaceRef != nil {
		{
			size, err := m.InterfaceRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xc2
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Enabled != nil {
		i--
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Subinterface != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.Subinterface))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.Interface != nil {
		i -= len(*m.Interface)
		copy(dAtA[i:], *m.Interface)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Interface)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mtu != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.Mtu))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.Enabled != nil {
		i--
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xd2
	}
	if m.Unnumbered != nil {
		{
			size, err := m.Unnumbered.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xca
	}
	if m.Neighbors != nil {
		{
			size, err := m.Neighbors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xc2
	}
	if m.Addresses != nil {
		{
			size, err := m.Addresses.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Address) > 0 {
		for iNdEx := len(m.Address) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Address[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMib2DOc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x9
			i--
			dAtA[i] = 0xba
		}
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xba
	}
	if m.Ip != nil {
		i -= len(*m.Ip)
		copy(dAtA[i:], *m.Ip)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Ip)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		i -= len(*m.Status)
		copy(dAtA[i:], *m.Status)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Status)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb2
	}
	if m.Origin != nil {
		i -= len(*m.Origin)
		copy(dAtA[i:], *m.Origin)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Origin)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xaa
	}
	if m.PrefixLength != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.PrefixLength))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.Ip != nil {
		i -= len(*m.Ip)
		copy(dAtA[i:], *m.Ip)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Ip)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Neighbor) > 0 {
		for iNdEx := len(m.Neighbor) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Neighbor[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMib2DOc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x9
			i--
			dAtA[i] = 0xba
		}
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xba
	}
	if m.Ip != nil {
		i -= len(*m.Ip)
		copy(dAtA[i:], *m.Ip)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Ip)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LogicalRouterId != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.LogicalRouterId))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe8
	}
	if m.InterfaceName != nil {
		i -= len(*m.InterfaceName)
		copy(dAtA[i:], *m.InterfaceName)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.InterfaceName)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if m.Expiry != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.Expiry))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd8
	}
	if m.IsPublish != nil {
		i--
		if *m.IsPublish {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd0
	}
	if m.IsSecure != nil {
		i--
		if *m.IsSecure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc8
	}
	if m.TableId != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.TableId))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc0
	}
	if m.NeighborState != nil {
		i -= len(*m.NeighborState)
		copy(dAtA[i:], *m.NeighborState)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.NeighborState)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xba
	}
	if m.IsRouter != nil {
		i--
		if *m.IsRouter {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.Origin != nil {
		i -= len(*m.Origin)
		copy(dAtA[i:], *m.Origin)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Origin)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xaa
	}
	if m.LinkLayerAddress != nil {
		i -= len(*m.LinkLayerAddress)
		copy(dAtA[i:], *m.LinkLayerAddress)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.LinkLayerAddress)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	if m.Ip != nil {
		i -= len(*m.Ip)
		copy(dAtA[i:], *m.Ip)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Ip)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.InterfaceRef != nil {
		{
			size, err := m.InterfaceRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xc2
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Enabled != nil {
		i--
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Subinterface != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.Subinterface))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.Interface != nil {
		i -= len(*m.Interface)
		copy(dAtA[i:], *m.Interface)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.Interface)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mtu != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.Mtu))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.Enabled != nil {
		i--
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListHoldTimeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListHoldTimeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListHoldTimeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListHoldTimeTypeStateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListHoldTimeTypeStateType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListHoldTimeTypeStateType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Down != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.Down))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.Up != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.Up))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListEthernetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListEthernetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListEthernetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListEthernetTypeStateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListEthernetTypeStateType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListEthernetTypeStateType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Counters != nil {
		{
			size, err := m.Counters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMib2DOc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xba
	}
	if m.NegotiatedPortSpeed != nil {
		i -= len(*m.NegotiatedPortSpeed)
		copy(dAtA[i:], *m.NegotiatedPortSpeed)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.NegotiatedPortSpeed)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd2
	}
	if m.NegotiatedDuplexMode != nil {
		i -= len(*m.NegotiatedDuplexMode)
		copy(dAtA[i:], *m.NegotiatedDuplexMode)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.NegotiatedDuplexMode)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xca
	}
	if m.HwMacAddress != nil {
		i -= len(*m.HwMacAddress)
		copy(dAtA[i:], *m.HwMacAddress)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.HwMacAddress)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc2
	}
	if m.EnableFlowControl != nil {
		i--
		if *m.EnableFlowControl {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if m.PortSpeed != nil {
		i -= len(*m.PortSpeed)
		copy(dAtA[i:], *m.PortSpeed)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.PortSpeed)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb2
	}
	if m.DuplexMode != nil {
		i -= len(*m.DuplexMode)
		copy(dAtA[i:], *m.DuplexMode)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.DuplexMode)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xaa
	}
	if m.AutoNegotiate != nil {
		i--
		if *m.AutoNegotiate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.MacAddress != nil {
		i -= len(*m.MacAddress)
		copy(dAtA[i:], *m.MacAddress)
		i = encodeVarintMib2DOc(dAtA, i, uint64(len(*m.MacAddress)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}

func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OutMacControlFrames != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.OutMacControlFrames))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe0
	}
	if m.OutMacPauseFrames != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.OutMacPauseFrames))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd8
	}
	if m.InBlockErrors != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.InBlockErrors))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd0
	}
	if m.InCrcErrors != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.InCrcErrors))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc8
	}
	if m.In_8021QFrames != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.In_8021QFrames))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc0
	}
	if m.InFragmentFrames != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.InFragmentFrames))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if m.InJabberFrames != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.InJabberFrames))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.InOversizeFrames != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.InOversizeFrames))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa8
	}
	if m.InMacPauseFrames != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.InMacPauseFrames))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.InMacControlFrames != nil {
		i = encodeVarintMib2DOc(dAtA, i, uint64(*m.InMacControlFrames))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	return len(dAtA) - i, nil
}

func encodeVarintMib2DOc(dAtA []byte, offset int, v uint64) int {
	offset -= sovMib2DOc(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *InterfacesMib) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Interface) > 0 {
		for _, e := range m.Interface {
			l = e.Size()
			n += 2 + l + sovMib2DOc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.Subinterfaces != nil {
		l = m.Subinterfaces.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.Ethernet != nil {
		l = m.Ethernet.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.HoldTime != nil {
		l = m.HoldTime.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListStateType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.Type != nil {
		l = len(*m.Type)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.Mtu != nil {
		n += 2 + sovMib2DOc(uint64(*m.Mtu))
	}
	if m.Description != nil {
		l = len(*m.Description)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.Enabled != nil {
		n += 3
	}
	if m.LoopbackMode != nil {
		n += 3
	}
	if m.Ifindex != nil {
		n += 2 + sovMib2DOc(uint64(*m.Ifindex))
	}
	if m.AdminStatus != nil {
		l = len(*m.AdminStatus)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.OperStatus != nil {
		l = len(*m.OperStatus)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.LastChange != nil {
		n += 2 + sovMib2DOc(uint64(*m.LastChange))
	}
	if m.Logical != nil {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Subinterface) > 0 {
		for _, e := range m.Subinterface {
			l = e.Size()
			n += 2 + l + sovMib2DOc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != nil {
		n += 2 + sovMib2DOc(uint64(*m.Index))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.Ipv4 != nil {
		l = m.Ipv4.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.Ipv6 != nil {
		l = m.Ipv6.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != nil {
		n += 2 + sovMib2DOc(uint64(*m.Index))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.Description != nil {
		l = len(*m.Description)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.Enabled != nil {
		n += 3
	}
	if m.Ifindex != nil {
		n += 2 + sovMib2DOc(uint64(*m.Ifindex))
	}
	if m.AdminStatus != nil {
		l = len(*m.AdminStatus)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.OperStatus != nil {
		l = len(*m.OperStatus)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.LastChange != nil {
		n += 2 + sovMib2DOc(uint64(*m.LastChange))
	}
	if m.Logical != nil {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Addresses != nil {
		l = m.Addresses.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.Neighbors != nil {
		l = m.Neighbors.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.Unnumbered != nil {
		l = m.Unnumbered.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Address) > 0 {
		for _, e := range m.Address {
			l = e.Size()
			n += 2 + l + sovMib2DOc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != nil {
		l = len(*m.Ip)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != nil {
		l = len(*m.Ip)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.PrefixLength != nil {
		n += 2 + sovMib2DOc(uint64(*m.PrefixLength))
	}
	if m.Origin != nil {
		l = len(*m.Origin)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Neighbor) > 0 {
		for _, e := range m.Neighbor {
			l = e.Size()
			n += 2 + l + sovMib2DOc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != nil {
		l = len(*m.Ip)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != nil {
		l = len(*m.Ip)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.LinkLayerAddress != nil {
		l = len(*m.LinkLayerAddress)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.Origin != nil {
		l = len(*m.Origin)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.HostName != nil {
		l = len(*m.HostName)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.TableId != nil {
		n += 2 + sovMib2DOc(uint64(*m.TableId))
	}
	if m.NeighborState != nil {
		l = len(*m.NeighborState)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.Expiry != nil {
		n += 2 + sovMib2DOc(uint64(*m.Expiry))
	}
	if m.IsPublish != nil {
		n += 3
	}
	if m.InterfaceName != nil {
		l = len(*m.InterfaceName)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.LogicalRouterId != nil {
		n += 2 + sovMib2DOc(uint64(*m.LogicalRouterId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		l = m.State.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.InterfaceRef != nil {
		l = m.InterfaceRef.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		l = m.State.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Interface != nil {
		l = len(*m.Interface)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.Subinterface != nil {
		n += 2 + sovMib2DOc(uint64(*m.Subinterface))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 3
	}
	if m.Mtu != nil {
		n += 2 + sovMib2DOc(uint64(*m.Mtu))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Addresses != nil {
		l = m.Addresses.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.Neighbors != nil {
		l = m.Neighbors.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.Unnumbered != nil {
		l = m.Unnumbered.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Address) > 0 {
		for _, e := range m.Address {
			l = e.Size()
			n += 2 + l + sovMib2DOc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != nil {
		l = len(*m.Ip)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != nil {
		l = len(*m.Ip)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.PrefixLength != nil {
		n += 2 + sovMib2DOc(uint64(*m.PrefixLength))
	}
	if m.Origin != nil {
		l = len(*m.Origin)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.Status != nil {
		l = len(*m.Status)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Neighbor) > 0 {
		for _, e := range m.Neighbor {
			l = e.Size()
			n += 2 + l + sovMib2DOc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != nil {
		l = len(*m.Ip)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != nil {
		l = len(*m.Ip)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.LinkLayerAddress != nil {
		l = len(*m.LinkLayerAddress)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.Origin != nil {
		l = len(*m.Origin)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.IsRouter != nil {
		n += 3
	}
	if m.NeighborState != nil {
		l = len(*m.NeighborState)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.TableId != nil {
		n += 2 + sovMib2DOc(uint64(*m.TableId))
	}
	if m.IsSecure != nil {
		n += 3
	}
	if m.IsPublish != nil {
		n += 3
	}
	if m.Expiry != nil {
		n += 2 + sovMib2DOc(uint64(*m.Expiry))
	}
	if m.InterfaceName != nil {
		l = len(*m.InterfaceName)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.LogicalRouterId != nil {
		n += 2 + sovMib2DOc(uint64(*m.LogicalRouterId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		l = m.State.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.InterfaceRef != nil {
		l = m.InterfaceRef.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		l = m.State.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Interface != nil {
		l = len(*m.Interface)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.Subinterface != nil {
		n += 2 + sovMib2DOc(uint64(*m.Subinterface))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 3
	}
	if m.Mtu != nil {
		n += 2 + sovMib2DOc(uint64(*m.Mtu))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListHoldTimeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		l = m.State.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListHoldTimeTypeStateType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Up != nil {
		n += 2 + sovMib2DOc(uint64(*m.Up))
	}
	if m.Down != nil {
		n += 2 + sovMib2DOc(uint64(*m.Down))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListEthernetType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		l = m.State.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListEthernetTypeStateType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MacAddress != nil {
		l = len(*m.MacAddress)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.AutoNegotiate != nil {
		n += 3
	}
	if m.DuplexMode != nil {
		l = len(*m.DuplexMode)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.PortSpeed != nil {
		l = len(*m.PortSpeed)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.EnableFlowControl != nil {
		n += 3
	}
	if m.HwMacAddress != nil {
		l = len(*m.HwMacAddress)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.NegotiatedDuplexMode != nil {
		l = len(*m.NegotiatedDuplexMode)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.NegotiatedPortSpeed != nil {
		l = len(*m.NegotiatedPortSpeed)
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.Counters != nil {
		l = m.Counters.Size()
		n += 2 + l + sovMib2DOc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InMacControlFrames != nil {
		n += 2 + sovMib2DOc(uint64(*m.InMacControlFrames))
	}
	if m.InMacPauseFrames != nil {
		n += 2 + sovMib2DOc(uint64(*m.InMacPauseFrames))
	}
	if m.InOversizeFrames != nil {
		n += 2 + sovMib2DOc(uint64(*m.InOversizeFrames))
	}
	if m.InJabberFrames != nil {
		n += 2 + sovMib2DOc(uint64(*m.InJabberFrames))
	}
	if m.InFragmentFrames != nil {
		n += 2 + sovMib2DOc(uint64(*m.InFragmentFrames))
	}
	if m.In_8021QFrames != nil {
		n += 2 + sovMib2DOc(uint64(*m.In_8021QFrames))
	}
	if m.InCrcErrors != nil {
		n += 2 + sovMib2DOc(uint64(*m.InCrcErrors))
	}
	if m.InBlockErrors != nil {
		n += 2 + sovMib2DOc(uint64(*m.InBlockErrors))
	}
	if m.OutMacPauseFrames != nil {
		n += 2 + sovMib2DOc(uint64(*m.OutMacPauseFrames))
	}
	if m.OutMacControlFrames != nil {
		n += 2 + sovMib2DOc(uint64(*m.OutMacControlFrames))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMib2DOc(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMib2DOc(x uint64) (n int) {
	return sovMib2DOc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *InterfacesMib) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: interfaces_mib: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: interfaces_mib: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interface = append(m.Interface, &InterfacesMibInterfaceList{})
			if err := m.Interface[len(m.Interface)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: interface_list: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: interface_list: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &InterfacesMibInterfaceListStateType{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 152:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subinterfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subinterfaces == nil {
				m.Subinterfaces = &InterfacesMibInterfaceListSubinterfacesType{}
			}
			if err := m.Subinterfaces.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 153:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ethernet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ethernet == nil {
				m.Ethernet = &InterfacesMibInterfaceListEthernetType{}
			}
			if err := m.Ethernet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 155:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HoldTime == nil {
				m.HoldTime = &InterfacesMibInterfaceListHoldTimeType{}
			}
			if err := m.HoldTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListStateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: state_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: state_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Type = &s
			iNdEx = postIndex
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mtu = &v
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopbackMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LoopbackMode = &b
		case 61:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ifindex", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ifindex = &v
		case 62:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AdminStatus = &s
			iNdEx = postIndex
		case 63:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OperStatus = &s
			iNdEx = postIndex
		case 64:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastChange", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastChange = &v
		case 65:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logical", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Logical = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: subinterfaces_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: subinterfaces_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subinterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subinterface = append(m.Subinterface, &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList{})
			if err := m.Subinterface[len(m.Subinterface)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: subinterface_list: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: subinterface_list: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Index = &v
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 152:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ipv4 == nil {
				m.Ipv4 = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type{}
			}
			if err := m.Ipv4.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 153:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ipv6 == nil {
				m.Ipv6 = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type{}
			}
			if err := m.Ipv6.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListStateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: state_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: state_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Index = &v
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ifindex", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ifindex = &v
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AdminStatus = &s
			iNdEx = postIndex
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OperStatus = &s
			iNdEx = postIndex
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastChange", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastChange = &v
		case 65:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logical", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Logical = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ipv4_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ipv4_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Addresses == nil {
				m.Addresses = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType{}
			}
			if err := m.Addresses.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 152:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Neighbors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Neighbors == nil {
				m.Neighbors = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType{}
			}
			if err := m.Neighbors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 153:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unnumbered", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Unnumbered == nil {
				m.Unnumbered = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType{}
			}
			if err := m.Unnumbered.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 154:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: addresses_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: addresses_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address, &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList{})
			if err := m.Address[len(m.Address)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: address_list: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: address_list: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Ip = &s
			iNdEx = postIndex
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeAddressesTypeAddressListStateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: state_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: state_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Ip = &s
			iNdEx = postIndex
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLength", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrefixLength = &v
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Origin = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: neighbors_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: neighbors_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Neighbor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Neighbor = append(m.Neighbor, &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList{})
			if err := m.Neighbor[len(m.Neighbor)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: neighbor_list: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: neighbor_list: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Ip = &s
			iNdEx = postIndex
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeNeighborsTypeNeighborListStateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: state_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: state_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Ip = &s
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkLayerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.LinkLayerAddress = &s
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Origin = &s
			iNdEx = postIndex
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HostName = &s
			iNdEx = postIndex
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TableId = &v
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeighborState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NeighborState = &s
			iNdEx = postIndex
		case 57:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Expiry = &v
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPublish", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsPublish = &b
		case 59:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.InterfaceName = &s
			iNdEx = postIndex
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalRouterId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LogicalRouterId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: unnumbered_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: unnumbered_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 152:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterfaceRef == nil {
				m.InterfaceRef = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType{}
			}
			if err := m.InterfaceRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeStateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: state_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: state_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: interface_ref_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: interface_ref_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeUnnumberedTypeInterfaceRefTypeStateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: state_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: state_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interface", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Interface = &s
			iNdEx = postIndex
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subinterface", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Subinterface = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv4TypeStateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: state_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: state_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mtu = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ipv6_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ipv6_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Addresses == nil {
				m.Addresses = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType{}
			}
			if err := m.Addresses.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 152:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Neighbors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Neighbors == nil {
				m.Neighbors = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType{}
			}
			if err := m.Neighbors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 153:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unnumbered", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Unnumbered == nil {
				m.Unnumbered = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType{}
			}
			if err := m.Unnumbered.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 154:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: addresses_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: addresses_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address, &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList{})
			if err := m.Address[len(m.Address)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: address_list: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: address_list: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Ip = &s
			iNdEx = postIndex
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeAddressesTypeAddressListStateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: state_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: state_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Ip = &s
			iNdEx = postIndex
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLength", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrefixLength = &v
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Origin = &s
			iNdEx = postIndex
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Status = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: neighbors_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: neighbors_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Neighbor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Neighbor = append(m.Neighbor, &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList{})
			if err := m.Neighbor[len(m.Neighbor)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: neighbor_list: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: neighbor_list: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Ip = &s
			iNdEx = postIndex
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeNeighborsTypeNeighborListStateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: state_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: state_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Ip = &s
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkLayerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.LinkLayerAddress = &s
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Origin = &s
			iNdEx = postIndex
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRouter", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsRouter = &b
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeighborState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NeighborState = &s
			iNdEx = postIndex
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TableId = &v
		case 57:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSecure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsSecure = &b
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPublish", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsPublish = &b
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Expiry = &v
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.InterfaceName = &s
			iNdEx = postIndex
		case 61:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalRouterId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LogicalRouterId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: unnumbered_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: unnumbered_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 152:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterfaceRef == nil {
				m.InterfaceRef = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType{}
			}
			if err := m.InterfaceRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeStateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: state_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: state_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: interface_ref_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: interface_ref_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeUnnumberedTypeInterfaceRefTypeStateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: state_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: state_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interface", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Interface = &s
			iNdEx = postIndex
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subinterface", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Subinterface = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListSubinterfacesTypeSubinterfaceListIpv6TypeStateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: state_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: state_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mtu = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListHoldTimeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: hold_time_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: hold_time_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &InterfacesMibInterfaceListHoldTimeTypeStateType{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListHoldTimeTypeStateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: state_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: state_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Up", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Up = &v
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Down", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Down = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListEthernetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ethernet_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ethernet_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &InterfacesMibInterfaceListEthernetTypeStateType{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListEthernetTypeStateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: state_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: state_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MacAddress = &s
			iNdEx = postIndex
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoNegotiate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.AutoNegotiate = &b
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DuplexMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DuplexMode = &s
			iNdEx = postIndex
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortSpeed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PortSpeed = &s
			iNdEx = postIndex
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableFlowControl", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.EnableFlowControl = &b
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwMacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HwMacAddress = &s
			iNdEx = postIndex
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NegotiatedDuplexMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NegotiatedDuplexMode = &s
			iNdEx = postIndex
		case 58:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NegotiatedPortSpeed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NegotiatedPortSpeed = &s
			iNdEx = postIndex
		case 151:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMib2DOc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Counters == nil {
				m.Counters = &InterfacesMibInterfaceListEthernetTypeStateTypeCountersType{}
			}
			if err := m.Counters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfacesMibInterfaceListEthernetTypeStateTypeCountersType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: counters_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: counters_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InMacControlFrames", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InMacControlFrames = &v
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InMacPauseFrames", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InMacPauseFrames = &v
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InOversizeFrames", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InOversizeFrames = &v
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InJabberFrames", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InJabberFrames = &v
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InFragmentFrames", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InFragmentFrames = &v
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field In_8021QFrames", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.In_8021QFrames = &v
		case 57:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InCrcErrors", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InCrcErrors = &v
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InBlockErrors", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InBlockErrors = &v
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutMacPauseFrames", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutMacPauseFrames = &v
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutMacControlFrames", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutMacControlFrames = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMib2DOc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMib2DOc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMib2DOc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMib2DOc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMib2DOc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMib2DOc
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMib2DOc
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMib2DOc
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMib2DOc        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMib2DOc          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMib2DOc = fmt.Errorf("proto: unexpected end of group")
)
