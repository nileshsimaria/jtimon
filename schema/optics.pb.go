// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: optics.proto

package schema

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

//
// Top-level message
//
type Optics struct {
	OpticsDiag           []*OpticsInfos `protobuf:"bytes,1,rep,name=Optics_diag,json=OpticsDiag" json:"Optics_diag,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Optics) Reset()         { *m = Optics{} }
func (m *Optics) String() string { return proto.CompactTextString(m) }
func (*Optics) ProtoMessage()    {}
func (*Optics) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b02cb96ddad460a, []int{0}
}
func (m *Optics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Optics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Optics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Optics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Optics.Merge(m, src)
}
func (m *Optics) XXX_Size() int {
	return m.Size()
}
func (m *Optics) XXX_DiscardUnknown() {
	xxx_messageInfo_Optics.DiscardUnknown(m)
}

var xxx_messageInfo_Optics proto.InternalMessageInfo

func (m *Optics) GetOpticsDiag() []*OpticsInfos {
	if m != nil {
		return m.OpticsDiag
	}
	return nil
}

//
// Optics Interface information
//
type OpticsInfos struct {
	// Interface name, e.g., xe-0/0/0
	IfName *string `protobuf:"bytes,1,req,name=if_name,json=ifName" json:"if_name,omitempty"`
	// Global Index
	SnmpIfIndex *uint32 `protobuf:"varint,2,opt,name=snmp_if_index,json=snmpIfIndex" json:"snmp_if_index,omitempty"`
	// Optics module Diagnostics statistics
	OpticsDiagStats      *OpticsDiagStats `protobuf:"bytes,3,opt,name=optics_diag_stats,json=opticsDiagStats" json:"optics_diag_stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *OpticsInfos) Reset()         { *m = OpticsInfos{} }
func (m *OpticsInfos) String() string { return proto.CompactTextString(m) }
func (*OpticsInfos) ProtoMessage()    {}
func (*OpticsInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b02cb96ddad460a, []int{1}
}
func (m *OpticsInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpticsInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpticsInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpticsInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpticsInfos.Merge(m, src)
}
func (m *OpticsInfos) XXX_Size() int {
	return m.Size()
}
func (m *OpticsInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_OpticsInfos.DiscardUnknown(m)
}

var xxx_messageInfo_OpticsInfos proto.InternalMessageInfo

func (m *OpticsInfos) GetIfName() string {
	if m != nil && m.IfName != nil {
		return *m.IfName
	}
	return ""
}

func (m *OpticsInfos) GetSnmpIfIndex() uint32 {
	if m != nil && m.SnmpIfIndex != nil {
		return *m.SnmpIfIndex
	}
	return 0
}

func (m *OpticsInfos) GetOpticsDiagStats() *OpticsDiagStats {
	if m != nil {
		return m.OpticsDiagStats
	}
	return nil
}

//
// Optics Diagnostics stats
//
type OpticsDiagStats struct {
	OpticsType *uint32 `protobuf:"varint,1,opt,name=optics_type,json=opticsType" json:"optics_type,omitempty"`
	// Module temperature
	ModuleTemp *float64 `protobuf:"fixed64,2,opt,name=module_temp,json=moduleTemp" json:"module_temp,omitempty"`
	// Module temperature threshold information
	ModuleTempHighAlarmThreshold   *float64 `protobuf:"fixed64,3,opt,name=module_temp_high_alarm_threshold,json=moduleTempHighAlarmThreshold" json:"module_temp_high_alarm_threshold,omitempty"`
	ModuleTempLowAlarmThreshold    *float64 `protobuf:"fixed64,4,opt,name=module_temp_low_alarm_threshold,json=moduleTempLowAlarmThreshold" json:"module_temp_low_alarm_threshold,omitempty"`
	ModuleTempHighWarningThreshold *float64 `protobuf:"fixed64,5,opt,name=module_temp_high_warning_threshold,json=moduleTempHighWarningThreshold" json:"module_temp_high_warning_threshold,omitempty"`
	ModuleTempLowWarningThreshold  *float64 `protobuf:"fixed64,6,opt,name=module_temp_low_warning_threshold,json=moduleTempLowWarningThreshold" json:"module_temp_low_warning_threshold,omitempty"`
	// laser output power threshold information
	LaserOutputPowerHighAlarmThresholdDbm   *float64 `protobuf:"fixed64,7,opt,name=laser_output_power_high_alarm_threshold_dbm,json=laserOutputPowerHighAlarmThresholdDbm" json:"laser_output_power_high_alarm_threshold_dbm,omitempty"`
	LaserOutputPowerLowAlarmThresholdDbm    *float64 `protobuf:"fixed64,8,opt,name=laser_output_power_low_alarm_threshold_dbm,json=laserOutputPowerLowAlarmThresholdDbm" json:"laser_output_power_low_alarm_threshold_dbm,omitempty"`
	LaserOutputPowerHighWarningThresholdDbm *float64 `protobuf:"fixed64,9,opt,name=laser_output_power_high_warning_threshold_dbm,json=laserOutputPowerHighWarningThresholdDbm" json:"laser_output_power_high_warning_threshold_dbm,omitempty"`
	LaserOutputPowerLowWarningThresholdDbm  *float64 `protobuf:"fixed64,10,opt,name=laser_output_power_low_warning_threshold_dbm,json=laserOutputPowerLowWarningThresholdDbm" json:"laser_output_power_low_warning_threshold_dbm,omitempty"`
	// laser rx power threshold information
	LaserRxPowerHighAlarmThresholdDbm   *float64 `protobuf:"fixed64,11,opt,name=laser_rx_power_high_alarm_threshold_dbm,json=laserRxPowerHighAlarmThresholdDbm" json:"laser_rx_power_high_alarm_threshold_dbm,omitempty"`
	LaserRxPowerLowAlarmThresholdDbm    *float64 `protobuf:"fixed64,12,opt,name=laser_rx_power_low_alarm_threshold_dbm,json=laserRxPowerLowAlarmThresholdDbm" json:"laser_rx_power_low_alarm_threshold_dbm,omitempty"`
	LaserRxPowerHighWarningThresholdDbm *float64 `protobuf:"fixed64,13,opt,name=laser_rx_power_high_warning_threshold_dbm,json=laserRxPowerHighWarningThresholdDbm" json:"laser_rx_power_high_warning_threshold_dbm,omitempty"`
	LaserRxPowerLowWarningThresholdDbm  *float64 `protobuf:"fixed64,14,opt,name=laser_rx_power_low_warning_threshold_dbm,json=laserRxPowerLowWarningThresholdDbm" json:"laser_rx_power_low_warning_threshold_dbm,omitempty"`
	// laser bias current threshold information
	LaserBiasCurrentHighAlarmThreshold   *float64 `protobuf:"fixed64,15,opt,name=laser_bias_current_high_alarm_threshold,json=laserBiasCurrentHighAlarmThreshold" json:"laser_bias_current_high_alarm_threshold,omitempty"`
	LaserBiasCurrentLowAlarmThreshold    *float64 `protobuf:"fixed64,16,opt,name=laser_bias_current_low_alarm_threshold,json=laserBiasCurrentLowAlarmThreshold" json:"laser_bias_current_low_alarm_threshold,omitempty"`
	LaserBiasCurrentHighWarningThreshold *float64 `protobuf:"fixed64,17,opt,name=laser_bias_current_high_warning_threshold,json=laserBiasCurrentHighWarningThreshold" json:"laser_bias_current_high_warning_threshold,omitempty"`
	LaserBiasCurrentLowWarningThreshold  *float64 `protobuf:"fixed64,18,opt,name=laser_bias_current_low_warning_threshold,json=laserBiasCurrentLowWarningThreshold" json:"laser_bias_current_low_warning_threshold,omitempty"`
	// Module temperature alarm information
	ModuleTempHighAlarm   *bool `protobuf:"varint,19,opt,name=module_temp_high_alarm,json=moduleTempHighAlarm" json:"module_temp_high_alarm,omitempty"`
	ModuleTempLowAlarm    *bool `protobuf:"varint,20,opt,name=module_temp_low_alarm,json=moduleTempLowAlarm" json:"module_temp_low_alarm,omitempty"`
	ModuleTempHighWarning *bool `protobuf:"varint,21,opt,name=module_temp_high_warning,json=moduleTempHighWarning" json:"module_temp_high_warning,omitempty"`
	ModuleTempLowWarning  *bool `protobuf:"varint,22,opt,name=module_temp_low_warning,json=moduleTempLowWarning" json:"module_temp_low_warning,omitempty"`
	// Optics module lane Diagnostics statistics
	OpticsLaneDiagStats  []*OpticsDiagLaneStats `protobuf:"bytes,23,rep,name=optics_lane_diag_stats,json=opticsLaneDiagStats" json:"optics_lane_diag_stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *OpticsDiagStats) Reset()         { *m = OpticsDiagStats{} }
func (m *OpticsDiagStats) String() string { return proto.CompactTextString(m) }
func (*OpticsDiagStats) ProtoMessage()    {}
func (*OpticsDiagStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b02cb96ddad460a, []int{2}
}
func (m *OpticsDiagStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpticsDiagStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpticsDiagStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpticsDiagStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpticsDiagStats.Merge(m, src)
}
func (m *OpticsDiagStats) XXX_Size() int {
	return m.Size()
}
func (m *OpticsDiagStats) XXX_DiscardUnknown() {
	xxx_messageInfo_OpticsDiagStats.DiscardUnknown(m)
}

var xxx_messageInfo_OpticsDiagStats proto.InternalMessageInfo

func (m *OpticsDiagStats) GetOpticsType() uint32 {
	if m != nil && m.OpticsType != nil {
		return *m.OpticsType
	}
	return 0
}

func (m *OpticsDiagStats) GetModuleTemp() float64 {
	if m != nil && m.ModuleTemp != nil {
		return *m.ModuleTemp
	}
	return 0
}

func (m *OpticsDiagStats) GetModuleTempHighAlarmThreshold() float64 {
	if m != nil && m.ModuleTempHighAlarmThreshold != nil {
		return *m.ModuleTempHighAlarmThreshold
	}
	return 0
}

func (m *OpticsDiagStats) GetModuleTempLowAlarmThreshold() float64 {
	if m != nil && m.ModuleTempLowAlarmThreshold != nil {
		return *m.ModuleTempLowAlarmThreshold
	}
	return 0
}

func (m *OpticsDiagStats) GetModuleTempHighWarningThreshold() float64 {
	if m != nil && m.ModuleTempHighWarningThreshold != nil {
		return *m.ModuleTempHighWarningThreshold
	}
	return 0
}

func (m *OpticsDiagStats) GetModuleTempLowWarningThreshold() float64 {
	if m != nil && m.ModuleTempLowWarningThreshold != nil {
		return *m.ModuleTempLowWarningThreshold
	}
	return 0
}

func (m *OpticsDiagStats) GetLaserOutputPowerHighAlarmThresholdDbm() float64 {
	if m != nil && m.LaserOutputPowerHighAlarmThresholdDbm != nil {
		return *m.LaserOutputPowerHighAlarmThresholdDbm
	}
	return 0
}

func (m *OpticsDiagStats) GetLaserOutputPowerLowAlarmThresholdDbm() float64 {
	if m != nil && m.LaserOutputPowerLowAlarmThresholdDbm != nil {
		return *m.LaserOutputPowerLowAlarmThresholdDbm
	}
	return 0
}

func (m *OpticsDiagStats) GetLaserOutputPowerHighWarningThresholdDbm() float64 {
	if m != nil && m.LaserOutputPowerHighWarningThresholdDbm != nil {
		return *m.LaserOutputPowerHighWarningThresholdDbm
	}
	return 0
}

func (m *OpticsDiagStats) GetLaserOutputPowerLowWarningThresholdDbm() float64 {
	if m != nil && m.LaserOutputPowerLowWarningThresholdDbm != nil {
		return *m.LaserOutputPowerLowWarningThresholdDbm
	}
	return 0
}

func (m *OpticsDiagStats) GetLaserRxPowerHighAlarmThresholdDbm() float64 {
	if m != nil && m.LaserRxPowerHighAlarmThresholdDbm != nil {
		return *m.LaserRxPowerHighAlarmThresholdDbm
	}
	return 0
}

func (m *OpticsDiagStats) GetLaserRxPowerLowAlarmThresholdDbm() float64 {
	if m != nil && m.LaserRxPowerLowAlarmThresholdDbm != nil {
		return *m.LaserRxPowerLowAlarmThresholdDbm
	}
	return 0
}

func (m *OpticsDiagStats) GetLaserRxPowerHighWarningThresholdDbm() float64 {
	if m != nil && m.LaserRxPowerHighWarningThresholdDbm != nil {
		return *m.LaserRxPowerHighWarningThresholdDbm
	}
	return 0
}

func (m *OpticsDiagStats) GetLaserRxPowerLowWarningThresholdDbm() float64 {
	if m != nil && m.LaserRxPowerLowWarningThresholdDbm != nil {
		return *m.LaserRxPowerLowWarningThresholdDbm
	}
	return 0
}

func (m *OpticsDiagStats) GetLaserBiasCurrentHighAlarmThreshold() float64 {
	if m != nil && m.LaserBiasCurrentHighAlarmThreshold != nil {
		return *m.LaserBiasCurrentHighAlarmThreshold
	}
	return 0
}

func (m *OpticsDiagStats) GetLaserBiasCurrentLowAlarmThreshold() float64 {
	if m != nil && m.LaserBiasCurrentLowAlarmThreshold != nil {
		return *m.LaserBiasCurrentLowAlarmThreshold
	}
	return 0
}

func (m *OpticsDiagStats) GetLaserBiasCurrentHighWarningThreshold() float64 {
	if m != nil && m.LaserBiasCurrentHighWarningThreshold != nil {
		return *m.LaserBiasCurrentHighWarningThreshold
	}
	return 0
}

func (m *OpticsDiagStats) GetLaserBiasCurrentLowWarningThreshold() float64 {
	if m != nil && m.LaserBiasCurrentLowWarningThreshold != nil {
		return *m.LaserBiasCurrentLowWarningThreshold
	}
	return 0
}

func (m *OpticsDiagStats) GetModuleTempHighAlarm() bool {
	if m != nil && m.ModuleTempHighAlarm != nil {
		return *m.ModuleTempHighAlarm
	}
	return false
}

func (m *OpticsDiagStats) GetModuleTempLowAlarm() bool {
	if m != nil && m.ModuleTempLowAlarm != nil {
		return *m.ModuleTempLowAlarm
	}
	return false
}

func (m *OpticsDiagStats) GetModuleTempHighWarning() bool {
	if m != nil && m.ModuleTempHighWarning != nil {
		return *m.ModuleTempHighWarning
	}
	return false
}

func (m *OpticsDiagStats) GetModuleTempLowWarning() bool {
	if m != nil && m.ModuleTempLowWarning != nil {
		return *m.ModuleTempLowWarning
	}
	return false
}

func (m *OpticsDiagStats) GetOpticsLaneDiagStats() []*OpticsDiagLaneStats {
	if m != nil {
		return m.OpticsLaneDiagStats
	}
	return nil
}

//
// Optics Diagnostics lane stats
//
type OpticsDiagLaneStats struct {
	LaneNumber *uint32 `protobuf:"varint,1,opt,name=lane_number,json=laneNumber" json:"lane_number,omitempty"`
	// lane Module temperature
	LaneLaserTemperature *float64 `protobuf:"fixed64,2,opt,name=lane_laser_temperature,json=laneLaserTemperature" json:"lane_laser_temperature,omitempty"`
	// Laser receive power
	LaneLaserOutputPowerDbm *float32 `protobuf:"fixed32,3,opt,name=lane_laser_output_power_dbm,json=laneLaserOutputPowerDbm" json:"lane_laser_output_power_dbm,omitempty"`
	// Laser transmit power
	LaneLaserReceiverPowerDbm *float32 `protobuf:"fixed32,4,opt,name=lane_laser_receiver_power_dbm,json=laneLaserReceiverPowerDbm" json:"lane_laser_receiver_power_dbm,omitempty"`
	// Laser receive power
	LaneLaserBiasCurrent *float64 `protobuf:"fixed64,5,opt,name=lane_laser_bias_current,json=laneLaserBiasCurrent" json:"lane_laser_bias_current,omitempty"`
	//lane laser output power alarm
	LaneLaserOutputPowerHighAlarm   *bool `protobuf:"varint,6,opt,name=lane_laser_output_power_high_alarm,json=laneLaserOutputPowerHighAlarm" json:"lane_laser_output_power_high_alarm,omitempty"`
	LaneLaserOutputPowerLowAlarm    *bool `protobuf:"varint,7,opt,name=lane_laser_output_power_low_alarm,json=laneLaserOutputPowerLowAlarm" json:"lane_laser_output_power_low_alarm,omitempty"`
	LaneLaserOutputPowerHighWarning *bool `protobuf:"varint,8,opt,name=lane_laser_output_power_high_warning,json=laneLaserOutputPowerHighWarning" json:"lane_laser_output_power_high_warning,omitempty"`
	LaneLaserOutputPowerLowWarning  *bool `protobuf:"varint,9,opt,name=lane_laser_output_power_low_warning,json=laneLaserOutputPowerLowWarning" json:"lane_laser_output_power_low_warning,omitempty"`
	//lane laser receiver power alarm
	LaneLaserReceiverPowerHighAlarm   *bool `protobuf:"varint,10,opt,name=lane_laser_receiver_power_high_alarm,json=laneLaserReceiverPowerHighAlarm" json:"lane_laser_receiver_power_high_alarm,omitempty"`
	LaneLaserReceiverPowerLowAlarm    *bool `protobuf:"varint,11,opt,name=lane_laser_receiver_power_low_alarm,json=laneLaserReceiverPowerLowAlarm" json:"lane_laser_receiver_power_low_alarm,omitempty"`
	LaneLaserReceiverPowerHighWarning *bool `protobuf:"varint,12,opt,name=lane_laser_receiver_power_high_warning,json=laneLaserReceiverPowerHighWarning" json:"lane_laser_receiver_power_high_warning,omitempty"`
	LaneLaserReceiverPowerLowWarning  *bool `protobuf:"varint,13,opt,name=lane_laser_receiver_power_low_warning,json=laneLaserReceiverPowerLowWarning" json:"lane_laser_receiver_power_low_warning,omitempty"`
	//lane laser output power alarm
	LaneLaserBiasCurrentHighAlarm   *bool    `protobuf:"varint,14,opt,name=lane_laser_bias_current_high_alarm,json=laneLaserBiasCurrentHighAlarm" json:"lane_laser_bias_current_high_alarm,omitempty"`
	LaneLaserBiasCurrentLowAlarm    *bool    `protobuf:"varint,15,opt,name=lane_laser_bias_current_low_alarm,json=laneLaserBiasCurrentLowAlarm" json:"lane_laser_bias_current_low_alarm,omitempty"`
	LaneLaserBiasCurrentHighWarning *bool    `protobuf:"varint,16,opt,name=lane_laser_bias_current_high_warning,json=laneLaserBiasCurrentHighWarning" json:"lane_laser_bias_current_high_warning,omitempty"`
	LaneLaserBiasCurrentLowWarning  *bool    `protobuf:"varint,17,opt,name=lane_laser_bias_current_low_warning,json=laneLaserBiasCurrentLowWarning" json:"lane_laser_bias_current_low_warning,omitempty"`
	LaneTxLossOfSignalAlarm         *bool    `protobuf:"varint,18,opt,name=lane_tx_loss_of_signal_alarm,json=laneTxLossOfSignalAlarm" json:"lane_tx_loss_of_signal_alarm,omitempty"`
	LaneRxLossOfSignalAlarm         *bool    `protobuf:"varint,19,opt,name=lane_rx_loss_of_signal_alarm,json=laneRxLossOfSignalAlarm" json:"lane_rx_loss_of_signal_alarm,omitempty"`
	LaneTxLaserDisabledAlarm        *bool    `protobuf:"varint,20,opt,name=lane_tx_laser_disabled_alarm,json=laneTxLaserDisabledAlarm" json:"lane_tx_laser_disabled_alarm,omitempty"`
	XXX_NoUnkeyedLiteral            struct{} `json:"-"`
	XXX_unrecognized                []byte   `json:"-"`
	XXX_sizecache                   int32    `json:"-"`
}

func (m *OpticsDiagLaneStats) Reset()         { *m = OpticsDiagLaneStats{} }
func (m *OpticsDiagLaneStats) String() string { return proto.CompactTextString(m) }
func (*OpticsDiagLaneStats) ProtoMessage()    {}
func (*OpticsDiagLaneStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b02cb96ddad460a, []int{3}
}
func (m *OpticsDiagLaneStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpticsDiagLaneStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpticsDiagLaneStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpticsDiagLaneStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpticsDiagLaneStats.Merge(m, src)
}
func (m *OpticsDiagLaneStats) XXX_Size() int {
	return m.Size()
}
func (m *OpticsDiagLaneStats) XXX_DiscardUnknown() {
	xxx_messageInfo_OpticsDiagLaneStats.DiscardUnknown(m)
}

var xxx_messageInfo_OpticsDiagLaneStats proto.InternalMessageInfo

func (m *OpticsDiagLaneStats) GetLaneNumber() uint32 {
	if m != nil && m.LaneNumber != nil {
		return *m.LaneNumber
	}
	return 0
}

func (m *OpticsDiagLaneStats) GetLaneLaserTemperature() float64 {
	if m != nil && m.LaneLaserTemperature != nil {
		return *m.LaneLaserTemperature
	}
	return 0
}

func (m *OpticsDiagLaneStats) GetLaneLaserOutputPowerDbm() float32 {
	if m != nil && m.LaneLaserOutputPowerDbm != nil {
		return *m.LaneLaserOutputPowerDbm
	}
	return 0
}

func (m *OpticsDiagLaneStats) GetLaneLaserReceiverPowerDbm() float32 {
	if m != nil && m.LaneLaserReceiverPowerDbm != nil {
		return *m.LaneLaserReceiverPowerDbm
	}
	return 0
}

func (m *OpticsDiagLaneStats) GetLaneLaserBiasCurrent() float64 {
	if m != nil && m.LaneLaserBiasCurrent != nil {
		return *m.LaneLaserBiasCurrent
	}
	return 0
}

func (m *OpticsDiagLaneStats) GetLaneLaserOutputPowerHighAlarm() bool {
	if m != nil && m.LaneLaserOutputPowerHighAlarm != nil {
		return *m.LaneLaserOutputPowerHighAlarm
	}
	return false
}

func (m *OpticsDiagLaneStats) GetLaneLaserOutputPowerLowAlarm() bool {
	if m != nil && m.LaneLaserOutputPowerLowAlarm != nil {
		return *m.LaneLaserOutputPowerLowAlarm
	}
	return false
}

func (m *OpticsDiagLaneStats) GetLaneLaserOutputPowerHighWarning() bool {
	if m != nil && m.LaneLaserOutputPowerHighWarning != nil {
		return *m.LaneLaserOutputPowerHighWarning
	}
	return false
}

func (m *OpticsDiagLaneStats) GetLaneLaserOutputPowerLowWarning() bool {
	if m != nil && m.LaneLaserOutputPowerLowWarning != nil {
		return *m.LaneLaserOutputPowerLowWarning
	}
	return false
}

func (m *OpticsDiagLaneStats) GetLaneLaserReceiverPowerHighAlarm() bool {
	if m != nil && m.LaneLaserReceiverPowerHighAlarm != nil {
		return *m.LaneLaserReceiverPowerHighAlarm
	}
	return false
}

func (m *OpticsDiagLaneStats) GetLaneLaserReceiverPowerLowAlarm() bool {
	if m != nil && m.LaneLaserReceiverPowerLowAlarm != nil {
		return *m.LaneLaserReceiverPowerLowAlarm
	}
	return false
}

func (m *OpticsDiagLaneStats) GetLaneLaserReceiverPowerHighWarning() bool {
	if m != nil && m.LaneLaserReceiverPowerHighWarning != nil {
		return *m.LaneLaserReceiverPowerHighWarning
	}
	return false
}

func (m *OpticsDiagLaneStats) GetLaneLaserReceiverPowerLowWarning() bool {
	if m != nil && m.LaneLaserReceiverPowerLowWarning != nil {
		return *m.LaneLaserReceiverPowerLowWarning
	}
	return false
}

func (m *OpticsDiagLaneStats) GetLaneLaserBiasCurrentHighAlarm() bool {
	if m != nil && m.LaneLaserBiasCurrentHighAlarm != nil {
		return *m.LaneLaserBiasCurrentHighAlarm
	}
	return false
}

func (m *OpticsDiagLaneStats) GetLaneLaserBiasCurrentLowAlarm() bool {
	if m != nil && m.LaneLaserBiasCurrentLowAlarm != nil {
		return *m.LaneLaserBiasCurrentLowAlarm
	}
	return false
}

func (m *OpticsDiagLaneStats) GetLaneLaserBiasCurrentHighWarning() bool {
	if m != nil && m.LaneLaserBiasCurrentHighWarning != nil {
		return *m.LaneLaserBiasCurrentHighWarning
	}
	return false
}

func (m *OpticsDiagLaneStats) GetLaneLaserBiasCurrentLowWarning() bool {
	if m != nil && m.LaneLaserBiasCurrentLowWarning != nil {
		return *m.LaneLaserBiasCurrentLowWarning
	}
	return false
}

func (m *OpticsDiagLaneStats) GetLaneTxLossOfSignalAlarm() bool {
	if m != nil && m.LaneTxLossOfSignalAlarm != nil {
		return *m.LaneTxLossOfSignalAlarm
	}
	return false
}

func (m *OpticsDiagLaneStats) GetLaneRxLossOfSignalAlarm() bool {
	if m != nil && m.LaneRxLossOfSignalAlarm != nil {
		return *m.LaneRxLossOfSignalAlarm
	}
	return false
}

func (m *OpticsDiagLaneStats) GetLaneTxLaserDisabledAlarm() bool {
	if m != nil && m.LaneTxLaserDisabledAlarm != nil {
		return *m.LaneTxLaserDisabledAlarm
	}
	return false
}

var E_JnprOpticsExt = &proto.ExtensionDesc{
	ExtendedType:  (*JuniperNetworksSensors)(nil),
	ExtensionType: (*Optics)(nil),
	Field:         10,
	Name:          "jnpr_optics_ext",
	Tag:           "bytes,10,opt,name=jnpr_optics_ext",
	Filename:      "optics.proto",
}

func init() {
	proto.RegisterType((*Optics)(nil), "Optics")
	proto.RegisterType((*OpticsInfos)(nil), "OpticsInfos")
	proto.RegisterType((*OpticsDiagStats)(nil), "OpticsDiagStats")
	proto.RegisterType((*OpticsDiagLaneStats)(nil), "OpticsDiagLaneStats")
	proto.RegisterExtension(E_JnprOpticsExt)
}

func init() { proto.RegisterFile("optics.proto", fileDescriptor_1b02cb96ddad460a) }

var fileDescriptor_1b02cb96ddad460a = []byte{
	// 1147 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x95, 0xe9, 0x72, 0xdb, 0x36,
	0x10, 0xc7, 0x87, 0x4e, 0xe2, 0x63, 0xe5, 0x23, 0xa1, 0x7c, 0xb0, 0x4d, 0x2c, 0xcb, 0x4a, 0xe2,
	0xaa, 0x87, 0xa5, 0xa9, 0x3b, 0x99, 0xcc, 0xf4, 0x9a, 0xd6, 0x71, 0x27, 0x71, 0xe3, 0xd8, 0x0d,
	0xed, 0x99, 0xb4, 0xe9, 0x81, 0x42, 0x12, 0x24, 0xc1, 0xe1, 0x35, 0x00, 0x14, 0xcb, 0x5f, 0xfb,
	0x02, 0x7d, 0x82, 0x3e, 0x44, 0xdf, 0xa2, 0x1f, 0xfb, 0x08, 0x1d, 0x3f, 0x49, 0x07, 0xa0, 0x28,
	0x82, 0x24, 0xe8, 0x7c, 0x93, 0xc0, 0xdd, 0xdf, 0xfe, 0x77, 0x17, 0xd8, 0x85, 0xc5, 0x30, 0x12,
	0xb4, 0xcb, 0x5b, 0x11, 0x0b, 0x45, 0xf8, 0x7e, 0x55, 0x10, 0x8f, 0xf8, 0x44, 0xb0, 0x4b, 0x24,
	0xc2, 0x28, 0x3e, 0x6c, 0x3c, 0x86, 0xd9, 0x13, 0x65, 0x64, 0xef, 0x42, 0x25, 0xfe, 0x85, 0x7a,
	0x14, 0x0f, 0x1c, 0xab, 0x7e, 0xa3, 0x59, 0xd9, 0x5b, 0x6c, 0xc5, 0x67, 0x87, 0x41, 0x3f, 0xe4,
	0x2e, 0xc4, 0x7f, 0x0e, 0x28, 0x1e, 0x34, 0xfe, 0xb4, 0x12, 0x7b, 0xf5, 0xcd, 0xae, 0xc1, 0x1c,
	0xed, 0xa3, 0x00, 0xfb, 0xc4, 0xb1, 0xea, 0x33, 0xcd, 0x85, 0xfd, 0x5b, 0x7f, 0x7c, 0x33, 0x33,
	0x6f, 0xb9, 0xb3, 0xb4, 0x7f, 0x8c, 0x7d, 0x62, 0x37, 0x60, 0x89, 0x07, 0x7e, 0x84, 0x68, 0x1f,
	0xd1, 0xa0, 0x47, 0xc6, 0xce, 0x4c, 0xdd, 0x6a, 0x2e, 0xb9, 0x15, 0x79, 0x78, 0xd8, 0x3f, 0x94,
	0x47, 0xf6, 0x97, 0x70, 0x27, 0x4c, 0x25, 0x20, 0x2e, 0xb0, 0xe0, 0xce, 0x8d, 0xba, 0xd5, 0xac,
	0xec, 0xdd, 0x6e, 0xa5, 0xb1, 0x4f, 0xe5, 0xb9, 0xbb, 0x12, 0x66, 0x0f, 0x1a, 0x7f, 0x2f, 0xc3,
	0x4a, 0xce, 0xc8, 0xde, 0x82, 0xca, 0x84, 0x28, 0x2e, 0x23, 0xa9, 0x4c, 0xc6, 0x84, 0xf8, 0xe8,
	0xec, 0x32, 0x22, 0xf6, 0x0e, 0x54, 0xfc, 0xb0, 0x37, 0xf2, 0x08, 0x12, 0xc4, 0x8f, 0x94, 0x28,
	0x4b, 0x49, 0xaf, 0x5b, 0x2e, 0xc4, 0x5f, 0xce, 0x88, 0x1f, 0xd9, 0x2f, 0xa0, 0xae, 0xd9, 0xa1,
	0x21, 0x1d, 0x0c, 0x11, 0xf6, 0x30, 0xf3, 0x91, 0x18, 0x32, 0xc2, 0x87, 0xa1, 0xd7, 0x53, 0x4a,
	0xa7, 0xce, 0xf7, 0x52, 0xe7, 0x67, 0x74, 0x30, 0xfc, 0x56, 0xda, 0x9e, 0x25, 0xa6, 0xf6, 0x73,
	0xd8, 0xd2, 0x71, 0x5e, 0x78, 0x51, 0xa0, 0xdd, 0xd4, 0x69, 0x77, 0x53, 0xda, 0x51, 0x78, 0x91,
	0x83, 0xbd, 0x84, 0x46, 0x41, 0xdb, 0x05, 0x66, 0x01, 0x0d, 0x06, 0x1a, 0xef, 0x96, 0xce, 0xab,
	0x65, 0xd5, 0xbd, 0x8a, 0xad, 0x53, 0xe4, 0x09, 0x6c, 0xe7, 0xf5, 0x15, 0x89, 0xb3, 0x3a, 0x71,
	0x33, 0xa3, 0xb0, 0x00, 0xc4, 0xf0, 0xb1, 0x87, 0x39, 0x61, 0x28, 0x1c, 0x89, 0x68, 0x24, 0x50,
	0x14, 0x5e, 0x10, 0x66, 0x2c, 0x23, 0xea, 0x75, 0x7c, 0x67, 0x4e, 0x47, 0x3f, 0x54, 0x9e, 0x27,
	0xca, 0xf1, 0x07, 0xe9, 0x57, 0x2c, 0xe8, 0x41, 0xc7, 0xb7, 0x11, 0x7c, 0x64, 0x08, 0x61, 0x28,
	0xad, 0x8a, 0x30, 0xaf, 0x47, 0x78, 0x90, 0x8f, 0x50, 0x28, 0xb2, 0x0c, 0x40, 0x60, 0xb7, 0x2c,
	0x87, 0x42, 0x71, 0x54, 0x8c, 0x05, 0x3d, 0xc6, 0x07, 0xa6, 0x2c, 0xf2, 0x75, 0x92, 0x61, 0xba,
	0xf0, 0x49, 0x49, 0x1e, 0xe6, 0x28, 0xa0, 0x47, 0xd9, 0x31, 0x64, 0x62, 0x0a, 0xf2, 0x13, 0xc4,
	0x7a, 0x10, 0x1b, 0xbf, 0xab, 0x17, 0x15, 0x9d, 0xbf, 0xad, 0xbc, 0xdc, 0xf1, 0x35, 0x7d, 0x78,
	0x05, 0x3b, 0x39, 0x74, 0x59, 0x0f, 0x16, 0x75, 0x72, 0x5d, 0x27, 0x1b, 0xeb, 0xff, 0x2b, 0x7c,
	0x68, 0xd2, 0x6c, 0xae, 0xca, 0x92, 0xce, 0xbe, 0x9f, 0x57, 0x6d, 0x2a, 0xc9, 0xcf, 0xd0, 0x34,
	0xe8, 0x36, 0xd3, 0x97, 0x75, 0x7a, 0x23, 0xa7, 0xdc, 0x04, 0x7f, 0x9d, 0xd4, 0xbb, 0x43, 0x31,
	0x47, 0xdd, 0x11, 0x63, 0x24, 0x10, 0xe6, 0x31, 0xb2, 0x52, 0x64, 0xef, 0x53, 0xcc, 0x9f, 0xc4,
	0x3e, 0x86, 0x61, 0xf2, 0x63, 0x52, 0xf0, 0x0c, 0xdb, 0x34, 0x53, 0x6e, 0x17, 0x5b, 0xa9, 0xa1,
	0x8b, 0x93, 0xe5, 0xb7, 0xa4, 0xe2, 0x45, 0xd5, 0xc5, 0x71, 0x70, 0xa7, 0xf8, 0xa2, 0x72, 0xba,
	0x0b, 0x53, 0xe1, 0x97, 0xa4, 0xe4, 0x05, 0xe5, 0x45, 0xbc, 0x5d, 0x6c, 0x68, 0x56, 0x7b, 0x81,
	0xfe, 0x19, 0xac, 0x9b, 0x67, 0xb6, 0x53, 0xad, 0x5b, 0xcd, 0x79, 0xb7, 0x6a, 0x18, 0xd1, 0xf6,
	0xa7, 0xb0, 0x66, 0x9c, 0xcc, 0xce, 0xaa, 0xf2, 0xb1, 0x8b, 0x83, 0xd8, 0x7e, 0x0c, 0x4e, 0xd9,
	0xfc, 0x75, 0xd6, 0x94, 0xd7, 0x9a, 0x71, 0xdc, 0xda, 0x8f, 0x60, 0xa3, 0x64, 0xca, 0x3a, 0xeb,
	0xca, 0x6f, 0xd5, 0x34, 0x54, 0xed, 0x43, 0x58, 0x9f, 0x2c, 0x35, 0x0f, 0x07, 0x44, 0xdf, 0x95,
	0x1b, 0x6a, 0x69, 0xaf, 0x6a, 0xbb, 0xf2, 0x08, 0x07, 0x24, 0xde, 0x97, 0xd5, 0xd8, 0x47, 0x1e,
	0xa4, 0x3b, 0xf3, 0xaf, 0x0a, 0x54, 0x0d, 0xc6, 0x72, 0x2d, 0x2a, 0x76, 0x30, 0xf2, 0x3b, 0x84,
	0xc5, 0x7b, 0x33, 0xd9, 0xe8, 0x20, 0xbf, 0x1c, 0xab, 0x0f, 0xf6, 0x17, 0xb0, 0xae, 0xec, 0xe2,
	0x2e, 0xca, 0x2c, 0x08, 0xc3, 0x62, 0xc4, 0x48, 0x76, 0x93, 0xae, 0x4a, 0xa3, 0x23, 0x69, 0x73,
	0x96, 0x9a, 0xd8, 0x4f, 0xe0, 0xae, 0xe6, 0x9c, 0x99, 0x76, 0xf2, 0x8d, 0xc9, 0x75, 0x3a, 0x93,
	0x10, 0x36, 0xa6, 0x04, 0x6d, 0xb6, 0xc9, 0x87, 0xf5, 0x14, 0x36, 0x35, 0x08, 0x23, 0x5d, 0x42,
	0xdf, 0x12, 0xa6, 0x61, 0x6e, 0xea, 0x98, 0xf7, 0xa6, 0x18, 0x77, 0x62, 0x39, 0x05, 0x3d, 0x82,
	0x0d, 0x0d, 0xa4, 0x5f, 0xc8, 0x78, 0x75, 0x6a, 0x49, 0x68, 0xf7, 0xce, 0x3e, 0x84, 0x46, 0x59,
	0x12, 0xda, 0x85, 0x9b, 0x55, 0xed, 0xdc, 0x34, 0x25, 0x91, 0x5e, 0xbd, 0xa7, 0xb0, 0x5d, 0x86,
	0x4a, 0xaf, 0xe1, 0x9c, 0x22, 0xdd, 0x33, 0x91, 0xa6, 0x17, 0xf2, 0x05, 0x3c, 0xb8, 0x56, 0x53,
	0x72, 0xc9, 0xe6, 0x15, 0x6b, 0xab, 0x4c, 0x55, 0x72, 0xdf, 0x9e, 0xc3, 0xfd, 0xeb, 0x74, 0x25,
	0xb4, 0x05, 0x45, 0xab, 0x95, 0x28, 0x4b, 0x60, 0x59, 0x6d, 0xb9, 0x7e, 0x69, 0x15, 0x83, 0x9c,
	0xb6, 0x4c, 0xbf, 0xd2, 0x9a, 0x65, 0xb5, 0xe5, 0x70, 0x69, 0xd5, 0x2a, 0x39, 0x6d, 0x19, 0xda,
	0xb4, 0x6e, 0x2f, 0xe5, 0x20, 0xbd, 0x56, 0x5b, 0x92, 0xeb, 0xa2, 0xe2, 0x6d, 0x97, 0xab, 0x4b,
	0xd2, 0x3d, 0x81, 0x87, 0xd7, 0xeb, 0x4b, 0x88, 0x4b, 0x8a, 0x58, 0x2f, 0x55, 0x98, 0x3e, 0xfe,
	0x46, 0xc9, 0x35, 0xd5, 0xab, 0xb7, 0x9c, 0xbb, 0x6f, 0xa6, 0x05, 0x92, 0xbb, 0x6f, 0xe6, 0xe5,
	0xa1, 0xb6, 0x91, 0x7e, 0xdf, 0x0c, 0xfb, 0x22, 0xd7, 0xd3, 0xd2, 0x5d, 0xa1, 0xd6, 0x8f, 0xde,
	0x53, 0xf3, 0x7a, 0xc8, 0xf5, 0xb4, 0x6c, 0x35, 0xa8, 0x7d, 0xa3, 0xf7, 0xd4, 0xb8, 0x0d, 0xec,
	0xaf, 0x40, 0x69, 0x47, 0x62, 0x8c, 0xbc, 0x90, 0x73, 0x14, 0xf6, 0x11, 0xa7, 0x83, 0x00, 0x7b,
	0x93, 0xfc, 0x6c, 0x45, 0x51, 0x4f, 0xff, 0x6c, 0x7c, 0x14, 0x72, 0x7e, 0xd2, 0x3f, 0x55, 0xdf,
	0xe3, 0xd4, 0x12, 0x77, 0x56, 0xe2, 0x5e, 0x4d, 0xdd, 0x5d, 0x83, 0xfb, 0xd7, 0x5a, 0x74, 0x95,
	0x4d, 0x8f, 0x72, 0xdc, 0xf1, 0x48, 0x2f, 0xb3, 0x54, 0x9c, 0x49, 0x74, 0x69, 0x71, 0x30, 0x31,
	0x50, 0xfe, 0x9f, 0x3f, 0x83, 0x95, 0xf3, 0x20, 0x62, 0x68, 0x32, 0xef, 0xc9, 0x58, 0xd8, 0x1b,
	0xad, 0xef, 0x47, 0x01, 0x8d, 0x08, 0x3b, 0x26, 0xe2, 0x22, 0x64, 0x6f, 0xf8, 0x29, 0x09, 0x78,
	0xc8, 0xb8, 0x7a, 0x31, 0x95, 0xbd, 0xb9, 0xc9, 0xf0, 0x77, 0x97, 0xa4, 0x63, 0xfc, 0xfb, 0xbb,
	0xb1, 0xd8, 0xff, 0xfd, 0x9f, 0xab, 0x9a, 0xf5, 0xef, 0x55, 0xcd, 0xfa, 0xef, 0xaa, 0x66, 0xbd,
	0x76, 0x07, 0x54, 0xb4, 0xce, 0x63, 0x4e, 0x2b, 0x20, 0xa2, 0x4d, 0xbb, 0xa4, 0x43, 0xd8, 0xa0,
	0x3d, 0x24, 0xd8, 0x13, 0xc3, 0x4e, 0x28, 0x76, 0x69, 0x30, 0x20, 0x5c, 0xec, 0x9e, 0x0b, 0xba,
	0x1b, 0x60, 0x41, 0xdf, 0x92, 0x76, 0xf4, 0x66, 0xd0, 0x3e, 0x17, 0xb4, 0x8d, 0x7b, 0x38, 0x12,
	0x84, 0xf1, 0x36, 0x3a, 0x1f, 0x05, 0x21, 0x6f, 0xf3, 0xee, 0x90, 0xf8, 0xf8, 0xff, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x09, 0xa1, 0x8f, 0x85, 0x6e, 0x0e, 0x00, 0x00,
}

func (m *Optics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Optics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Optics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OpticsDiag) > 0 {
		for iNdEx := len(m.OpticsDiag) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OpticsDiag[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOptics(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OpticsInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpticsInfos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpticsInfos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OpticsDiagStats != nil {
		{
			size, err := m.OpticsDiagStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOptics(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SnmpIfIndex != nil {
		i = encodeVarintOptics(dAtA, i, uint64(*m.SnmpIfIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.IfName == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("if_name")
	} else {
		i -= len(*m.IfName)
		copy(dAtA[i:], *m.IfName)
		i = encodeVarintOptics(dAtA, i, uint64(len(*m.IfName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OpticsDiagStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpticsDiagStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpticsDiagStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OpticsLaneDiagStats) > 0 {
		for iNdEx := len(m.OpticsLaneDiagStats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OpticsLaneDiagStats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOptics(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if m.ModuleTempLowWarning != nil {
		i--
		if *m.ModuleTempLowWarning {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.ModuleTempHighWarning != nil {
		i--
		if *m.ModuleTempHighWarning {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.ModuleTempLowAlarm != nil {
		i--
		if *m.ModuleTempLowAlarm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.ModuleTempHighAlarm != nil {
		i--
		if *m.ModuleTempHighAlarm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.LaserBiasCurrentLowWarningThreshold != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.LaserBiasCurrentLowWarningThreshold))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x91
	}
	if m.LaserBiasCurrentHighWarningThreshold != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.LaserBiasCurrentHighWarningThreshold))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x89
	}
	if m.LaserBiasCurrentLowAlarmThreshold != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.LaserBiasCurrentLowAlarmThreshold))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x81
	}
	if m.LaserBiasCurrentHighAlarmThreshold != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.LaserBiasCurrentHighAlarmThreshold))))
		i--
		dAtA[i] = 0x79
	}
	if m.LaserRxPowerLowWarningThresholdDbm != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.LaserRxPowerLowWarningThresholdDbm))))
		i--
		dAtA[i] = 0x71
	}
	if m.LaserRxPowerHighWarningThresholdDbm != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.LaserRxPowerHighWarningThresholdDbm))))
		i--
		dAtA[i] = 0x69
	}
	if m.LaserRxPowerLowAlarmThresholdDbm != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.LaserRxPowerLowAlarmThresholdDbm))))
		i--
		dAtA[i] = 0x61
	}
	if m.LaserRxPowerHighAlarmThresholdDbm != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.LaserRxPowerHighAlarmThresholdDbm))))
		i--
		dAtA[i] = 0x59
	}
	if m.LaserOutputPowerLowWarningThresholdDbm != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.LaserOutputPowerLowWarningThresholdDbm))))
		i--
		dAtA[i] = 0x51
	}
	if m.LaserOutputPowerHighWarningThresholdDbm != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.LaserOutputPowerHighWarningThresholdDbm))))
		i--
		dAtA[i] = 0x49
	}
	if m.LaserOutputPowerLowAlarmThresholdDbm != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.LaserOutputPowerLowAlarmThresholdDbm))))
		i--
		dAtA[i] = 0x41
	}
	if m.LaserOutputPowerHighAlarmThresholdDbm != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.LaserOutputPowerHighAlarmThresholdDbm))))
		i--
		dAtA[i] = 0x39
	}
	if m.ModuleTempLowWarningThreshold != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.ModuleTempLowWarningThreshold))))
		i--
		dAtA[i] = 0x31
	}
	if m.ModuleTempHighWarningThreshold != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.ModuleTempHighWarningThreshold))))
		i--
		dAtA[i] = 0x29
	}
	if m.ModuleTempLowAlarmThreshold != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.ModuleTempLowAlarmThreshold))))
		i--
		dAtA[i] = 0x21
	}
	if m.ModuleTempHighAlarmThreshold != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.ModuleTempHighAlarmThreshold))))
		i--
		dAtA[i] = 0x19
	}
	if m.ModuleTemp != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.ModuleTemp))))
		i--
		dAtA[i] = 0x11
	}
	if m.OpticsType != nil {
		i = encodeVarintOptics(dAtA, i, uint64(*m.OpticsType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OpticsDiagLaneStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpticsDiagLaneStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpticsDiagLaneStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LaneTxLaserDisabledAlarm != nil {
		i--
		if *m.LaneTxLaserDisabledAlarm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.LaneRxLossOfSignalAlarm != nil {
		i--
		if *m.LaneRxLossOfSignalAlarm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.LaneTxLossOfSignalAlarm != nil {
		i--
		if *m.LaneTxLossOfSignalAlarm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.LaneLaserBiasCurrentLowWarning != nil {
		i--
		if *m.LaneLaserBiasCurrentLowWarning {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.LaneLaserBiasCurrentHighWarning != nil {
		i--
		if *m.LaneLaserBiasCurrentHighWarning {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.LaneLaserBiasCurrentLowAlarm != nil {
		i--
		if *m.LaneLaserBiasCurrentLowAlarm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.LaneLaserBiasCurrentHighAlarm != nil {
		i--
		if *m.LaneLaserBiasCurrentHighAlarm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.LaneLaserReceiverPowerLowWarning != nil {
		i--
		if *m.LaneLaserReceiverPowerLowWarning {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.LaneLaserReceiverPowerHighWarning != nil {
		i--
		if *m.LaneLaserReceiverPowerHighWarning {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.LaneLaserReceiverPowerLowAlarm != nil {
		i--
		if *m.LaneLaserReceiverPowerLowAlarm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.LaneLaserReceiverPowerHighAlarm != nil {
		i--
		if *m.LaneLaserReceiverPowerHighAlarm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.LaneLaserOutputPowerLowWarning != nil {
		i--
		if *m.LaneLaserOutputPowerLowWarning {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.LaneLaserOutputPowerHighWarning != nil {
		i--
		if *m.LaneLaserOutputPowerHighWarning {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.LaneLaserOutputPowerLowAlarm != nil {
		i--
		if *m.LaneLaserOutputPowerLowAlarm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.LaneLaserOutputPowerHighAlarm != nil {
		i--
		if *m.LaneLaserOutputPowerHighAlarm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.LaneLaserBiasCurrent != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.LaneLaserBiasCurrent))))
		i--
		dAtA[i] = 0x29
	}
	if m.LaneLaserReceiverPowerDbm != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.LaneLaserReceiverPowerDbm))))
		i--
		dAtA[i] = 0x25
	}
	if m.LaneLaserOutputPowerDbm != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.LaneLaserOutputPowerDbm))))
		i--
		dAtA[i] = 0x1d
	}
	if m.LaneLaserTemperature != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.LaneLaserTemperature))))
		i--
		dAtA[i] = 0x11
	}
	if m.LaneNumber != nil {
		i = encodeVarintOptics(dAtA, i, uint64(*m.LaneNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintOptics(dAtA []byte, offset int, v uint64) int {
	offset -= sovOptics(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Optics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OpticsDiag) > 0 {
		for _, e := range m.OpticsDiag {
			l = e.Size()
			n += 1 + l + sovOptics(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpticsInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfName != nil {
		l = len(*m.IfName)
		n += 1 + l + sovOptics(uint64(l))
	}
	if m.SnmpIfIndex != nil {
		n += 1 + sovOptics(uint64(*m.SnmpIfIndex))
	}
	if m.OpticsDiagStats != nil {
		l = m.OpticsDiagStats.Size()
		n += 1 + l + sovOptics(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpticsDiagStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpticsType != nil {
		n += 1 + sovOptics(uint64(*m.OpticsType))
	}
	if m.ModuleTemp != nil {
		n += 9
	}
	if m.ModuleTempHighAlarmThreshold != nil {
		n += 9
	}
	if m.ModuleTempLowAlarmThreshold != nil {
		n += 9
	}
	if m.ModuleTempHighWarningThreshold != nil {
		n += 9
	}
	if m.ModuleTempLowWarningThreshold != nil {
		n += 9
	}
	if m.LaserOutputPowerHighAlarmThresholdDbm != nil {
		n += 9
	}
	if m.LaserOutputPowerLowAlarmThresholdDbm != nil {
		n += 9
	}
	if m.LaserOutputPowerHighWarningThresholdDbm != nil {
		n += 9
	}
	if m.LaserOutputPowerLowWarningThresholdDbm != nil {
		n += 9
	}
	if m.LaserRxPowerHighAlarmThresholdDbm != nil {
		n += 9
	}
	if m.LaserRxPowerLowAlarmThresholdDbm != nil {
		n += 9
	}
	if m.LaserRxPowerHighWarningThresholdDbm != nil {
		n += 9
	}
	if m.LaserRxPowerLowWarningThresholdDbm != nil {
		n += 9
	}
	if m.LaserBiasCurrentHighAlarmThreshold != nil {
		n += 9
	}
	if m.LaserBiasCurrentLowAlarmThreshold != nil {
		n += 10
	}
	if m.LaserBiasCurrentHighWarningThreshold != nil {
		n += 10
	}
	if m.LaserBiasCurrentLowWarningThreshold != nil {
		n += 10
	}
	if m.ModuleTempHighAlarm != nil {
		n += 3
	}
	if m.ModuleTempLowAlarm != nil {
		n += 3
	}
	if m.ModuleTempHighWarning != nil {
		n += 3
	}
	if m.ModuleTempLowWarning != nil {
		n += 3
	}
	if len(m.OpticsLaneDiagStats) > 0 {
		for _, e := range m.OpticsLaneDiagStats {
			l = e.Size()
			n += 2 + l + sovOptics(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpticsDiagLaneStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LaneNumber != nil {
		n += 1 + sovOptics(uint64(*m.LaneNumber))
	}
	if m.LaneLaserTemperature != nil {
		n += 9
	}
	if m.LaneLaserOutputPowerDbm != nil {
		n += 5
	}
	if m.LaneLaserReceiverPowerDbm != nil {
		n += 5
	}
	if m.LaneLaserBiasCurrent != nil {
		n += 9
	}
	if m.LaneLaserOutputPowerHighAlarm != nil {
		n += 2
	}
	if m.LaneLaserOutputPowerLowAlarm != nil {
		n += 2
	}
	if m.LaneLaserOutputPowerHighWarning != nil {
		n += 2
	}
	if m.LaneLaserOutputPowerLowWarning != nil {
		n += 2
	}
	if m.LaneLaserReceiverPowerHighAlarm != nil {
		n += 2
	}
	if m.LaneLaserReceiverPowerLowAlarm != nil {
		n += 2
	}
	if m.LaneLaserReceiverPowerHighWarning != nil {
		n += 2
	}
	if m.LaneLaserReceiverPowerLowWarning != nil {
		n += 2
	}
	if m.LaneLaserBiasCurrentHighAlarm != nil {
		n += 2
	}
	if m.LaneLaserBiasCurrentLowAlarm != nil {
		n += 2
	}
	if m.LaneLaserBiasCurrentHighWarning != nil {
		n += 3
	}
	if m.LaneLaserBiasCurrentLowWarning != nil {
		n += 3
	}
	if m.LaneTxLossOfSignalAlarm != nil {
		n += 3
	}
	if m.LaneRxLossOfSignalAlarm != nil {
		n += 3
	}
	if m.LaneTxLaserDisabledAlarm != nil {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovOptics(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOptics(x uint64) (n int) {
	return sovOptics(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Optics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Optics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Optics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpticsDiag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpticsDiag = append(m.OpticsDiag, &OpticsInfos{})
			if err := m.OpticsDiag[len(m.OpticsDiag)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOptics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOptics
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOptics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpticsInfos) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpticsInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpticsInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IfName = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnmpIfIndex", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SnmpIfIndex = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpticsDiagStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpticsDiagStats == nil {
				m.OpticsDiagStats = &OpticsDiagStats{}
			}
			if err := m.OpticsDiagStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOptics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOptics
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOptics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("if_name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpticsDiagStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpticsDiagStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpticsDiagStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpticsType", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OpticsType = &v
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleTemp", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.ModuleTemp = &v2
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleTempHighAlarmThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.ModuleTempHighAlarmThreshold = &v2
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleTempLowAlarmThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.ModuleTempLowAlarmThreshold = &v2
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleTempHighWarningThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.ModuleTempHighWarningThreshold = &v2
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleTempLowWarningThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.ModuleTempLowWarningThreshold = &v2
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaserOutputPowerHighAlarmThresholdDbm", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.LaserOutputPowerHighAlarmThresholdDbm = &v2
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaserOutputPowerLowAlarmThresholdDbm", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.LaserOutputPowerLowAlarmThresholdDbm = &v2
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaserOutputPowerHighWarningThresholdDbm", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.LaserOutputPowerHighWarningThresholdDbm = &v2
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaserOutputPowerLowWarningThresholdDbm", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.LaserOutputPowerLowWarningThresholdDbm = &v2
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaserRxPowerHighAlarmThresholdDbm", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.LaserRxPowerHighAlarmThresholdDbm = &v2
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaserRxPowerLowAlarmThresholdDbm", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.LaserRxPowerLowAlarmThresholdDbm = &v2
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaserRxPowerHighWarningThresholdDbm", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.LaserRxPowerHighWarningThresholdDbm = &v2
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaserRxPowerLowWarningThresholdDbm", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.LaserRxPowerLowWarningThresholdDbm = &v2
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaserBiasCurrentHighAlarmThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.LaserBiasCurrentHighAlarmThreshold = &v2
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaserBiasCurrentLowAlarmThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.LaserBiasCurrentLowAlarmThreshold = &v2
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaserBiasCurrentHighWarningThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.LaserBiasCurrentHighWarningThreshold = &v2
		case 18:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaserBiasCurrentLowWarningThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.LaserBiasCurrentLowWarningThreshold = &v2
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleTempHighAlarm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ModuleTempHighAlarm = &b
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleTempLowAlarm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ModuleTempLowAlarm = &b
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleTempHighWarning", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ModuleTempHighWarning = &b
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleTempLowWarning", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ModuleTempLowWarning = &b
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpticsLaneDiagStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpticsLaneDiagStats = append(m.OpticsLaneDiagStats, &OpticsDiagLaneStats{})
			if err := m.OpticsLaneDiagStats[len(m.OpticsLaneDiagStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOptics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOptics
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOptics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpticsDiagLaneStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpticsDiagLaneStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpticsDiagLaneStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaneNumber", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LaneNumber = &v
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaneLaserTemperature", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.LaneLaserTemperature = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaneLaserOutputPowerDbm", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.LaneLaserOutputPowerDbm = &v2
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaneLaserReceiverPowerDbm", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.LaneLaserReceiverPowerDbm = &v2
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaneLaserBiasCurrent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.LaneLaserBiasCurrent = &v2
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaneLaserOutputPowerHighAlarm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LaneLaserOutputPowerHighAlarm = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaneLaserOutputPowerLowAlarm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LaneLaserOutputPowerLowAlarm = &b
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaneLaserOutputPowerHighWarning", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LaneLaserOutputPowerHighWarning = &b
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaneLaserOutputPowerLowWarning", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LaneLaserOutputPowerLowWarning = &b
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaneLaserReceiverPowerHighAlarm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LaneLaserReceiverPowerHighAlarm = &b
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaneLaserReceiverPowerLowAlarm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LaneLaserReceiverPowerLowAlarm = &b
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaneLaserReceiverPowerHighWarning", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LaneLaserReceiverPowerHighWarning = &b
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaneLaserReceiverPowerLowWarning", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LaneLaserReceiverPowerLowWarning = &b
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaneLaserBiasCurrentHighAlarm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LaneLaserBiasCurrentHighAlarm = &b
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaneLaserBiasCurrentLowAlarm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LaneLaserBiasCurrentLowAlarm = &b
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaneLaserBiasCurrentHighWarning", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LaneLaserBiasCurrentHighWarning = &b
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaneLaserBiasCurrentLowWarning", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LaneLaserBiasCurrentLowWarning = &b
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaneTxLossOfSignalAlarm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LaneTxLossOfSignalAlarm = &b
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaneRxLossOfSignalAlarm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LaneRxLossOfSignalAlarm = &b
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaneTxLaserDisabledAlarm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LaneTxLaserDisabledAlarm = &b
		default:
			iNdEx = preIndex
			skippy, err := skipOptics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOptics
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOptics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOptics(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOptics
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOptics
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOptics
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOptics
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOptics
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOptics        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOptics          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOptics = fmt.Errorf("proto: unexpected end of group")
)
