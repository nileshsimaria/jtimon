// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: port.proto

package schema

import (
	fmt "fmt"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

//
// Top-level message
//
type Port struct {
	InterfaceStats       []*InterfaceInfos `protobuf:"bytes,1,rep,name=interface_stats,json=interfaceStats" json:"interface_stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Port) Reset()         { *m = Port{} }
func (m *Port) String() string { return proto.CompactTextString(m) }
func (*Port) ProtoMessage()    {}
func (*Port) Descriptor() ([]byte, []int) {
	return fileDescriptor_729c3d36e9010a8e, []int{0}
}
func (m *Port) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Port) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Port.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Port) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Port.Merge(m, src)
}
func (m *Port) XXX_Size() int {
	return m.Size()
}
func (m *Port) XXX_DiscardUnknown() {
	xxx_messageInfo_Port.DiscardUnknown(m)
}

var xxx_messageInfo_Port proto.InternalMessageInfo

func (m *Port) GetInterfaceStats() []*InterfaceInfos {
	if m != nil {
		return m.InterfaceStats
	}
	return nil
}

//
// Interface information
//
type InterfaceInfos struct {
	// Interface name, e.g., xe-0/0/0
	IfName *string `protobuf:"bytes,1,req,name=if_name,json=ifName" json:"if_name,omitempty"`
	// Time when interface is created
	InitTime *uint64 `protobuf:"varint,2,opt,name=init_time,json=initTime" json:"init_time,omitempty"`
	// Global Index
	SnmpIfIndex *uint32 `protobuf:"varint,3,opt,name=snmp_if_index,json=snmpIfIndex" json:"snmp_if_index,omitempty"`
	// Name of parent for AE interface, if applicable
	ParentAeName *string `protobuf:"bytes,4,opt,name=parent_ae_name,json=parentAeName" json:"parent_ae_name,omitempty"`
	// Egress queue information
	EgressQueueInfo []*QueueStats `protobuf:"bytes,5,rep,name=egress_queue_info,json=egressQueueInfo" json:"egress_queue_info,omitempty"`
	// Ingress queue information
	IngressQueueInfo []*QueueStats `protobuf:"bytes,6,rep,name=ingress_queue_info,json=ingressQueueInfo" json:"ingress_queue_info,omitempty"`
	// Inbound traffic statistics
	IngressStats *InterfaceStats `protobuf:"bytes,7,opt,name=ingress_stats,json=ingressStats" json:"ingress_stats,omitempty"`
	// Outbound traffic statistics
	EgressStats *InterfaceStats `protobuf:"bytes,8,opt,name=egress_stats,json=egressStats" json:"egress_stats,omitempty"`
	// Inbound traffic errors
	IngressErrors *IngressInterfaceErrors `protobuf:"bytes,9,opt,name=ingress_errors,json=ingressErrors" json:"ingress_errors,omitempty"`
	// Interface administration status
	IfAdministrationStatus *string `protobuf:"bytes,10,opt,name=if_administration_status,json=ifAdministrationStatus" json:"if_administration_status,omitempty"`
	// Interface operational status
	IfOperationalStatus *string `protobuf:"bytes,11,opt,name=if_operational_status,json=ifOperationalStatus" json:"if_operational_status,omitempty"`
	// Interface description
	IfDescription *string `protobuf:"bytes,12,opt,name=if_description,json=ifDescription" json:"if_description,omitempty"`
	// Counter: number of carrier transitions on this interface
	IfTransitions *uint64 `protobuf:"varint,13,opt,name=if_transitions,json=ifTransitions" json:"if_transitions,omitempty"`
	// This corresponds to the ifLastChange object in the standard interface MIB
	IfLastChange *uint32 `protobuf:"varint,14,opt,name=ifLastChange" json:"ifLastChange,omitempty"`
	// This corresponds to the ifHighSpeed object in the standard interface MIB
	IfHighSpeed *uint32 `protobuf:"varint,15,opt,name=ifHighSpeed" json:"ifHighSpeed,omitempty"`
	// Outbound traffic errors
	EgressErrors         *EgressInterfaceErrors `protobuf:"bytes,16,opt,name=egress_errors,json=egressErrors" json:"egress_errors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *InterfaceInfos) Reset()         { *m = InterfaceInfos{} }
func (m *InterfaceInfos) String() string { return proto.CompactTextString(m) }
func (*InterfaceInfos) ProtoMessage()    {}
func (*InterfaceInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_729c3d36e9010a8e, []int{1}
}
func (m *InterfaceInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceInfos.Merge(m, src)
}
func (m *InterfaceInfos) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceInfos.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceInfos proto.InternalMessageInfo

func (m *InterfaceInfos) GetIfName() string {
	if m != nil && m.IfName != nil {
		return *m.IfName
	}
	return ""
}

func (m *InterfaceInfos) GetInitTime() uint64 {
	if m != nil && m.InitTime != nil {
		return *m.InitTime
	}
	return 0
}

func (m *InterfaceInfos) GetSnmpIfIndex() uint32 {
	if m != nil && m.SnmpIfIndex != nil {
		return *m.SnmpIfIndex
	}
	return 0
}

func (m *InterfaceInfos) GetParentAeName() string {
	if m != nil && m.ParentAeName != nil {
		return *m.ParentAeName
	}
	return ""
}

func (m *InterfaceInfos) GetEgressQueueInfo() []*QueueStats {
	if m != nil {
		return m.EgressQueueInfo
	}
	return nil
}

func (m *InterfaceInfos) GetIngressQueueInfo() []*QueueStats {
	if m != nil {
		return m.IngressQueueInfo
	}
	return nil
}

func (m *InterfaceInfos) GetIngressStats() *InterfaceStats {
	if m != nil {
		return m.IngressStats
	}
	return nil
}

func (m *InterfaceInfos) GetEgressStats() *InterfaceStats {
	if m != nil {
		return m.EgressStats
	}
	return nil
}

func (m *InterfaceInfos) GetIngressErrors() *IngressInterfaceErrors {
	if m != nil {
		return m.IngressErrors
	}
	return nil
}

func (m *InterfaceInfos) GetIfAdministrationStatus() string {
	if m != nil && m.IfAdministrationStatus != nil {
		return *m.IfAdministrationStatus
	}
	return ""
}

func (m *InterfaceInfos) GetIfOperationalStatus() string {
	if m != nil && m.IfOperationalStatus != nil {
		return *m.IfOperationalStatus
	}
	return ""
}

func (m *InterfaceInfos) GetIfDescription() string {
	if m != nil && m.IfDescription != nil {
		return *m.IfDescription
	}
	return ""
}

func (m *InterfaceInfos) GetIfTransitions() uint64 {
	if m != nil && m.IfTransitions != nil {
		return *m.IfTransitions
	}
	return 0
}

func (m *InterfaceInfos) GetIfLastChange() uint32 {
	if m != nil && m.IfLastChange != nil {
		return *m.IfLastChange
	}
	return 0
}

func (m *InterfaceInfos) GetIfHighSpeed() uint32 {
	if m != nil && m.IfHighSpeed != nil {
		return *m.IfHighSpeed
	}
	return 0
}

func (m *InterfaceInfos) GetEgressErrors() *EgressInterfaceErrors {
	if m != nil {
		return m.EgressErrors
	}
	return nil
}

//
// Interface queue statistics
//
type QueueStats struct {
	// Queue number
	QueueNumber *uint32 `protobuf:"varint,1,opt,name=queue_number,json=queueNumber" json:"queue_number,omitempty"`
	// The total number of packets that have been added to this queue
	Packets *uint64 `protobuf:"varint,2,opt,name=packets" json:"packets,omitempty"`
	// The total number of bytes that have been added to this queue
	Bytes *uint64 `protobuf:"varint,3,opt,name=bytes" json:"bytes,omitempty"`
	// The total number of tail dropped packets
	TailDropPackets *uint64 `protobuf:"varint,4,opt,name=tail_drop_packets,json=tailDropPackets" json:"tail_drop_packets,omitempty"`
	// The total number of rate-limited packets
	RlDropPackets *uint64 `protobuf:"varint,5,opt,name=rl_drop_packets,json=rlDropPackets" json:"rl_drop_packets,omitempty"`
	// The total number of rate-limited bytes
	RlDropBytes *uint64 `protobuf:"varint,6,opt,name=rl_drop_bytes,json=rlDropBytes" json:"rl_drop_bytes,omitempty"`
	// The total number of red-dropped packets
	RedDropPackets *uint64 `protobuf:"varint,7,opt,name=red_drop_packets,json=redDropPackets" json:"red_drop_packets,omitempty"`
	// The total number of red-dropped bytes
	RedDropBytes *uint64 `protobuf:"varint,8,opt,name=red_drop_bytes,json=redDropBytes" json:"red_drop_bytes,omitempty"`
	// Average queue depth, in packets
	AvgBufferOccupancy *uint64 `protobuf:"varint,9,opt,name=avg_buffer_occupancy,json=avgBufferOccupancy" json:"avg_buffer_occupancy,omitempty"`
	// Current queue depth, in packets
	CurBufferOccupancy *uint64 `protobuf:"varint,10,opt,name=cur_buffer_occupancy,json=curBufferOccupancy" json:"cur_buffer_occupancy,omitempty"`
	// The max measured queue depth, in packets, across all measurements since boot
	PeakBufferOccupancy *uint64 `protobuf:"varint,11,opt,name=peak_buffer_occupancy,json=peakBufferOccupancy" json:"peak_buffer_occupancy,omitempty"`
	// Allocated buffer size
	AllocatedBufferSize  *uint64  `protobuf:"varint,12,opt,name=allocated_buffer_size,json=allocatedBufferSize" json:"allocated_buffer_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueueStats) Reset()         { *m = QueueStats{} }
func (m *QueueStats) String() string { return proto.CompactTextString(m) }
func (*QueueStats) ProtoMessage()    {}
func (*QueueStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_729c3d36e9010a8e, []int{2}
}
func (m *QueueStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueStats.Merge(m, src)
}
func (m *QueueStats) XXX_Size() int {
	return m.Size()
}
func (m *QueueStats) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueStats.DiscardUnknown(m)
}

var xxx_messageInfo_QueueStats proto.InternalMessageInfo

func (m *QueueStats) GetQueueNumber() uint32 {
	if m != nil && m.QueueNumber != nil {
		return *m.QueueNumber
	}
	return 0
}

func (m *QueueStats) GetPackets() uint64 {
	if m != nil && m.Packets != nil {
		return *m.Packets
	}
	return 0
}

func (m *QueueStats) GetBytes() uint64 {
	if m != nil && m.Bytes != nil {
		return *m.Bytes
	}
	return 0
}

func (m *QueueStats) GetTailDropPackets() uint64 {
	if m != nil && m.TailDropPackets != nil {
		return *m.TailDropPackets
	}
	return 0
}

func (m *QueueStats) GetRlDropPackets() uint64 {
	if m != nil && m.RlDropPackets != nil {
		return *m.RlDropPackets
	}
	return 0
}

func (m *QueueStats) GetRlDropBytes() uint64 {
	if m != nil && m.RlDropBytes != nil {
		return *m.RlDropBytes
	}
	return 0
}

func (m *QueueStats) GetRedDropPackets() uint64 {
	if m != nil && m.RedDropPackets != nil {
		return *m.RedDropPackets
	}
	return 0
}

func (m *QueueStats) GetRedDropBytes() uint64 {
	if m != nil && m.RedDropBytes != nil {
		return *m.RedDropBytes
	}
	return 0
}

func (m *QueueStats) GetAvgBufferOccupancy() uint64 {
	if m != nil && m.AvgBufferOccupancy != nil {
		return *m.AvgBufferOccupancy
	}
	return 0
}

func (m *QueueStats) GetCurBufferOccupancy() uint64 {
	if m != nil && m.CurBufferOccupancy != nil {
		return *m.CurBufferOccupancy
	}
	return 0
}

func (m *QueueStats) GetPeakBufferOccupancy() uint64 {
	if m != nil && m.PeakBufferOccupancy != nil {
		return *m.PeakBufferOccupancy
	}
	return 0
}

func (m *QueueStats) GetAllocatedBufferSize() uint64 {
	if m != nil && m.AllocatedBufferSize != nil {
		return *m.AllocatedBufferSize
	}
	return 0
}

//
// Interface statistics
//
type InterfaceStats struct {
	// The total number of packets sent/received by this interface
	IfPkts *uint64 `protobuf:"varint,1,opt,name=if_pkts,json=ifPkts" json:"if_pkts,omitempty"`
	// The total number of bytes sent/received by this interface
	IfOctets *uint64 `protobuf:"varint,2,opt,name=if_octets,json=ifOctets" json:"if_octets,omitempty"`
	// The rate at which packets are sent/received by this interface (in packets/sec)
	If_1SecPkts *uint64 `protobuf:"varint,3,opt,name=if_1sec_pkts,json=if1secPkts" json:"if_1sec_pkts,omitempty"`
	// The rate at which bytes are sent/received by this interface
	If_1SecOctets *uint64 `protobuf:"varint,4,opt,name=if_1sec_octets,json=if1secOctets" json:"if_1sec_octets,omitempty"`
	// Total number of unicast packets sent/received by this interface
	IfUcPkts *uint64 `protobuf:"varint,5,opt,name=if_uc_pkts,json=ifUcPkts" json:"if_uc_pkts,omitempty"`
	// Total number of multicast packets sent/received by this interface
	IfMcPkts *uint64 `protobuf:"varint,6,opt,name=if_mc_pkts,json=ifMcPkts" json:"if_mc_pkts,omitempty"`
	// Total number of broadcast packets sent/received by this interface
	IfBcPkts *uint64 `protobuf:"varint,7,opt,name=if_bc_pkts,json=ifBcPkts" json:"if_bc_pkts,omitempty"`
	// Counter: total no of error packets sent/rcvd by this interface
	IfError *uint64 `protobuf:"varint,8,opt,name=if_error,json=ifError" json:"if_error,omitempty"`
	// Counter: total no of PAUSE packets sent/rcvd by this interface
	IfPausePkts *uint64 `protobuf:"varint,9,opt,name=if_pause_pkts,json=ifPausePkts" json:"if_pause_pkts,omitempty"`
	// Counter: total no of UNKNOWN proto packets sent/rcvd by this interface
	IfUnknownProtoPkts   *uint64  `protobuf:"varint,10,opt,name=if_unknown_proto_pkts,json=ifUnknownProtoPkts" json:"if_unknown_proto_pkts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InterfaceStats) Reset()         { *m = InterfaceStats{} }
func (m *InterfaceStats) String() string { return proto.CompactTextString(m) }
func (*InterfaceStats) ProtoMessage()    {}
func (*InterfaceStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_729c3d36e9010a8e, []int{3}
}
func (m *InterfaceStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceStats.Merge(m, src)
}
func (m *InterfaceStats) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceStats) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceStats.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceStats proto.InternalMessageInfo

func (m *InterfaceStats) GetIfPkts() uint64 {
	if m != nil && m.IfPkts != nil {
		return *m.IfPkts
	}
	return 0
}

func (m *InterfaceStats) GetIfOctets() uint64 {
	if m != nil && m.IfOctets != nil {
		return *m.IfOctets
	}
	return 0
}

func (m *InterfaceStats) GetIf_1SecPkts() uint64 {
	if m != nil && m.If_1SecPkts != nil {
		return *m.If_1SecPkts
	}
	return 0
}

func (m *InterfaceStats) GetIf_1SecOctets() uint64 {
	if m != nil && m.If_1SecOctets != nil {
		return *m.If_1SecOctets
	}
	return 0
}

func (m *InterfaceStats) GetIfUcPkts() uint64 {
	if m != nil && m.IfUcPkts != nil {
		return *m.IfUcPkts
	}
	return 0
}

func (m *InterfaceStats) GetIfMcPkts() uint64 {
	if m != nil && m.IfMcPkts != nil {
		return *m.IfMcPkts
	}
	return 0
}

func (m *InterfaceStats) GetIfBcPkts() uint64 {
	if m != nil && m.IfBcPkts != nil {
		return *m.IfBcPkts
	}
	return 0
}

func (m *InterfaceStats) GetIfError() uint64 {
	if m != nil && m.IfError != nil {
		return *m.IfError
	}
	return 0
}

func (m *InterfaceStats) GetIfPausePkts() uint64 {
	if m != nil && m.IfPausePkts != nil {
		return *m.IfPausePkts
	}
	return 0
}

func (m *InterfaceStats) GetIfUnknownProtoPkts() uint64 {
	if m != nil && m.IfUnknownProtoPkts != nil {
		return *m.IfUnknownProtoPkts
	}
	return 0
}

//
// Inbound traffic error statistics
//
type IngressInterfaceErrors struct {
	// The number of packets that contained errors
	IfErrors *uint64 `protobuf:"varint,1,opt,name=if_errors,json=ifErrors" json:"if_errors,omitempty"`
	// The number of packets dropped by the input queue of the I/O Manager ASIC
	IfInQdrops *uint64 `protobuf:"varint,2,opt,name=if_in_qdrops,json=ifInQdrops" json:"if_in_qdrops,omitempty"`
	// The number of packets which were misaligned
	IfInFrameErrors *uint64 `protobuf:"varint,3,opt,name=if_in_frame_errors,json=ifInFrameErrors" json:"if_in_frame_errors,omitempty"`
	// The number of non-error packets which were chosen to be discarded
	IfDiscards *uint64 `protobuf:"varint,4,opt,name=if_discards,json=ifDiscards" json:"if_discards,omitempty"`
	// The number of runt packets
	IfInRunts *uint64 `protobuf:"varint,5,opt,name=if_in_runts,json=ifInRunts" json:"if_in_runts,omitempty"`
	// The number of packets that fail Layer 3 sanity checks of the header
	IfInL3Incompletes *uint64 `protobuf:"varint,6,opt,name=if_in_l3_incompletes,json=ifInL3Incompletes" json:"if_in_l3_incompletes,omitempty"`
	// The number of packets for which the software could not find a valid logical interface
	IfInL2ChanErrors *uint64 `protobuf:"varint,7,opt,name=if_in_l2chan_errors,json=ifInL2chanErrors" json:"if_in_l2chan_errors,omitempty"`
	// The number of malform or short packets
	IfInL2MismatchTimeouts *uint64 `protobuf:"varint,8,opt,name=if_in_l2_mismatch_timeouts,json=ifInL2MismatchTimeouts" json:"if_in_l2_mismatch_timeouts,omitempty"`
	// The number of FIFO errors
	IfInFifoErrors *uint64 `protobuf:"varint,9,opt,name=if_in_fifo_errors,json=ifInFifoErrors" json:"if_in_fifo_errors,omitempty"`
	// The number of resource errors
	IfInResourceErrors   *uint64  `protobuf:"varint,10,opt,name=if_in_resource_errors,json=ifInResourceErrors" json:"if_in_resource_errors,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IngressInterfaceErrors) Reset()         { *m = IngressInterfaceErrors{} }
func (m *IngressInterfaceErrors) String() string { return proto.CompactTextString(m) }
func (*IngressInterfaceErrors) ProtoMessage()    {}
func (*IngressInterfaceErrors) Descriptor() ([]byte, []int) {
	return fileDescriptor_729c3d36e9010a8e, []int{4}
}
func (m *IngressInterfaceErrors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngressInterfaceErrors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngressInterfaceErrors.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngressInterfaceErrors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngressInterfaceErrors.Merge(m, src)
}
func (m *IngressInterfaceErrors) XXX_Size() int {
	return m.Size()
}
func (m *IngressInterfaceErrors) XXX_DiscardUnknown() {
	xxx_messageInfo_IngressInterfaceErrors.DiscardUnknown(m)
}

var xxx_messageInfo_IngressInterfaceErrors proto.InternalMessageInfo

func (m *IngressInterfaceErrors) GetIfErrors() uint64 {
	if m != nil && m.IfErrors != nil {
		return *m.IfErrors
	}
	return 0
}

func (m *IngressInterfaceErrors) GetIfInQdrops() uint64 {
	if m != nil && m.IfInQdrops != nil {
		return *m.IfInQdrops
	}
	return 0
}

func (m *IngressInterfaceErrors) GetIfInFrameErrors() uint64 {
	if m != nil && m.IfInFrameErrors != nil {
		return *m.IfInFrameErrors
	}
	return 0
}

func (m *IngressInterfaceErrors) GetIfDiscards() uint64 {
	if m != nil && m.IfDiscards != nil {
		return *m.IfDiscards
	}
	return 0
}

func (m *IngressInterfaceErrors) GetIfInRunts() uint64 {
	if m != nil && m.IfInRunts != nil {
		return *m.IfInRunts
	}
	return 0
}

func (m *IngressInterfaceErrors) GetIfInL3Incompletes() uint64 {
	if m != nil && m.IfInL3Incompletes != nil {
		return *m.IfInL3Incompletes
	}
	return 0
}

func (m *IngressInterfaceErrors) GetIfInL2ChanErrors() uint64 {
	if m != nil && m.IfInL2ChanErrors != nil {
		return *m.IfInL2ChanErrors
	}
	return 0
}

func (m *IngressInterfaceErrors) GetIfInL2MismatchTimeouts() uint64 {
	if m != nil && m.IfInL2MismatchTimeouts != nil {
		return *m.IfInL2MismatchTimeouts
	}
	return 0
}

func (m *IngressInterfaceErrors) GetIfInFifoErrors() uint64 {
	if m != nil && m.IfInFifoErrors != nil {
		return *m.IfInFifoErrors
	}
	return 0
}

func (m *IngressInterfaceErrors) GetIfInResourceErrors() uint64 {
	if m != nil && m.IfInResourceErrors != nil {
		return *m.IfInResourceErrors
	}
	return 0
}

//
// Outbound traffic error statistics
//
type EgressInterfaceErrors struct {
	// The number of packets that contained errors
	IfErrors *uint64 `protobuf:"varint,1,opt,name=if_errors,json=ifErrors" json:"if_errors,omitempty"`
	// The number of non-error packets which were chosen to be discarded
	IfDiscards           *uint64  `protobuf:"varint,2,opt,name=if_discards,json=ifDiscards" json:"if_discards,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EgressInterfaceErrors) Reset()         { *m = EgressInterfaceErrors{} }
func (m *EgressInterfaceErrors) String() string { return proto.CompactTextString(m) }
func (*EgressInterfaceErrors) ProtoMessage()    {}
func (*EgressInterfaceErrors) Descriptor() ([]byte, []int) {
	return fileDescriptor_729c3d36e9010a8e, []int{5}
}
func (m *EgressInterfaceErrors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EgressInterfaceErrors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EgressInterfaceErrors.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EgressInterfaceErrors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EgressInterfaceErrors.Merge(m, src)
}
func (m *EgressInterfaceErrors) XXX_Size() int {
	return m.Size()
}
func (m *EgressInterfaceErrors) XXX_DiscardUnknown() {
	xxx_messageInfo_EgressInterfaceErrors.DiscardUnknown(m)
}

var xxx_messageInfo_EgressInterfaceErrors proto.InternalMessageInfo

func (m *EgressInterfaceErrors) GetIfErrors() uint64 {
	if m != nil && m.IfErrors != nil {
		return *m.IfErrors
	}
	return 0
}

func (m *EgressInterfaceErrors) GetIfDiscards() uint64 {
	if m != nil && m.IfDiscards != nil {
		return *m.IfDiscards
	}
	return 0
}

var E_JnprInterfaceExt = &proto.ExtensionDesc{
	ExtendedType:  (*JuniperNetworksSensors)(nil),
	ExtensionType: (*Port)(nil),
	Field:         3,
	Name:          "jnpr_interface_ext",
	Tag:           "bytes,3,opt,name=jnpr_interface_ext",
	Filename:      "port.proto",
}

func init() {
	proto.RegisterType((*Port)(nil), "Port")
	proto.RegisterType((*InterfaceInfos)(nil), "InterfaceInfos")
	proto.RegisterType((*QueueStats)(nil), "QueueStats")
	proto.RegisterType((*InterfaceStats)(nil), "InterfaceStats")
	proto.RegisterType((*IngressInterfaceErrors)(nil), "IngressInterfaceErrors")
	proto.RegisterType((*EgressInterfaceErrors)(nil), "EgressInterfaceErrors")
	proto.RegisterExtension(E_JnprInterfaceExt)
}

func init() { proto.RegisterFile("port.proto", fileDescriptor_729c3d36e9010a8e) }

var fileDescriptor_729c3d36e9010a8e = []byte{
	// 1180 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x96, 0x5d, 0x6f, 0xdb, 0x36,
	0x17, 0xc7, 0xa1, 0x24, 0x4e, 0x62, 0xfa, 0x2d, 0x61, 0x9a, 0x54, 0x68, 0x81, 0x3c, 0x86, 0x9f,
	0x75, 0xcb, 0xd0, 0xc5, 0x5e, 0xd3, 0x62, 0x6d, 0x37, 0x60, 0x68, 0xb3, 0x76, 0x98, 0x87, 0xbe,
	0xa4, 0x4e, 0x7b, 0xb3, 0x1b, 0x8e, 0x91, 0x0f, 0xed, 0x13, 0x5b, 0x94, 0x4a, 0x52, 0x7d, 0xbb,
	0x1c, 0xb0, 0xef, 0xb1, 0x6f, 0xb3, 0x5d, 0xee, 0x23, 0x0c, 0xfd, 0x1a, 0xbb, 0x19, 0x48, 0x4a,
	0xb6, 0xec, 0x64, 0x37, 0xbb, 0xd4, 0x39, 0xbf, 0xff, 0x21, 0x75, 0xf8, 0xe7, 0x91, 0x08, 0x49,
	0x13, 0x65, 0xba, 0xa9, 0x4a, 0x4c, 0x72, 0x6d, 0xc7, 0xc0, 0x14, 0x62, 0x30, 0xea, 0x3d, 0x33,
	0x49, 0xea, 0x83, 0x9d, 0x07, 0x64, 0xed, 0x24, 0x51, 0x86, 0xde, 0x23, 0x2d, 0x94, 0x06, 0x94,
	0xe0, 0x11, 0x30, 0x6d, 0xb8, 0xd1, 0x61, 0xd0, 0x5e, 0x3d, 0xa8, 0x1d, 0xb5, 0xba, 0xfd, 0x22,
	0xde, 0x97, 0x22, 0xd1, 0x83, 0xe6, 0x8c, 0x3b, 0xb5, 0x58, 0xe7, 0xef, 0x0a, 0x69, 0x2e, 0x22,
	0x74, 0x9f, 0x6c, 0xa0, 0x60, 0x92, 0xc7, 0x10, 0x06, 0xed, 0x95, 0x83, 0xea, 0x71, 0xe5, 0x97,
	0x07, 0x2b, 0x9b, 0xc1, 0x60, 0x1d, 0xc5, 0x33, 0x1e, 0x03, 0xbd, 0x4e, 0xaa, 0x28, 0xd1, 0x30,
	0x83, 0x31, 0x84, 0x2b, 0xed, 0xe0, 0x60, 0x6d, 0xb0, 0x69, 0x03, 0x2f, 0x31, 0x06, 0xda, 0x21,
	0x0d, 0x2d, 0xe3, 0x94, 0xa1, 0x60, 0x28, 0x87, 0xf0, 0x2e, 0x5c, 0x6d, 0x07, 0x07, 0x8d, 0x41,
	0xcd, 0x06, 0xfb, 0xa2, 0x6f, 0x43, 0xf4, 0x13, 0xd2, 0x4c, 0xb9, 0x02, 0x69, 0x18, 0x07, 0xbf,
	0xce, 0x5a, 0x3b, 0x38, 0xa8, 0x0e, 0xea, 0x3e, 0xfa, 0x10, 0xdc, 0x32, 0x77, 0xc9, 0x36, 0x8c,
	0x14, 0x68, 0xcd, 0x5e, 0x67, 0x90, 0x01, 0x43, 0x29, 0x92, 0xb0, 0xe2, 0xde, 0xaa, 0xd6, 0x7d,
	0x61, 0x43, 0xee, 0x0d, 0x06, 0x2d, 0x4f, 0xb9, 0x88, 0x7d, 0x01, 0x7a, 0x9f, 0x50, 0x94, 0x17,
	0x94, 0xeb, 0x17, 0x95, 0x5b, 0x39, 0x36, 0x97, 0xde, 0x21, 0x8d, 0x42, 0xea, 0xbb, 0xb8, 0xd1,
	0x0e, 0x16, 0xbb, 0xe8, 0x95, 0xf5, 0x9c, 0x72, 0x4f, 0xf4, 0x88, 0xd4, 0xa1, 0x2c, 0xda, 0xbc,
	0x5c, 0x54, 0x83, 0x92, 0xe6, 0x5b, 0xd2, 0x2c, 0x56, 0x02, 0xa5, 0x12, 0xa5, 0xc3, 0xaa, 0x53,
	0x5d, 0xed, 0xf6, 0x7d, 0x78, 0x26, 0x7e, 0xec, 0xd2, 0x83, 0x62, 0x63, 0xfe, 0x91, 0xde, 0x23,
	0x21, 0x0a, 0xc6, 0x87, 0x31, 0x4a, 0xd4, 0x46, 0x71, 0x83, 0x89, 0x74, 0xcb, 0x67, 0x3a, 0x24,
	0xae, 0x9b, 0x7b, 0x28, 0x1e, 0x2e, 0xa4, 0x4f, 0x5d, 0x96, 0x1e, 0x91, 0x5d, 0x14, 0x2c, 0x49,
	0xc1, 0x47, 0xf9, 0xb4, 0x90, 0xd5, 0x9c, 0x6c, 0x07, 0xc5, 0xf3, 0x79, 0x2e, 0xd7, 0xdc, 0x20,
	0x4d, 0x14, 0x6c, 0x08, 0x3a, 0x52, 0x98, 0xda, 0x4c, 0x58, 0x77, 0x70, 0x03, 0xc5, 0xa3, 0x79,
	0x90, 0x7e, 0xe1, 0x30, 0xa3, 0xb8, 0xd4, 0x68, 0x03, 0x3a, 0x6c, 0x58, 0x7b, 0x38, 0x03, 0x85,
	0x81, 0xa5, 0x5f, 0xce, 0x73, 0xb4, 0x43, 0xea, 0x28, 0x9e, 0x70, 0x6d, 0xbe, 0x1b, 0x73, 0x39,
	0x82, 0xb0, 0xe9, 0x9c, 0xb2, 0x10, 0xa3, 0x6d, 0x52, 0x43, 0xf1, 0x03, 0x8e, 0xc6, 0xa7, 0x29,
	0xc0, 0x30, 0x6c, 0x79, 0x33, 0x95, 0x42, 0xf4, 0x1b, 0xd2, 0x80, 0x85, 0x3e, 0x6e, 0xb9, 0x3e,
	0xee, 0x75, 0x1f, 0x5f, 0xda, 0xc6, 0xfc, 0xa4, 0xfc, 0x53, 0xe7, 0xf7, 0x35, 0x42, 0xe6, 0x86,
	0xa0, 0x07, 0xa4, 0xee, 0x1d, 0x23, 0xb3, 0xf8, 0x0c, 0x54, 0x18, 0xd8, 0xe5, 0x0a, 0xfb, 0xd7,
	0x5c, 0xea, 0x99, 0xcb, 0xd0, 0xff, 0x91, 0x8d, 0x94, 0x47, 0x13, 0x30, 0xda, 0xdf, 0x80, 0xe2,
	0x15, 0x8b, 0x28, 0xbd, 0x4e, 0x2a, 0x67, 0xef, 0x0d, 0x68, 0xe7, 0xff, 0x59, 0xda, 0xc7, 0xe8,
	0x2d, 0xb2, 0x6d, 0x38, 0x4e, 0xd9, 0x50, 0x25, 0x29, 0x2b, 0xea, 0xac, 0x95, 0xc1, 0x96, 0xcd,
	0x3f, 0x52, 0x49, 0x7a, 0x92, 0xd7, 0x3b, 0x24, 0x2d, 0xb5, 0x24, 0xa8, 0x2c, 0xf4, 0x56, 0x2d,
	0xe0, 0x9f, 0x93, 0x46, 0x81, 0xfb, 0x6d, 0xac, 0x97, 0xe1, 0x9a, 0x87, 0x8f, 0xdd, 0x66, 0x7a,
	0x64, 0x4b, 0xc1, 0x70, 0xb1, 0xf4, 0x46, 0x99, 0x6e, 0x2a, 0x18, 0x96, 0x6b, 0xdf, 0x24, 0xcd,
	0x99, 0xc0, 0x17, 0xdf, 0x2c, 0xe3, 0xf5, 0x1c, 0xf7, 0xd5, 0xef, 0x92, 0x2b, 0xfc, 0xcd, 0x88,
	0x9d, 0x65, 0x42, 0x80, 0x62, 0x49, 0x14, 0x65, 0x29, 0x97, 0xd1, 0x7b, 0xe7, 0x76, 0x2f, 0x69,
	0x07, 0x03, 0xca, 0xdf, 0x8c, 0x8e, 0x1d, 0xf1, 0xbc, 0x00, 0xac, 0x30, 0xca, 0xd4, 0x45, 0x21,
	0x59, 0x10, 0x46, 0x99, 0x5a, 0x16, 0xde, 0x27, 0xbb, 0x29, 0xf0, 0xc9, 0x45, 0x65, 0xad, 0xac,
	0xdc, 0xb1, 0xcc, 0x25, 0x52, 0x3e, 0x9d, 0x26, 0x11, 0x37, 0x30, 0x2c, 0xf4, 0x1a, 0x3f, 0x80,
	0x73, 0xfb, 0x5c, 0x3a, 0x63, 0xbc, 0xfe, 0x14, 0x3f, 0x40, 0xe7, 0xb7, 0xd5, 0xd2, 0x1c, 0xf5,
	0x6e, 0xf2, 0x73, 0x34, 0x9d, 0xb8, 0x61, 0x5c, 0x6a, 0xd0, 0x3a, 0x8a, 0x93, 0x89, 0xb1, 0xfe,
	0xaf, 0xda, 0x8b, 0x18, 0x99, 0x0b, 0x2e, 0xda, 0x44, 0xf1, 0xdc, 0x85, 0xe9, 0x67, 0xf6, 0x8e,
	0xb0, 0x5b, 0x1a, 0x22, 0x5f, 0x68, 0xb5, 0xbc, 0x11, 0x82, 0xc2, 0x66, 0x5c, 0xb1, 0x9b, 0xee,
	0xea, 0x39, 0x30, 0xaf, 0xb8, 0x56, 0x46, 0xeb, 0x1e, 0xcd, 0xab, 0xfe, 0x9f, 0x10, 0x14, 0x2c,
	0xcb, 0x6b, 0x56, 0x96, 0x96, 0x7e, 0xe5, 0x2b, 0x7a, 0x28, 0xce, 0xa1, 0xf5, 0x25, 0xe8, 0x69,
	0x19, 0x3a, 0xcb, 0xa1, 0x8d, 0x25, 0xe8, 0xd8, 0x43, 0x6d, 0xb2, 0x89, 0xc2, 0x5f, 0xcf, 0x45,
	0xab, 0x6c, 0xa0, 0x70, 0x17, 0xd1, 0xda, 0xd5, 0xb6, 0x8a, 0x67, 0x1a, 0x7c, 0xa5, 0xea, 0x82,
	0x5d, 0x51, 0x9c, 0xd8, 0x94, 0x2b, 0x76, 0xcf, 0x8d, 0xaf, 0x4c, 0x4e, 0x64, 0xf2, 0x56, 0x32,
	0xf7, 0x19, 0xf4, 0x12, 0x52, 0x96, 0x50, 0x14, 0xaf, 0x3c, 0x72, 0x62, 0x09, 0xab, 0xec, 0xfc,
	0xba, 0x46, 0xf6, 0x2e, 0x1f, 0xae, 0xf9, 0x51, 0xe4, 0x03, 0x24, 0x58, 0x7a, 0x8b, 0x9c, 0xf1,
	0x47, 0x81, 0x92, 0xbd, 0xb6, 0xce, 0x5f, 0x3a, 0x31, 0x82, 0xa2, 0x2f, 0x5f, 0xb8, 0x04, 0x3d,
	0x22, 0xd4, 0x83, 0x42, 0xf1, 0x18, 0x8a, 0xaa, 0x0b, 0x73, 0xa0, 0x65, 0xf1, 0xef, 0x6d, 0x3a,
	0x2f, 0xfe, 0xa9, 0x9d, 0x73, 0x6c, 0x88, 0x3a, 0xe2, 0x6a, 0xb8, 0x34, 0x0b, 0x08, 0x8a, 0x47,
	0x79, 0x82, 0xde, 0x70, 0x1c, 0x4a, 0xa6, 0x32, 0xb9, 0x7c, 0x74, 0x55, 0x5b, 0x74, 0x60, 0xe3,
	0xf4, 0x2b, 0x72, 0xc5, 0x63, 0xd3, 0xdb, 0x0c, 0x65, 0x94, 0xc4, 0xe9, 0x14, 0x2e, 0x4c, 0x81,
	0x6d, 0xcb, 0x3f, 0xb9, 0xdd, 0x9f, 0xe7, 0xe9, 0x1d, 0xb2, 0x93, 0xeb, 0x8e, 0xa2, 0x31, 0x97,
	0xc5, 0xde, 0x17, 0xce, 0x75, 0xcb, 0xc9, 0x5c, 0x3e, 0xdf, 0xfc, 0x43, 0x72, 0xad, 0x50, 0xb1,
	0x18, 0x75, 0xcc, 0x4d, 0x34, 0x76, 0x7f, 0x07, 0x49, 0x66, 0x96, 0x86, 0xc3, 0x9e, 0x17, 0x3f,
	0xcd, 0xa9, 0x97, 0x39, 0x44, 0xbf, 0x24, 0xdb, 0x79, 0xcf, 0x50, 0x24, 0xe5, 0x2f, 0xe2, 0x7c,
	0x0a, 0xb9, 0x96, 0xa1, 0x48, 0x66, 0x1f, 0xc0, 0xdd, 0xbc, 0x13, 0xa0, 0x93, 0x4c, 0x45, 0xb3,
	0x46, 0x2f, 0xfb, 0xa0, 0x2f, 0x07, 0x39, 0x91, 0x0f, 0xfd, 0x88, 0xec, 0x3e, 0xfe, 0xcf, 0x2e,
	0x58, 0x3a, 0xa8, 0x95, 0x7f, 0x39, 0xa8, 0xaf, 0x9f, 0x10, 0x7a, 0x2e, 0x53, 0xc5, 0xe6, 0xbf,
	0x65, 0xf0, 0xce, 0xd0, 0xab, 0xdd, 0x1f, 0x33, 0x89, 0x29, 0xa8, 0x67, 0x60, 0xde, 0x26, 0x6a,
	0xa2, 0x4f, 0x41, 0xea, 0xc2, 0x1d, 0xb5, 0xa3, 0x4a, 0xd7, 0xfe, 0xcd, 0x0d, 0xb6, 0xac, 0x72,
	0xbe, 0xb9, 0x77, 0xe6, 0xf8, 0xe7, 0x3f, 0x3e, 0xee, 0x07, 0x7f, 0x7e, 0xdc, 0x0f, 0xfe, 0xfa,
	0xb8, 0x1f, 0xfc, 0x34, 0x18, 0xa1, 0xe9, 0x9e, 0xfb, 0x42, 0x5d, 0x09, 0xa6, 0x87, 0x11, 0x9c,
	0x81, 0x1a, 0xf5, 0xc6, 0xc0, 0xa7, 0x66, 0x7c, 0x96, 0x98, 0x43, 0x94, 0x23, 0xd0, 0xe6, 0xf0,
	0xdc, 0xe0, 0xa1, 0xe4, 0x06, 0xdf, 0x40, 0x2f, 0x9d, 0x8c, 0x7a, 0xe7, 0x06, 0x7b, 0x7c, 0xc8,
	0x53, 0x03, 0x4a, 0xf7, 0xd8, 0x79, 0x26, 0x13, 0xdd, 0xd3, 0xd1, 0x18, 0x62, 0xfe, 0x4f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xd4, 0x6a, 0xd8, 0x79, 0x6b, 0x0a, 0x00, 0x00,
}

func (m *Port) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Port) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Port) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InterfaceStats) > 0 {
		for iNdEx := len(m.InterfaceStats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InterfaceStats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPort(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceInfos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceInfos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EgressErrors != nil {
		{
			size, err := m.EgressErrors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPort(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.IfHighSpeed != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfHighSpeed))
		i--
		dAtA[i] = 0x78
	}
	if m.IfLastChange != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfLastChange))
		i--
		dAtA[i] = 0x70
	}
	if m.IfTransitions != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfTransitions))
		i--
		dAtA[i] = 0x68
	}
	if m.IfDescription != nil {
		i -= len(*m.IfDescription)
		copy(dAtA[i:], *m.IfDescription)
		i = encodeVarintPort(dAtA, i, uint64(len(*m.IfDescription)))
		i--
		dAtA[i] = 0x62
	}
	if m.IfOperationalStatus != nil {
		i -= len(*m.IfOperationalStatus)
		copy(dAtA[i:], *m.IfOperationalStatus)
		i = encodeVarintPort(dAtA, i, uint64(len(*m.IfOperationalStatus)))
		i--
		dAtA[i] = 0x5a
	}
	if m.IfAdministrationStatus != nil {
		i -= len(*m.IfAdministrationStatus)
		copy(dAtA[i:], *m.IfAdministrationStatus)
		i = encodeVarintPort(dAtA, i, uint64(len(*m.IfAdministrationStatus)))
		i--
		dAtA[i] = 0x52
	}
	if m.IngressErrors != nil {
		{
			size, err := m.IngressErrors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPort(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.EgressStats != nil {
		{
			size, err := m.EgressStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPort(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.IngressStats != nil {
		{
			size, err := m.IngressStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPort(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.IngressQueueInfo) > 0 {
		for iNdEx := len(m.IngressQueueInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IngressQueueInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPort(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.EgressQueueInfo) > 0 {
		for iNdEx := len(m.EgressQueueInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EgressQueueInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPort(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ParentAeName != nil {
		i -= len(*m.ParentAeName)
		copy(dAtA[i:], *m.ParentAeName)
		i = encodeVarintPort(dAtA, i, uint64(len(*m.ParentAeName)))
		i--
		dAtA[i] = 0x22
	}
	if m.SnmpIfIndex != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.SnmpIfIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.InitTime != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.InitTime))
		i--
		dAtA[i] = 0x10
	}
	if m.IfName == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("if_name")
	} else {
		i -= len(*m.IfName)
		copy(dAtA[i:], *m.IfName)
		i = encodeVarintPort(dAtA, i, uint64(len(*m.IfName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueueStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueueStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AllocatedBufferSize != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.AllocatedBufferSize))
		i--
		dAtA[i] = 0x60
	}
	if m.PeakBufferOccupancy != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.PeakBufferOccupancy))
		i--
		dAtA[i] = 0x58
	}
	if m.CurBufferOccupancy != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.CurBufferOccupancy))
		i--
		dAtA[i] = 0x50
	}
	if m.AvgBufferOccupancy != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.AvgBufferOccupancy))
		i--
		dAtA[i] = 0x48
	}
	if m.RedDropBytes != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.RedDropBytes))
		i--
		dAtA[i] = 0x40
	}
	if m.RedDropPackets != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.RedDropPackets))
		i--
		dAtA[i] = 0x38
	}
	if m.RlDropBytes != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.RlDropBytes))
		i--
		dAtA[i] = 0x30
	}
	if m.RlDropPackets != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.RlDropPackets))
		i--
		dAtA[i] = 0x28
	}
	if m.TailDropPackets != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.TailDropPackets))
		i--
		dAtA[i] = 0x20
	}
	if m.Bytes != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.Bytes))
		i--
		dAtA[i] = 0x18
	}
	if m.Packets != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.Packets))
		i--
		dAtA[i] = 0x10
	}
	if m.QueueNumber != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.QueueNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IfUnknownProtoPkts != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfUnknownProtoPkts))
		i--
		dAtA[i] = 0x50
	}
	if m.IfPausePkts != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfPausePkts))
		i--
		dAtA[i] = 0x48
	}
	if m.IfError != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfError))
		i--
		dAtA[i] = 0x40
	}
	if m.IfBcPkts != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfBcPkts))
		i--
		dAtA[i] = 0x38
	}
	if m.IfMcPkts != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfMcPkts))
		i--
		dAtA[i] = 0x30
	}
	if m.IfUcPkts != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfUcPkts))
		i--
		dAtA[i] = 0x28
	}
	if m.If_1SecOctets != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.If_1SecOctets))
		i--
		dAtA[i] = 0x20
	}
	if m.If_1SecPkts != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.If_1SecPkts))
		i--
		dAtA[i] = 0x18
	}
	if m.IfOctets != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfOctets))
		i--
		dAtA[i] = 0x10
	}
	if m.IfPkts != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfPkts))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IngressInterfaceErrors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngressInterfaceErrors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngressInterfaceErrors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IfInResourceErrors != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfInResourceErrors))
		i--
		dAtA[i] = 0x50
	}
	if m.IfInFifoErrors != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfInFifoErrors))
		i--
		dAtA[i] = 0x48
	}
	if m.IfInL2MismatchTimeouts != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfInL2MismatchTimeouts))
		i--
		dAtA[i] = 0x40
	}
	if m.IfInL2ChanErrors != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfInL2ChanErrors))
		i--
		dAtA[i] = 0x38
	}
	if m.IfInL3Incompletes != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfInL3Incompletes))
		i--
		dAtA[i] = 0x30
	}
	if m.IfInRunts != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfInRunts))
		i--
		dAtA[i] = 0x28
	}
	if m.IfDiscards != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfDiscards))
		i--
		dAtA[i] = 0x20
	}
	if m.IfInFrameErrors != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfInFrameErrors))
		i--
		dAtA[i] = 0x18
	}
	if m.IfInQdrops != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfInQdrops))
		i--
		dAtA[i] = 0x10
	}
	if m.IfErrors != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfErrors))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EgressInterfaceErrors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EgressInterfaceErrors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EgressInterfaceErrors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IfDiscards != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfDiscards))
		i--
		dAtA[i] = 0x10
	}
	if m.IfErrors != nil {
		i = encodeVarintPort(dAtA, i, uint64(*m.IfErrors))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPort(dAtA []byte, offset int, v uint64) int {
	offset -= sovPort(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Port) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InterfaceStats) > 0 {
		for _, e := range m.InterfaceStats {
			l = e.Size()
			n += 1 + l + sovPort(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfaceInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfName != nil {
		l = len(*m.IfName)
		n += 1 + l + sovPort(uint64(l))
	}
	if m.InitTime != nil {
		n += 1 + sovPort(uint64(*m.InitTime))
	}
	if m.SnmpIfIndex != nil {
		n += 1 + sovPort(uint64(*m.SnmpIfIndex))
	}
	if m.ParentAeName != nil {
		l = len(*m.ParentAeName)
		n += 1 + l + sovPort(uint64(l))
	}
	if len(m.EgressQueueInfo) > 0 {
		for _, e := range m.EgressQueueInfo {
			l = e.Size()
			n += 1 + l + sovPort(uint64(l))
		}
	}
	if len(m.IngressQueueInfo) > 0 {
		for _, e := range m.IngressQueueInfo {
			l = e.Size()
			n += 1 + l + sovPort(uint64(l))
		}
	}
	if m.IngressStats != nil {
		l = m.IngressStats.Size()
		n += 1 + l + sovPort(uint64(l))
	}
	if m.EgressStats != nil {
		l = m.EgressStats.Size()
		n += 1 + l + sovPort(uint64(l))
	}
	if m.IngressErrors != nil {
		l = m.IngressErrors.Size()
		n += 1 + l + sovPort(uint64(l))
	}
	if m.IfAdministrationStatus != nil {
		l = len(*m.IfAdministrationStatus)
		n += 1 + l + sovPort(uint64(l))
	}
	if m.IfOperationalStatus != nil {
		l = len(*m.IfOperationalStatus)
		n += 1 + l + sovPort(uint64(l))
	}
	if m.IfDescription != nil {
		l = len(*m.IfDescription)
		n += 1 + l + sovPort(uint64(l))
	}
	if m.IfTransitions != nil {
		n += 1 + sovPort(uint64(*m.IfTransitions))
	}
	if m.IfLastChange != nil {
		n += 1 + sovPort(uint64(*m.IfLastChange))
	}
	if m.IfHighSpeed != nil {
		n += 1 + sovPort(uint64(*m.IfHighSpeed))
	}
	if m.EgressErrors != nil {
		l = m.EgressErrors.Size()
		n += 2 + l + sovPort(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueueStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueueNumber != nil {
		n += 1 + sovPort(uint64(*m.QueueNumber))
	}
	if m.Packets != nil {
		n += 1 + sovPort(uint64(*m.Packets))
	}
	if m.Bytes != nil {
		n += 1 + sovPort(uint64(*m.Bytes))
	}
	if m.TailDropPackets != nil {
		n += 1 + sovPort(uint64(*m.TailDropPackets))
	}
	if m.RlDropPackets != nil {
		n += 1 + sovPort(uint64(*m.RlDropPackets))
	}
	if m.RlDropBytes != nil {
		n += 1 + sovPort(uint64(*m.RlDropBytes))
	}
	if m.RedDropPackets != nil {
		n += 1 + sovPort(uint64(*m.RedDropPackets))
	}
	if m.RedDropBytes != nil {
		n += 1 + sovPort(uint64(*m.RedDropBytes))
	}
	if m.AvgBufferOccupancy != nil {
		n += 1 + sovPort(uint64(*m.AvgBufferOccupancy))
	}
	if m.CurBufferOccupancy != nil {
		n += 1 + sovPort(uint64(*m.CurBufferOccupancy))
	}
	if m.PeakBufferOccupancy != nil {
		n += 1 + sovPort(uint64(*m.PeakBufferOccupancy))
	}
	if m.AllocatedBufferSize != nil {
		n += 1 + sovPort(uint64(*m.AllocatedBufferSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InterfaceStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfPkts != nil {
		n += 1 + sovPort(uint64(*m.IfPkts))
	}
	if m.IfOctets != nil {
		n += 1 + sovPort(uint64(*m.IfOctets))
	}
	if m.If_1SecPkts != nil {
		n += 1 + sovPort(uint64(*m.If_1SecPkts))
	}
	if m.If_1SecOctets != nil {
		n += 1 + sovPort(uint64(*m.If_1SecOctets))
	}
	if m.IfUcPkts != nil {
		n += 1 + sovPort(uint64(*m.IfUcPkts))
	}
	if m.IfMcPkts != nil {
		n += 1 + sovPort(uint64(*m.IfMcPkts))
	}
	if m.IfBcPkts != nil {
		n += 1 + sovPort(uint64(*m.IfBcPkts))
	}
	if m.IfError != nil {
		n += 1 + sovPort(uint64(*m.IfError))
	}
	if m.IfPausePkts != nil {
		n += 1 + sovPort(uint64(*m.IfPausePkts))
	}
	if m.IfUnknownProtoPkts != nil {
		n += 1 + sovPort(uint64(*m.IfUnknownProtoPkts))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngressInterfaceErrors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfErrors != nil {
		n += 1 + sovPort(uint64(*m.IfErrors))
	}
	if m.IfInQdrops != nil {
		n += 1 + sovPort(uint64(*m.IfInQdrops))
	}
	if m.IfInFrameErrors != nil {
		n += 1 + sovPort(uint64(*m.IfInFrameErrors))
	}
	if m.IfDiscards != nil {
		n += 1 + sovPort(uint64(*m.IfDiscards))
	}
	if m.IfInRunts != nil {
		n += 1 + sovPort(uint64(*m.IfInRunts))
	}
	if m.IfInL3Incompletes != nil {
		n += 1 + sovPort(uint64(*m.IfInL3Incompletes))
	}
	if m.IfInL2ChanErrors != nil {
		n += 1 + sovPort(uint64(*m.IfInL2ChanErrors))
	}
	if m.IfInL2MismatchTimeouts != nil {
		n += 1 + sovPort(uint64(*m.IfInL2MismatchTimeouts))
	}
	if m.IfInFifoErrors != nil {
		n += 1 + sovPort(uint64(*m.IfInFifoErrors))
	}
	if m.IfInResourceErrors != nil {
		n += 1 + sovPort(uint64(*m.IfInResourceErrors))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EgressInterfaceErrors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfErrors != nil {
		n += 1 + sovPort(uint64(*m.IfErrors))
	}
	if m.IfDiscards != nil {
		n += 1 + sovPort(uint64(*m.IfDiscards))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPort(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPort(x uint64) (n int) {
	return sovPort(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Port) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPort
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPort
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceStats = append(m.InterfaceStats, &InterfaceInfos{})
			if err := m.InterfaceStats[len(m.InterfaceStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPort(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPort
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPort
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceInfos) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPort
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPort
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IfName = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InitTime = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnmpIfIndex", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SnmpIfIndex = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentAeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPort
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ParentAeName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressQueueInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPort
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressQueueInfo = append(m.EgressQueueInfo, &QueueStats{})
			if err := m.EgressQueueInfo[len(m.EgressQueueInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressQueueInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPort
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressQueueInfo = append(m.IngressQueueInfo, &QueueStats{})
			if err := m.IngressQueueInfo[len(m.IngressQueueInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPort
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IngressStats == nil {
				m.IngressStats = &InterfaceStats{}
			}
			if err := m.IngressStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPort
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EgressStats == nil {
				m.EgressStats = &InterfaceStats{}
			}
			if err := m.EgressStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPort
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IngressErrors == nil {
				m.IngressErrors = &IngressInterfaceErrors{}
			}
			if err := m.IngressErrors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfAdministrationStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPort
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IfAdministrationStatus = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfOperationalStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPort
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IfOperationalStatus = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPort
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IfDescription = &s
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfTransitions", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfTransitions = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfLastChange", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfLastChange = &v
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfHighSpeed", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfHighSpeed = &v
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPort
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPort
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EgressErrors == nil {
				m.EgressErrors = &EgressInterfaceErrors{}
			}
			if err := m.EgressErrors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPort(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPort
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPort
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("if_name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPort
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueNumber", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueueNumber = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Packets = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bytes = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TailDropPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TailDropPackets = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RlDropPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RlDropPackets = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RlDropBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RlDropBytes = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedDropPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RedDropPackets = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedDropBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RedDropBytes = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvgBufferOccupancy", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AvgBufferOccupancy = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurBufferOccupancy", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CurBufferOccupancy = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeakBufferOccupancy", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PeakBufferOccupancy = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatedBufferSize", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllocatedBufferSize = &v
		default:
			iNdEx = preIndex
			skippy, err := skipPort(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPort
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPort
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPort
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfPkts", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfPkts = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfOctets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfOctets = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field If_1SecPkts", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.If_1SecPkts = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field If_1SecOctets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.If_1SecOctets = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfUcPkts", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfUcPkts = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfMcPkts", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfMcPkts = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfBcPkts", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfBcPkts = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfError", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfError = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfPausePkts", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfPausePkts = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfUnknownProtoPkts", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfUnknownProtoPkts = &v
		default:
			iNdEx = preIndex
			skippy, err := skipPort(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPort
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPort
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressInterfaceErrors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPort
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressInterfaceErrors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressInterfaceErrors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfErrors", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfErrors = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfInQdrops", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfInQdrops = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfInFrameErrors", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfInFrameErrors = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfDiscards", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfDiscards = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfInRunts", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfInRunts = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfInL3Incompletes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfInL3Incompletes = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfInL2ChanErrors", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfInL2ChanErrors = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfInL2MismatchTimeouts", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfInL2MismatchTimeouts = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfInFifoErrors", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfInFifoErrors = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfInResourceErrors", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfInResourceErrors = &v
		default:
			iNdEx = preIndex
			skippy, err := skipPort(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPort
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPort
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EgressInterfaceErrors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPort
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EgressInterfaceErrors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EgressInterfaceErrors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfErrors", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfErrors = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfDiscards", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPort
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfDiscards = &v
		default:
			iNdEx = preIndex
			skippy, err := skipPort(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPort
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPort
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPort(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPort
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPort
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPort
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPort
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPort
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPort
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPort        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPort          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPort = fmt.Errorf("proto: unexpected end of group")
)
